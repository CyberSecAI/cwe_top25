{"ID": "1287", "Name": "Improper Validation of Specified Type of Input", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.", "ExtendedDescription": "\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "20", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "843", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Often"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context"]}], "PotentialMitigations": [{"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n", "Effectiveness": "High"}], "ObservedExamples": [{"Reference": "CVE-2024-37032", "Description": "Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama", "Link": "https://www.cve.org/CVERecord?id=CVE-2024-37032"}, {"Reference": "CVE-2008-2223", "Description": "SQL injection through an ID that was supposed to be numeric.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2223"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}], "Top25Examples": [{"Reference": "CVE-2022-22228", "Description": "An Improper Validation of Specified Type of Input vulnerability in the routing protocol daemon (rpd) of Juniper Networks Junos OS allows an attacker to cause an RPD memory leak leading to a Denial of Service (DoS). This memory leak only occurs when the attacker's packets are destined to any configured IPv6 address on the device. This issue affects: Juniper Networks Junos OS 21.1 versions prior to 21.1R3-S2; 21.2 versions prior to 21.2R3-S1; 21.3 versions prior to 21.3R3; 21.4 versions prior to 21.4R2; 22.1 versions prior to 22.1R2. This issue does not affect Juniper Networks Junos OS versions prior to 21.1R1."}, {"Reference": "CVE-2022-32226", "Description": "An improper access control vulnerability exists in Rocket.Chat <v5, <v4.8.2 and <v4.7.5 due to input data in the getUsersOfRoom Meteor server method is not type validated, so that MongoDB query operator objects are accepted by the server, so that instead of a matching rid String a$regex query can be executed, bypassing the room access permission check for every but the first matching room."}, {"Reference": "CVE-2021-0600", "Description": "In onCreate of DeviceAdminAdd.java, there is a possible way to mislead a user to activate a device admin app due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-179042963"}, {"Reference": "CVE-2021-38455", "Description": "The affected product\u2019s OS Service does not verify any given parameter. A user can supply any type of parameter that will be passed to inner calls without checking the type of the parameter or the value."}, {"Reference": "CVE-2021-43802", "Description": "Etherpad is a real-time collaborative editor. In versions prior to 1.8.16, an attacker can craft an `*.etherpad` file that, when imported, might allow the attacker to gain admin privileges for the Etherpad instance. This, in turn, can be used to install a malicious Etherpad plugin that can execute arbitrary code (including system commands). To gain privileges, the attacker must be able to trigger deletion of `express-session` state or wait for old `express-session` state to be cleaned up. Core Etherpad does not delete any `express-session` state, so the only known attacks require either a plugin that can delete session state or a custom cleanup process (such as a cron job that deletes old `sessionstorage:*` records). The problem has been fixed in version 1.8.16. If users cannot upgrade to 1.8.16 or install patches manually, several workarounds are available. Users may configure their reverse proxies to reject requests to `/p/*/import`, which will block all imports, not just `*.etherpad` imports; limit all users to read-only access; and/or prevent the reuse of `express_sid` cookie values that refer to deleted express-session state. More detailed information and general mitigation strategies may be found in the GitHub Security Advisory."}, {"Reference": "CVE-2021-44354", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44355", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44356", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44357", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44358", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetRec param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44359", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetCrop param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44360", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetNorm param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44361", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Set3G param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44362", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetCloudSchedule param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44363", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPush param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44364", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetWifi param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44365", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetDevName param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44366", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44367", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetUpnp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44368", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetNetPort param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44369", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetNtp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44370", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetFtp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44371", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetEmail param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44372", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetLocalLink param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44373", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetAutoFocus param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44374", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetMask param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44375", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44376", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetIsp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44377", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetImage param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44378", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetEnc param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44379", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetAutoMaint param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44380", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetTime param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44381", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPowerLed param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44382", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot.SetIrLights param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44383", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetAutoUpgrade param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44384", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPtzTattern param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44385", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPtzSerial param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44386", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPtzPatrol param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44387", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. SetPtzPreset param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44388", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Login param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44389", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetAbility param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44390", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Format param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44391", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetEnc param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44392", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetImage param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44393", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetIsp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44394", "Description": "Multiple denial of service vulnerabilities exist in the cgiserver.cgi JSON command parser functionality of Reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44395", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetMask param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44396", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Preview param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44397", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. rtmp=start param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44398", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. rtmp=stop param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44399", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetPtzPreset param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44400", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetPtzPatrol param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44401", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. PtzCtrl param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44402", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetPtzSerial param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44403", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetPtzTattern param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44404", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetZoomFocus param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44405", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. StartZoomFocus param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44406", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetAutoFocus param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44407", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. TestEmail param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44408", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. TestFtp param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44409", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. TestWifi param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44410", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. UpgradePrepare param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44411", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Search param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44412", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetRec param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44413", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. AddUser param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44414", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. DelUser param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44415", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. ModifyUser param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44416", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. Disconnect param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44417", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetAlarm param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44418", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetMdState param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2021-44419", "Description": "A denial of service vulnerability exists in the cgiserver.cgi JSON command parser functionality of reolink RLC-410W v3.0.0.136_20121102. A specially-crafted HTTP request can lead to a reboot. GetMdAlarm param is not object. An attacker can send an HTTP request to trigger this vulnerability."}, {"Reference": "CVE-2022-20545", "Description": "In bindArtworkAndColors of MediaControlPanel.java, there is a possible way to crash the phone due to improper input validation. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-239368697"}, {"Reference": "CVE-2022-20783", "Description": "A vulnerability in the packet processing functionality of Cisco TelePresence Collaboration Endpoint (CE) Software and Cisco RoomOS Software could allow an unauthenticated, remote attacker to cause a denial of service (DoS) condition on an affected device. This vulnerability is due to insufficient input validation. An attacker could exploit this vulnerability by sending crafted H.323 traffic to an affected device. A successful exploit could allow the attacker to cause the affected device to either reboot normally or reboot into maintenance mode, which could result in a DoS condition on the device."}, {"Reference": "CVE-2022-29191", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.GetSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29192", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29193", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.TensorSummaryV2` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29194", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.DeleteSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-4033", "Description": "The Quiz and Survey Master plugin for WordPress is vulnerable to input validation bypass via the 'question[id]' parameter in versions up to, and including, 8.0.4 due to insufficient input validation that allows attackers to inject content other than the specified value (i.e. a number, file path, etc..). This makes it possible attackers to submit values other than the intended input type."}, {"Reference": "CVE-2022-43723", "Description": "A vulnerability has been identified in SICAM PAS/PQS (All versions < V7.0), SICAM PAS/PQS (All versions >= 7.0 < V8.06). Affected software does not properly validate the input for a certain parameter in the s7ontcp.dll. This could allow an unauthenticated remote attacker to send messages and create a denial of service condition as the application crashes. At the time of assigning the CVE, the affected firmware version of the component has already been superseded by succeeding mainline versions."}, {"Reference": "CVE-2022-44556", "Description": "Missing parameter type validation in the DRM module. Successful exploitation of this vulnerability may affect availability. "}, {"Reference": "CVE-2022-21144", "Description": "This affects all versions of package libxmljs. When invoking the libxmljs.parseXml function with a non-buffer argument the V8 code will attempt invoking the .toString method of the argument. If the argument's toString value is not a Function object V8 will crash."}, {"Reference": "CVE-2022-29195", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.StagePeek` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `index` is a scalar but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29197", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.UnsortedSegmentJoin` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `num_segments` is a scalar but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29198", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SparseTensorToCSRSparseMatrix` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `dense_shape` is a vector and `indices` is a matrix (as part of requirements for sparse tensors) but there is no validation for this. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29199", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.LoadAndRemapMatrix does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `initializing_values` is a vector but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}]}
{"ID": "1288", "Name": "Improper Validation of Consistency within Input", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives a complex input with multiple elements or fields that must be consistent with each other, but it does not validate or incorrectly validates that the input is actually consistent.", "ExtendedDescription": "\n\nSome input data can be structured with multiple elements or fields that must be consistent with each other, e.g. a number-of-items field that is followed by the expected number of elements. When such complex inputs are inconsistent, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "20", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Often"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context"]}], "PotentialMitigations": [{"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n", "Effectiveness": "High"}], "ObservedExamples": [{"Reference": "CVE-2018-16733", "Description": "product does not validate that the start block appears before the end block", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-16733"}, {"Reference": "CVE-2006-3790", "Description": "size field that is inconsistent with packet size leads to buffer over-read", "Link": "https://www.cve.org/CVERecord?id=CVE-2006-3790"}, {"Reference": "CVE-2008-4114", "Description": "system crash with offset value that is inconsistent with packet size", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4114"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}], "Top25Examples": [{"Reference": "CVE-2021-0163", "Description": "Improper Validation of Consistency within input in software for Intel(R) PROSet/Wireless Wi-Fi and Killer(TM) Wi-Fi in Windows 10 and 11 may allow an unauthenticated user to potentially enable escalation of privilege via adjacent access."}, {"Reference": "CVE-2021-0173", "Description": "Improper Validation of Consistency within input in firmware for some Intel(R) PROSet/Wireless Wi-Fi in multiple operating systems and some Killer(TM) Wi-Fi in Windows 10 and 11 may allow a unauthenticated user to potentially enable denial of service via adjacent access."}, {"Reference": "CVE-2021-0177", "Description": "Improper Validation of Consistency within input in software for Intel(R) PROSet/Wireless Wi-Fi and Killer(TM) Wi-Fi in Windows 10 and 11 may allow an unauthenticated user to potentially enable denial of service via adjacent access."}, {"Reference": "CVE-2021-41531", "Description": "NLnet Labs Routinator prior to 0.10.0 produces invalid RTR payload if an RPKI CA uses too large values in the max-length parameter in a ROA. This will lead to RTR clients such as routers to reject the RPKI data set, effectively disabling Route Origin Validation."}]}
{"ID": "1289", "Name": "Improper Validation of Unsafe Equivalence in Input", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives an input value that is used as a resource identifier or other type of reference, but it does not validate or incorrectly validates that the input is equivalent to a potentially-unsafe value.", "ExtendedDescription": "\n\nAttackers can sometimes bypass input validation schemes by finding inputs that appear to be safe, but will be dangerous when processed at a lower layer or by a downstream component. For example, a simple XSS protection mechanism might try to validate that an input has no script tags using case-sensitive matching, but since HTML is case-insensitive when processed by web browsers, an attacker could inject script and trigger XSS.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "20", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "41", "ViewID": "1000"}, {"Nature": "PeerOf", "CweID": "178", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Often"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context"]}], "PotentialMitigations": [{"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n", "Effectiveness": "High"}], "ObservedExamples": [{"Reference": "CVE-2021-39155", "Description": "Chain: A microservice integration and management platform compares the hostname in the HTTP Host header in a case-sensitive way (CWE-178, CWE-1289), allowing bypass of the authorization policy (CWE-863) using a hostname with mixed case or other variations.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-39155"}, {"Reference": "CVE-2020-11053", "Description": "Chain: Go-based Oauth2 reverse proxy can send the authenticated user to another site at the end of the authentication flow. A redirect URL with HTML-encoded whitespace characters can bypass the validation (CWE-1289) to redirect to a malicious site (CWE-601)", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-11053"}, {"Reference": "CVE-2005-0269", "Description": "File extension check in forum software only verifies extensions that contain all lowercase letters, which allows remote attackers to upload arbitrary files via file extensions that include uppercase letters.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0269"}, {"Reference": "CVE-2001-1238", "Description": "Task Manager does not allow local users to end processes with uppercase letters named (1) winlogon.exe, (2) csrss.exe, (3) smss.exe and (4) services.exe via the Process tab which could allow local users to install Trojan horses that cannot be stopped.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1238"}, {"Reference": "CVE-2004-2214", "Description": "HTTP server allows bypass of access restrictions using URIs with mixed case.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2214"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}], "Top25Examples": [{"Reference": "CVE-2021-29468", "Description": "Cygwin Git is a patch set for the git command line tool for the cygwin environment. A specially crafted repository that contains symbolic links as well as files with backslash characters in the file name may cause just-checked out code to be executed while checking out a repository using Git on Cygwin. The problem will be patched in the Cygwin Git v2.31.1-2 release. At time of writing, the vulnerability is present in the upstream Git source code; any Cygwin user who compiles Git for themselves from upstream sources should manually apply a patch to mitigate the vulnerability. As mitigation users should not clone or pull from repositories from untrusted sources. CVE-2019-1354 was an equivalent vulnerability in Git for Visual Studio."}, {"Reference": "CVE-2022-0675", "Description": "In certain situations it is possible for an unmanaged rule to exist on the target system that has the same comment as the rule specified in the manifest. This could allow for unmanaged rules to exist on the target system and leave the system in an unsafe state."}]}
{"ID": "129", "Name": "Improper Validation of Array Index", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1285", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "20", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "119", "ViewID": "1000"}, {"Nature": "CanPrecede", "CweID": "823", "ViewID": "1000"}, {"Nature": "CanPrecede", "CweID": "789", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Resultant", "Description": "The most common condition situation leading to an out-of-bounds array index is the use of loop index variables as buffer indexes. If the end condition for the loop is subject to a flaw, the index can grow or shrink unbounded, therefore causing a buffer overflow or underflow. Another common situation leading to this condition is the use of a function's return value, or the resulting value of a calculation directly as an index in to a buffer."}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Often"}, {"Type": "Language", "Name": "C++", "Prevalence": "Often"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "out-of-bounds array index"}, {"Term": "index-out-of-range"}, {"Term": "array index underflow"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Availability"], "Impact": ["DoS: Crash, Exit, or Restart"], "Note": "Use of an index that is outside the bounds of an array will very likely result in the corruption of relevant memory and perhaps instructions, leading to a crash, if the values are outside of the valid memory area."}, {"Scope": ["Integrity"], "Impact": ["Modify Memory"], "Note": "If the memory corrupted is data, rather than instructions, the system will continue to function with improper values."}, {"Scope": ["Confidentiality", "Integrity"], "Impact": ["Modify Memory", "Read Memory"], "Note": "Use of an index that is outside the bounds of an array can also trigger out-of-bounds read or write operations, or operations on the wrong objects; i.e., \"buffer overflows\" are not always the result. This may result in the exposure or modification of sensitive data."}, {"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"], "Note": "If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow and possibly without the use of large inputs if a precise index can be controlled."}, {"Scope": ["Integrity", "Availability", "Confidentiality"], "Impact": ["DoS: Crash, Exit, or Restart", "Execute Unauthorized Code or Commands", "Read Memory", "Modify Memory"], "Note": "A single fault could allow either an overflow (CWE-788) or underflow (CWE-786) of the array index. What happens next will depend on the type of operation being performed out of bounds, but can expose sensitive information, cause a system crash, or possibly lead to arbitrary code execution."}], "DetectionMethods": [{"DetectionMethodID": "DM-1", "Method": "Automated Static Analysis", "Description": "\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report array index errors that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n", "Effectiveness": "High", "EffectivenessNotes": "This is not a perfect solution, since 100% accuracy and coverage are not feasible."}, {"DetectionMethodID": "DM-2", "Method": "Automated Dynamic Analysis", "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."}, {"Method": "Black Box", "Description": "Black box methods might not get the needed code coverage within limited time constraints, and a dynamic test might not produce any noticeable side effects even if it is successful."}], "PotentialMitigations": [{"MitigationID": "MIT-7", "Phase": ["Architecture and Design"], "Strategy": "Input Validation", "Description": "Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173)."}, {"MitigationID": "MIT-15", "Phase": ["Architecture and Design"], "Description": "\n\nFor any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.\n\n\nEven though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.\n"}, {"MitigationID": "MIT-3", "Phase": ["Requirements"], "Strategy": "Language Selection", "Description": "\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.\n"}, {"MitigationID": "MIT-11", "Phase": ["Operation", "Build and Compilation"], "Strategy": "Environment Hardening", "Description": "\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"}, {"MitigationID": "MIT-12", "Phase": ["Operation"], "Strategy": "Environment Hardening", "Description": "\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n\n\nWhen accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.\n"}, {"MitigationID": "MIT-35", "Phase": ["Implementation"], "Description": "Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow."}, {"MitigationID": "MIT-17", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Environment Hardening", "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."}, {"MitigationID": "MIT-22", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Sandbox or Jail", "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n", "Effectiveness": "Limited", "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In the code snippet below, an untrusted integer value is used to reference an object in an array."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic String getValue(int index) {\n\t\treturn array[index];\n\t}\n```"}, {"BodyText": "If index is outside of the range of the array, this may result in an ArrayIndexOutOfBounds Exception being raised."}]}, {"ID": "DX-34", "Entries": [{"IntroText": "The following example takes a user-supplied value to allocate an array of objects and then operates on the array."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprivate void buildList ( int untrustedListSize ){\n\t\tif ( 0 > untrustedListSize ){\n\t\t\tdie(\"Negative value supplied for list size, die evil hacker!\");\n\t\t}\n\t\tWidget[] list = new Widget [ untrustedListSize ];\n\t\tlist[0] = new Widget();\n\t}\n```"}, {"BodyText": "This example attempts to build a list from a user-specified value, and even checks to ensure a non-negative value is supplied. If, however, a 0 value is provided, the code will build an array of size 0 and then try to store a new Widget in the first location, causing an exception to be thrown."}]}, {"ID": "DX-100", "Entries": [{"IntroText": "In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint getValueFromArray(int *array, int len, int index) {\n\t\t\tint value;\n```\n// check that the array index is less than the maximum* \n\t\t\t\n\t\t\t\n\t\t\t *// length of the array* \n\t\t\tif (index < len) {\n\t\t\t```\n```\n// get the value at the specified index of the array* \n\t\t\t\t\tvalue = array[index];}\n\t\t\t\n\t\t\t *// if array index is invalid then output error message* \n\t\t\t\n\t\t\t\n\t\t\t *// and return value indicating error* \n\t\t\telse {\n\t\t\t```\n\t\t\t\tprintf(\"Value is: %d\\n\", array[index]);\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\treturn value;\n\t}\n```"}, {"BodyText": "However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."}, {"Nature": "Good", "Language": "C", "ExampleCode": "```\n\t...\n```\n// check that the array index is within the correct* \n\t\n\t\n\t *// range of values for the array* \n\tif (index >= 0 && index < len) {\n\t\n\t..."}]}, {"ID": "DX-134", "Entries": [{"IntroText": "The following example retrieves the sizes of messages for a pop3 mail server. The message sizes are retrieved from a socket that returns in a buffer the message number and the message size, the message number (num) and size (size) are extracted from the buffer and the message size is placed into an array using the message number for the array index."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n```\n/* capture the sizes of all messages */* \n\tint getsizes(int sock, int count, int *sizes) {\n\t```\n\t\t\t...\n\t\t\tchar buf[BUFFER_SIZE];\n\t\t\tint ok;\n\t\t\tint num, size;\n```\n// read values from socket and added to sizes array* \n\t\t\twhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n\t\t\t{\n\t\t\t```\n```\n// continue read from socket until buf only contains '.'* \n\t\t\t\t\tif (DOTLINE(buf))\n\t\t\t\t\t```\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t else if (sscanf(buf, \"%d %d\", &num, &size) == 2)\n\t\t\t\t\t\tsizes[num - 1] = size;\n\t\t\t}\n\t\t\t\t...\n\t}\n```"}, {"BodyText": "In this example the message number retrieved from the buffer could be a value that is outside the allowable range of indices for the array and could possibly be a negative number. Without proper validation of the value to be used for the array index an array overflow could occur and could potentially lead to unauthorized access to memory addresses and system crashes. The value of the array index should be validated to ensure that it is within the allowable range of indices for the array as in the following code."}, {"Nature": "Good", "Language": "C", "ExampleCode": "```\n```\n/* capture the sizes of all messages */* \n\tint getsizes(int sock, int count, int *sizes) {\n\t```\n\t\t\t...\n\t\t\tchar buf[BUFFER_SIZE];\n\t\t\tint ok;\n\t\t\tint num, size;\n```\n// read values from socket and added to sizes array* \n\t\t\twhile ((ok = gen_recv(sock, buf, sizeof(buf))) == 0)\n\t\t\t{\n\t\t\t```\n```\n// continue read from socket until buf only contains '.'* \n\t\t\t\t\tif (DOTLINE(buf))\n\t\t\t\t\t```\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (sscanf(buf, \"%d %d\", &num, &size) == 2) {\n\t\t\t\t\t\t\tif (num > 0 && num <= (unsigned)count)\n\t\t\t\t\t\t\t\tsizes[num - 1] = size;\n\t\t\t\t\t\t\telse\n```\n/* warn about possible attempt to induce buffer overflow */* \n\t\t\t\t\t\t\t\t\treport(stderr, \"Warning: ignoring bogus data for message sizes returned by server.\\n\");}}\n\t\t\t```\n\t\t\t\t...\n\t}\n```"}]}, {"ID": "DX-133", "Entries": [{"IntroText": "In the following example the method displayProductSummary is called from a Web service servlet to retrieve product summary information for display to the user. The servlet obtains the integer value of the product number from the user and passes it to the displayProductSummary method. The displayProductSummary method passes the integer value of the product number to the getProductSummary method which obtains the product summary from the array object containing the project summaries using the integer value of the product number as the array index."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n```\n// Method called from servlet to obtain product information* \n\tpublic String displayProductSummary(int index) {\n\t\n\t```\n\t\t\tString productSummary = new String(\"\");\n\t\t\ttry {\n\t\t\t\tString productSummary = getProductSummary(index);\n\t\t\t} catch (Exception ex) {...}\n\t\t\treturn productSummary;\n\t}\n\tpublic String getProductSummary(int index) {\n\t\treturn products[index];\n\t}\n```"}, {"BodyText": "In this example the integer value used as the array index that is provided by the user may be outside the allowable range of indices for the array which may provide unexpected results or cause the application to fail. The integer value used for the array index should be validated to ensure that it is within the allowable range of indices for the array as in the following code."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n```\n// Method called from servlet to obtain product information* \n\tpublic String displayProductSummary(int index) {\n\t\n\t```\n\t\t\tString productSummary = new String(\"\");\n\t\t\ttry {\n\t\t\t\tString productSummary = getProductSummary(index);\n\t\t\t} catch (Exception ex) {...}\n\t\t\treturn productSummary;\n\t}\n\tpublic String getProductSummary(int index) {\n\t\t\tString productSummary = \"\";\n\t\t\tif ((index >= 0) && (index < MAX_PRODUCTS)) {\n\t\t\t\tproductSummary = products[index];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.err.println(\"index is out of bounds\");\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\treturn productSummary;\n\t}\n```"}, {"BodyText": "An alternative in Java would be to use one of the collection objects such as ArrayList that will automatically generate an exception if an attempt is made to access an array index that is out of bounds."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tArrayList productArray = new ArrayList(MAX_PRODUCTS);\n\t...\n\ttry {\n\t\tproductSummary = (String) productArray.get(index);\n\t} catch (IndexOutOfBoundsException ex) {...}\n```"}]}, {"ID": "DX-90", "Entries": [{"IntroText": "The following example asks a user for an offset into an array to select an item."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint main (int argc, char **argv) {\n\t\tchar *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\n\t\tint index = GetUntrustedOffset();\n\t\tprintf(\"You selected %s\\n\", items[index-1]);\n\t}\n```"}, {"BodyText": "The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."}]}], "ObservedExamples": [{"Reference": "CVE-2005-0369", "Description": "large ID in packet used as array index", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0369"}, {"Reference": "CVE-2001-1009", "Description": "negative array index as argument to POP LIST command", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1009"}, {"Reference": "CVE-2003-0721", "Description": "Integer signedness error leads to negative array index", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0721"}, {"Reference": "CVE-2004-1189", "Description": "product does not properly track a count and a maximum number, which can lead to resultant array index overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1189"}, {"Reference": "CVE-2007-5756", "Description": "Chain: device driver for packet-capturing software allows access to an unintended IOCTL with resultant array index error.", "Link": "https://www.cve.org/CVERecord?id=CVE-2007-5756"}, {"Reference": "CVE-2005-2456", "Description": "Chain: array index error (CWE-129) leads to deadlock (CWE-833)", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2456"}], "AffectedResources": ["Memory"], "RelatedAttackPatterns": ["100"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript."}, {"Type": "Theoretical", "Note": "An improperly validated array index might lead directly to the always-incorrect behavior of \"access of array using out-of-bounds index.\""}], "Top25Examples": [{"Reference": "CVE-2021-21947", "Description": "Two heap-based buffer overflow vulnerabilities exists in the JPEG-JFIF lossless Huffman image parser functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger these vulnerabilities.This heap-based buffer overflow takes place when the `SOF3` precision is greater or equal than 9."}, {"Reference": "CVE-2021-30311", "Description": "Possible heap overflow due to lack of index validation before allocating and writing to heap buffer in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile"}, {"Reference": "CVE-2021-35121", "Description": "An array index is improperly used to lock and unlock a mutex which can lead to a Use After Free condition In the Synx driver in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile"}, {"Reference": "CVE-2022-1237", "Description": "Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html)."}, {"Reference": "CVE-2022-46152", "Description": "OP-TEE Trusted OS is the secure side implementation of OP-TEE project, a Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper Validation of Array Index vulnerability. The function `cleanup_shm_refs()` is called by both `entry_invoke_command()` and `entry_open_session()`. The commands `OPTEE_MSG_CMD_OPEN_SESSION` and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed from the normal world via an OP-TEE SMC. This function is not validating the `num_params` argument, which is only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function `get_cmd_buffer()`. Therefore, an attacker in the normal world can craft an SMC call that will cause out-of-bounds reading in `cleanup_shm_refs` and potentially freeing of fake-objects in the function `mobj_put()`. A normal-world attacker with permission to execute SMC instructions may exploit this flaw. Maintainers believe this problem permits local privilege escalation from the normal world to the secure world. Version 3.19.0 contains a fix for this issue. There are no known workarounds."}, {"Reference": "CVE-2022-47342", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47343", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47344", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47345", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47346", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47347", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2022-47348", "Description": "In engineermode services, there is a missing permission check. This could lead to local denial of service in engineermode services."}, {"Reference": "CVE-2021-21949", "Description": "An improper array index validation vulnerability exists in the JPEG-JFIF Scan header parser functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to an out-of-bounds write and potential code exectuion. An attacker can provide a malicious file to trigger this vulnerability."}, {"Reference": "CVE-2022-21310", "Description": "Vulnerability in the MySQL Cluster product of Oracle MySQL (component: Cluster: General). Supported versions that are affected are 7.4.34 and prior, 7.5.24 and prior, 7.6.20 and prior and 8.0.27 and prior. Difficult to exploit vulnerability allows high privileged attacker with access to the physical communication segment attached to the hardware where the MySQL Cluster executes to compromise MySQL Cluster. Successful attacks require human interaction from a person other than the attacker. Successful attacks of this vulnerability can result in takeover of MySQL Cluster. CVSS 3.1 Base Score 6.3 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:A/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:H)."}, {"Reference": "CVE-2022-35268", "Description": "A denial of service vulnerability exists in the web_server hashFirst functionality of Robustel R1510 3.1.16 and 3.3.0. A specially-crafted network request can lead to denial of service. An attacker can send a sequence of requests to trigger this vulnerability.This denial of service is in the `/action/import_sdk_file/` API."}, {"Reference": "CVE-2022-26129", "Description": "Buffer overflow vulnerabilities exist in FRRouting through 8.1.0 due to wrong checks on the subtlv length in the functions, parse_hello_subtlv, parse_ihu_subtlv, and parse_update_subtlv in babeld/message.c."}, {"Reference": "CVE-2022-29206", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SparseTensorDenseAdd` does not fully validate the input arguments. In this case, a reference gets bound to a `nullptr` during kernel execution. This is undefined behavior. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}]}
{"ID": "1290", "Name": "Incorrect Decoding of Security Identifiers ", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product implements a decoding mechanism to decode certain bus-transaction signals to security identifiers. If the decoding is implemented incorrectly, then untrusted agents can now gain unauthorized access to the asset.", "ExtendedDescription": "\n\nIn a System-On-Chip (SoC), various integrated circuits and hardware engines generate transactions such as to access (reads/writes) assets or perform certain actions (e.g., reset, fetch, compute, etc.). Among various types of message information, a typical transaction is comprised of source identity (to identify the originator of the transaction) and a destination identity (to route the transaction to the respective entity). Sometimes the transactions are qualified with a security identifier. The security identifier helps the destination agent decide on the set of allowed actions (e.g., access an asset for read and writes). A decoder decodes the bus transactions to map security identifiers into necessary access-controls/protections.\n\n\nA common weakness that can exist in this scenario is incorrect decoding because an untrusted agent's security identifier is decoded into a trusted agent's security identifier. Thus, an untrusted agent previously without access to an asset can now gain access to the asset.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1294", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Bus/Interface Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "DoS: Resource Consumption (Other)", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Quality Degradation"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Security identifier decoders must be reviewed for design consistency and common weaknesses."}, {"Phase": ["Implementation"], "Description": "Access and programming flows must be tested in pre-silicon and post-silicon testing in order to check for this weakness."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a system that has four bus masters and a decoder. The decoder is supposed to decode every bus transaction and assign a corresponding security identifier. The security identifier is used to determine accesses to the assets. The bus transaction that contains the security information is Bus_transaction [15:14], and the bits 15 through 14 contain the security identifier information. The table below provides bus masters as well as their security identifiers and trust assumptions: \n\n| Bus Master | Security Identifier Decoding | Trust Assumptions | \n| --- | --- | --- |\n| Master_0 | \"00\" | Untrusted  |\n| Master_1 | \"01\" | Trusted  |\n| Master_2 | \"10\" | Untrusted  |\n| Master_3 | \"11\" | Untrusted  |\n\n\t\n The assets are the AES-Key registers for encryption or decryption. The key is 128 bits implemented as a set of four 32-bit registers. The AES_KEY_ACCESS_POLICY is used to define which agents with a security identifier in the transaction can access the AES-key registers. The size of the security identifier is 4 bits (i.e., bit 3 through 0). Each bit in these 4 bits defines a security identifier. There are only 4 security identifiers that are allowed accesses to the AES-key registers. The number of the bit when set (i.e., \"1\") allows respective action from an agent whose identity matches the number of the bit. If clear (i.e., \"0\"), disallows the respective action to that corresponding agent. \n\n\t| Register | Field description | \n| --- | --- |\n| AES_ENC_DEC_KEY_0 | AES key [0:31] for encryption or decryption  Default 0x00000000 |\n| AES_ENC_DEC_KEY_1 | AES key [32:63] for encryption or decryption  Default 0x00000000 |\n| AES_ENC_DEC_KEY_2 | AES key [64:95] for encryption or decryption  Default 0x00000000 |\n| AES_ENC_DEC_KEY_3 | AES key [96:127] for encryption or decryption  Default 0x00000000 |\n| AES_KEY_ACCESS_POLCY | [31:4] Default 0x00000000  [3:0]-0x01 agent with Security Identified \"1\" has access to AES_ENC_DEC_KEY_0 through AES_ENC_DEC_KEY_3 registers |"}, {"BodyText": "The following Pseudo code outlines the process of checking the value of the Security Identifier within the AES_KEY_ACCESS_POLICY register:"}, {"Nature": "Informative", "Language": "Other", "ExampleCode": "```\n\t If (AES_KEY_ACCESS_POLICY[Security_Identifier] == \"1\") \n\t\t Allow access to AES-Key registers \n\t Else \n\t\t Deny access to AES-Key registers \n```"}, {"BodyText": "Below is a decoder's Pseudo code that only checks for bit [14] of the bus transaction to determine what Security Identifier it must assign."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "```\n\t If (Bus_transaction[14] == \"1\") \n\t\t Security_Identifier == \"1\" \n\t Else \n\t\t Security_Identifier == \"0\" \n```"}, {"BodyText": "The security identifier is two bits, but the decoder code above only checks the value of one bit. Two Masters have their bit 0 set to \"1\" - Master_1 and Master_3. Master_1 is trusted, while Master_3 is not. The code above would therefore allow an untrusted agent, Master_3, access to the AES-Key registers in addition to intended trusted Master_1. \n The decoder should check for the entire size of the security identifier in the bus-transaction signal to assign a corresponding security identifier. The following is good Pseudo code:"}, {"Nature": "Good", "Language": "Other", "ExampleCode": "```\n\t If (Bus_transaction[15:14] == \"00\") \n\t\t Security_Identifier == \"0\" \n\t If (Bus_transaction[15:14] == \"01\") \n\t\t Security_Identifier == \"1\" \n\t If (Bus_transaction[15:14] == \"10\") \n\t\t Security_Identifier == \"2\" \n\t If (Bus_transaction[15:14] == \"11\") \n\t\t Security_Identifier == \"3\" \n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1291", "Name": "Public Key Re-Use for Signing both Debug and Production Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The same public key is used for signing both debug and production code.", "ExtendedDescription": "\n\nA common usage of public-key cryptography is to verify the integrity and authenticity of another entity (for example a firmware binary). If a company wants to ensure that its firmware runs only on its own hardware, before the firmware runs, an encrypted hash of the firmware image will be decrypted with the public key and then verified against the now-computed hash of the firmware image. This means that the public key forms the root of trust, which necessitates that the public key itself must be protected and used properly.\n\n\nDuring the development phase, debug firmware enables many hardware debug hooks, debug modes, and debug messages for testing. Those debug facilities provide significant, additional views about the firmware's capability and, in some cases, additional capability into the chip or SoC. If compromised, these capabilities could be exploited by an attacker to take full control of the system.\n\n\nOnce the product exits the manufacturing stage and enters production, it is good practice to use a different public key. Debug firmware images are known to leak. With the debug key being reused as the production key, the debug image will also work on the production image. Thus, it will open all the internal, debug capabilities to the attacker.\n\n\nIf a different public key is used for the production image, even if the attacker gains access to the debug firmware image, they will not be able to run it on a production machine. Thus, damage will be limited to the intellectual property leakage resulting from the debug image.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "693", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "321", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control", "Accountability", "Authentication", "Authorization", "Non-Repudiation", "Other"], "Impact": ["Read Memory", "Modify Memory", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Varies by Context"], "Likelihood": ["High"]}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "\n\nCompare the debug key with the production key to make sure that they are not the same.\n", "Effectiveness": "High"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nCompare the debug key with the production key to make sure that they are not the same.\n", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Use different keys for Production and Debug"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example illustrates the danger of using the same public key for debug and production."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "Suppose the product design requires frugality of silicon real estate. Assume that originally the architecture allows just enough storage for two 2048-bit RSA keys in the fuse: one to be used for debug and the other for production. However, in the meantime, a business decision is taken to make the security future-proof beyond 2030, which means the architecture needs to use the NIST-recommended 3072-bit keys instead of the originally-planned 2048-bit keys. This means that, at most, one key can be fully stored in the fuses, not two. So the product design team decides to use the same public key for debug and production."}, {"Nature": "Informative", "Language": "Other", "ExampleCode": "Increase the storage so that two different keys of the required size can be stored."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1292", "Name": "Incorrect Conversion of Security Identifiers", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product implements a conversion mechanism to map certain bus-transaction signals to security identifiers. However, if the conversion is incorrectly implemented, untrusted agents can gain unauthorized access to the asset.", "ExtendedDescription": "\n\nIn a System-On-Chip (SoC), various integrated circuits and hardware engines generate transactions such as to access (reads/writes) assets or perform certain actions (e.g., reset, fetch, compute, etc.). Among various types of message information, a typical transaction is comprised of source identity (to identify the originator of the transaction) and a destination identity (to route the transaction to the respective entity). Sometimes the transactions are qualified with a security identifier. This security identifier helps the destination agent decide on the set of allowed actions (e.g., access an asset for read and writes).\n\n\nA typical bus connects several leader and follower agents. Some follower agents implement bus protocols differently from leader agents. A protocol conversion happens at a bridge to seamlessly connect different protocols on the bus. One example is a system that implements a leader with the Advanced High-performance Bus (AHB) protocol and a follower with the Open-Core Protocol (OCP). A bridge AHB-to-OCP is needed to translate the transaction from one form to the other.\n\n\nA common weakness that can exist in this scenario is that this conversion between protocols is implemented incorrectly, whereupon an untrusted agent may gain unauthorized access to an asset.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1294", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Bus/Interface Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design, then identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during hardware implementation, then identified later during Testing or System Configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "DoS: Resource Consumption (Other)", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Quality Degradation"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Security identifier decoders must be reviewed for design inconsistency and common weaknesses."}, {"Phase": ["Implementation"], "Description": "Access and programming flows must be tested in pre-silicon and post-silicon testing."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a system that supports AHB. Let us assume we have a follower agent that only understands OCP. To connect this follower to the leader, a bridge is introduced, i.e., AHB to OCP. \n\n\n The follower has assets to protect accesses from untrusted leaders, and it employs access controls based on policy, (e.g., AES-Key registers for encryption or decryption). The key is 128 bits implemented as a set of four 32-bit registers. The key registers are assets, and register AES_KEY_ACCESS_POLICY is defined to provide the necessary access controls. \n\n\n The AES_KEY_ACCESS_POLICY access-policy register defines which agents with a security identifier in the transaction can access the AES-key registers. The implemented AES_KEY_ACCESS_POLICY has 4 bits where each bit when \"Set\" allows access to the AES-Key registers to the corresponding agent that has the security identifier. The other bits from 31 through 4 are reserved and not used. \n\n|  | \n|\n|  Register  |  Field Description   |\n|  AES_ENC_DEC_KEY_0  |  AES key [0:31] for encryption or decryption Default 0x00000000   |\n|  AES_ENC_DEC_KEY_1  |  AES key [32:63] for encryption or decryption Default 0x00000000   |\n|  AES_ENC_DEC_KEY_2  |  AES key [64:95] for encryption or decryption Default 0x00000000   |\n|  AES_ENC_DEC_KEY_3  |  AES key [96:127] for encryption or decryption Default 0x00000000   |\n|  AES_KEY_ACCESS_POLICY  |  [31:4] Default 0x000000 [3:0] - 0x02 agent with Security Identifier \"1\" has access to AES_ENC_DEC_KEY_0 through AES_ENC_DEC_KEY_4 registers   |\n\n\t\n During conversion of the AHB-to-OCP transaction, the security identifier information must be preserved and passed on to the follower correctly."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "In AHB-to-OCP bridge, the security identifier information conversion is done incorrectly."}, {"BodyText": "Because of the incorrect conversion, the security identifier information is either lost or could be modified in such a way that an untrusted leader can access the AES-Key registers."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "The conversion of the signals from one protocol (AHB) to another (OCP) must be done while preserving the security identifier correctly."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1293", "Name": "Missing Source Correlation of Multiple Independent Data", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product relies on one source of data, preventing the ability to detect if an adversary has compromised a data source.", "ExtendedDescription": "\n\nTo operate successfully, a product sometimes has to implicitly trust the integrity of an information source. When information is implicitly signed, one can ensure that the data was not tampered in transit. This does not ensure that the information source was not compromised when responding to a request. By requesting information from multiple sources, one can check if all of the data is the same. If they are not, the system should report the information sources that respond with a different or minority value as potentially compromised. If there are not enough answers to provide a majority or plurality of responses, the system should report all of the sources as potentially compromised. As the seriousness of the impact of incorrect integrity increases, so should the number of independent information sources that would need to be queried.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "345", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "654", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "This flaw could be introduced during the design of the application or misconfiguration at run time by only specifying a single point of validation."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during hardware implementation, then identified later during Testing or System Configuration phases."}, {"Phase": "Operation", "Note": "This weakness could be introduced by intentionally failing all but one of the devices used to retrieve the data or by failing the devices that validate the data."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Application Data", "Modify Application Data", "Gain Privileges or Assume Identity"], "Note": "An attacker that may be able to execute a single Person-in-the-Middle attack can subvert a check of an external oracle (e.g. the ACME protocol check for a file on a website), and thus inject an arbitrary reply to the single perspective request to the external oracle."}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Design system to use a Practical Byzantine fault method, to request information from multiple sources to verify the data and report on potentially compromised information sources."}, {"Phase": ["Implementation"], "Description": "Failure to use a Practical Byzantine fault method when requesting data. Lack of place to report potentially compromised information sources. Relying on non-independent information sources for integrity checking. Failure to report information sources that respond in the minority to incident response procedures."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1294", "Name": "Insecure Security Identifier Mechanism", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The System-on-Chip (SoC) implements a Security Identifier mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. However, the Security Identifiers are not correctly implemented.", "ExtendedDescription": "\n\nSystems-On-Chip (Integrated circuits and hardware engines) implement Security Identifiers to differentiate/identify actions originated from various agents. These actions could be 'read', 'write', 'program', 'reset', 'fetch', 'compute', etc. Security identifiers are generated and assigned to every agent in the System (SoC) that is either capable of generating an action or receiving an action from another agent. Every agent could be assigned a unique, Security Identifier based on its trust level or privileges.\n\n\nA broad class of flaws can exist in the Security Identifier process, including but not limited to missing security identifiers, improper conversion of security identifiers, incorrect generation of security identifiers, etc.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Bus/Interface Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design, then identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during hardware implementation, then identified later during Testing or System Configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "DoS: Resource Consumption (Other)", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Quality Degradation"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Security Identifier Decoders must be reviewed for design inconsistency and common weaknesses."}, {"Phase": ["Implementation"], "Description": "Access and programming flows must be tested in pre-silicon and post-silicon testing."}], "RelatedAttackPatterns": ["121", "681"], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}]}
{"ID": "1295", "Name": "Debug Messages Revealing Unnecessary Information", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product fails to adequately prevent the revealing of unnecessary and potentially sensitive system information within debugging messages.", "ExtendedDescription": "\n\nDebug messages are messages that help troubleshoot an issue by revealing the internal state of the system. For example, debug data in design can be exposed through internal memory array dumps or boot logs through interfaces like UART via TAP commands, scan chain, etc. Thus, the more information contained in a debug message, the easier it is to debug. However, there is also the risk of revealing information that could help an attacker either decipher a vulnerability, and/or gain a better understanding of the system. Thus, this extra information could lower the \"security by obscurity\" factor. While \"security by obscurity\" alone is insufficient, it can help as a part of \"Defense-in-depth\". \n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "200", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "209", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control", "Accountability", "Authentication", "Authorization", "Non-Repudiation"], "Impact": ["Read Memory", "Bypass Protection Mechanism", "Gain Privileges or Assume Identity", "Varies by Context"], "Likelihood": ["Medium"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Ensure that a debug message does not reveal any unnecessary information during the debug process for the intended response."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example here shows how an attacker can take advantage of unnecessary information in debug messages."}, {"BodyText": "Example 1: Suppose in response to a Test Access Port (TAP) chaining request the debug message also reveals the current TAP hierarchy (the full topology) in addition to the success/failure message."}, {"BodyText": "Example 2: In response to a password-filling request, the debug message, instead of a simple Granted/Denied response, prints an elaborate message, \"The user-entered password does not match the actual password stored in <directory name>.\""}, {"BodyText": "The result of the above examples is that the user is able to gather additional unauthorized information about the system from the debug messages."}, {"BodyText": "The solution is to ensure that Debug messages do not reveal additional details."}]}], "ObservedExamples": [{"Reference": "CVE-2021-25476", "Description": "Digital Rights Management (DRM) capability for mobile platform leaks pointer information, simplifying ASLR bypass", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-25476"}, {"Reference": "CVE-2020-24491", "Description": "Processor generates debug message that contains sensitive information (\"addresses of memory transactions\").", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-24491"}, {"Reference": "CVE-2017-18326", "Description": "modem debug messages include cryptographic keys", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-18326"}], "RelatedAttackPatterns": ["121"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-34364", "Description": " Dell BSAFE SSL-J, versions before 6.5 and version 7.0 contain a debug message revealing unnecessary information vulnerability. This may lead to disclosing sensitive information to a locally privileged user. . "}]}
{"ID": "1296", "Name": "Incorrect Chaining or Granularity of Debug Components", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product's debug components contain incorrect chaining or granularity of debug components.", "ExtendedDescription": "\n\nFor debugging and troubleshooting a chip, several hardware design elements are often implemented, including:\n\n\n  - Various Test Access Ports (TAPs) allow boundary scan commands to be executed.\n\n  - For scanning the internal components of a chip, there are scan cells that allow the chip to be used as a \"stimulus and response\" mechanism.\n\n  - Chipmakers might create custom methods to observe the internal components of their chips by placing various tracing hubs within their chip and creating hierarchical or interconnected structures among those hubs.\n\nLogic errors during design or synthesis could misconfigure the interconnection of the debug components, which could allow unintended access permissions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Verilog", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "VHDL", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Authentication", "Authorization", "Availability", "Accountability"], "Impact": ["Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands", "Modify Memory", "Modify Files or Directories"], "Likelihood": ["Medium"], "Note": "Depending on the access to debug component(s) erroneously granted, an attacker could use the debug component to gain additional understanding about the system to further an attack and/or execute other commands. This could compromise any security property, including the ones listed above."}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "Appropriate Post-Si tests should be carried out at various authorization levels to ensure that debug components are properly chained and accessible only to users with appropriate credentials.", "Effectiveness": "High"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "Appropriate Post-Si tests should be carried out at various authorization levels to ensure that debug components are properly chained and accessible only to users with appropriate credentials.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Ensure that debug components are properly chained and their granularity is maintained at different authentication levels."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example shows how an attacker can take advantage of incorrect chaining or missing granularity of debug components."}, {"BodyText": "In a System-on-Chip (SoC), the user might be able to access the SoC-level TAP with a certain level of authorization. However, this access should not also grant access to all of the internal TAPs (e.g., Core). Separately, if any of the internal TAPs is also stitched to the TAP chain when it should not be because of a logic error, then an attacker can access the internal TAPs as well and execute commands there."}, {"BodyText": "As a related example, suppose there is a hierarchy of TAPs (TAP_A is connected to TAP_B and TAP_C, then TAP_B is connected to TAP_D and TAP_E, then TAP_C is connected to TAP_F and TAP_G, etc.). Architecture mandates that the user have one set of credentials for just accessing TAP_A, another set of credentials for accessing TAP_B and TAP_C, etc. However, if, during implementation, the designer mistakenly implements a daisy-chained TAP where all the TAPs are connected in a single TAP chain without the hierarchical structure, the correct granularity of debug components is not implemented and the attacker can gain unauthorized access."}]}], "ObservedExamples": [{"Reference": "CVE-2017-18347", "Description": "Incorrect access control in RDP Level 1 on STMicroelectronics STM32F0 series devices allows physically present attackers to extract the device's protected firmware via a special sequence of Serial Wire Debug (SWD) commands because there is a race condition between full initialization of the SWD interface and the setup of flash protection.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-18347"}, {"Reference": "CVE-2020-1791", "Description": "There is an improper authorization vulnerability in several smartphones. The system has a logic-judging error, and, under certain scenarios, a successful exploit could allow the attacker to switch to third desktop after a series of operations in ADB mode. (Vulnerability ID: HWPSIRT-2019-10114).", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-1791"}], "RelatedAttackPatterns": ["121", "702"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}]}
{"ID": "1297", "Name": "Unprotected Confidential Information on Device is Accessible by OSAT Vendors", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product does not adequately protect confidential information on the device from being accessed by Outsourced Semiconductor Assembly and Test (OSAT) vendors.", "ExtendedDescription": "\n\nIn contrast to complete vertical integration of architecting, designing, manufacturing, assembling, and testing chips all within a single organization, an organization can choose to simply architect and design a chip before outsourcing the rest of the process to OSAT entities (e.g., external foundries and test houses). In the latter example, the device enters an OSAT facility in a much more vulnerable pre-production stage where many debug and test modes are accessible. Therefore, the chipmaker must place a certain level of trust with the OSAT. To counter this, the chipmaker often requires the OSAT partner to enter into restrictive non-disclosure agreements (NDAs). Nonetheless, OSAT vendors likely have many customers, which increases the risk of accidental sharing of information. There may also be a security vulnerability in the information technology (IT) system of the OSAT facility. Alternatively, a malicious insider at the OSAT facility may carry out an insider attack. Considering these factors, it behooves the chipmaker to minimize any confidential information in the device that may be accessible to the OSAT vendor.\n\n\nLogic errors during design or synthesis could misconfigure the interconnection of the debug components, which could provide improper authorization to sensitive information.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "285", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Verilog", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "VHDL", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Authentication", "Authorization", "Availability", "Accountability", "Non-Repudiation"], "Impact": ["Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands", "Modify Memory", "Modify Files or Directories"], "Likelihood": ["Medium"], "Note": "The impact depends on the confidential information itself and who is inadvertently granted access. For example, if the confidential information is a key that can unlock all the parts of a generation, the impact could be severe."}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "Appropriate Post-Si tests should be carried out to ensure that residual confidential information is not left on parts leaving one facility for another facility.", "Effectiveness": "High"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "Appropriate Post-Si tests should be carried out to ensure that residual confidential information is not left on parts leaving one facility for another facility.", "Effectiveness": "Moderate"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\n  - Ensure that when an OSAT vendor is allowed to access test interfaces necessary for preproduction and returned parts, the vendor only pulls the minimal information necessary. Also, architect the product in such a way that, when an \"unlock device\" request comes, it only unlocks that specific part and not all the parts for that product line.\n\n  - Ensure that the product's non-volatile memory (NVM) is scrubbed of all confidential information and secrets before handing it over to an OSAT.\n\n  - Arrange to secure all communication between an OSAT facility and the chipmaker.\n\n", "Effectiveness": "Moderate"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example shows how an attacker can take advantage of a piece of confidential information that has not been protected from the OSAT."}, {"BodyText": "Suppose the preproduction device contains NVM (a storage medium that by definition/design can retain its data without power), and this NVM contains a key that can unlock all the parts for that generation. An OSAT facility accidentally leaks the key."}, {"BodyText": "Compromising a key that can unlock all the parts of a generation can be devastating to a chipmaker."}, {"BodyText": "The likelihood of such a compromise can be reduced by ensuring all memories on the preproduction device are properly scrubbed."}]}], "RelatedAttackPatterns": ["1", "180"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry might be subject to CWE Scope Exclusion SCOPE.SITUATIONS (Focus on situations in which weaknesses may appear); SCOPE.HUMANPROC (Human/organizational process; and/or SCOPE.CUSTREL (Not customer-relevant)."}, {"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}]}
{"ID": "1298", "Name": "Hardware Logic Contains Race Conditions", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "A race condition in the hardware logic results in undermining security guarantees of the system.", "ExtendedDescription": "\n\nA race condition in logic circuits typically occurs when a logic gate gets inputs from signals that have traversed different paths while originating from the same source. Such inputs to the gate can change at slightly different times in response to a change in the source signal. This results in a timing error or a glitch (temporary or permanent) that causes the output to change to an unwanted state before settling back to the desired state. If such timing errors occur in access control logic or finite state machines that are implemented in security sensitive flows, an attacker might exploit them to circumvent existing protections.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "362", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Verilog", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "VHDL", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism", "Gain Privileges or Assume Identity", "Alter Execution Logic"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Adopting design practices that encourage designers to recognize and eliminate race conditions, such as Karnaugh maps, could result in the decrease in occurrences of race conditions."}, {"Phase": ["Implementation"], "Description": "Logic redundancy can be implemented along security critical paths to prevent race conditions. To avoid metastability, it is a good practice in general to default to a secure state in which access is not given to untrusted agents."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The code below shows a 2x1 multiplexor using logic gates. Though the code shown below results in the minimum gate solution, it is disjoint and causes glitches."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "// 2x1 Multiplexor using logic-gates\n\n module glitchEx(\n\n```\n\t input wire in0, in1, sel,\n\t output wire z\n );\n wire not_sel;\n wire and_out1, and_out2;\n assign not_sel = ~sel;\n assign and_out1 = not_sel & in0;\n assign and_out2 = sel & in1;\n // Buggy line of code:\n assign z = and_out1 | and_out2; // glitch in signal z\n endmodule\n```"}, {"BodyText": "The buggy line of code, commented above, results in signal 'z' periodically changing to an unwanted state. Thus, any logic that references signal 'z' may access it at a time when it is in this unwanted state. This line should be replaced with the line shown below in the Good Code Snippet which results in signal 'z' remaining in a continuous, known, state. Reference for the above code, along with waveforms for simulation can be found in the references below."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "assign z <= and_out1 or and_out2 or (in0 and in1);"}, {"BodyText": "This line of code removes the glitch in signal z."}]}, {"Entries": [{"IntroText": "The example code is taken from the DMA (Direct Memory Access) module of the buggy OpenPiton SoC of HACK@DAC'21. The DMA contains a finite-state machine (FSM) for accessing the permissions using the physical memory protection (PMP) unit.\n\n\nPMP provides secure regions of physical memory against unauthorized access. It allows an operating system or a hypervisor to define a series of physical memory regions and then set permissions for those regions, such as read, write, and execute permissions. When a user tries to access a protected memory area (e.g., through DMA), PMP checks the access of a PMP address (e.g., pmpaddr_i) against its configuration (pmpcfg_i). If the access violates the defined permissions (e.g., CTRL_ABORT), the PMP can trigger a fault or an interrupt. This access check is implemented in the pmp parametrized module in the below code snippet. The below code assumes that the state of the pmpaddr_i and pmpcfg_i signals will not change during the different DMA states (i.e., CTRL_IDLE to CTRL_DONE) while processing a DMA request (via dma_ctrl_reg). The DMA state machine is implemented using a case statement (not shown in the code snippet)."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "module dma # (...)(...);\n ...\n\n```\n\t input [7:0] [16-1:0] pmpcfg_i;\n\t input logic [16-1:0][53:0] pmpaddr_i;\n\t ...\n\t //// Save the input command\n\t always @ (posedge clk_i or negedge rst_ni)\n\t\t begin: save_inputs\n\t\t if (!rst_ni)\n\t\t\t begin\n\t\t\t ...\n\t\t\t end\n\t\t else\n\t\t\t begin\n\t\t\t\t if (dma_ctrl_reg == CTRL_IDLE || dma_ctrl_reg == CTRL_DONE)\n\t\t\t\t begin\n\t\t\t\t ...\n\t\t\t\t end\n\t\t\t end\n\t\t end // save_inputs\n\t\t ...\n\t\t // Load/store PMP check\n\t\t pmp #(\n\t\t\t .XLEN ( 64 ),\n\t\t\t .PMP_LEN ( 54 ),\n\t\t\t .NR_ENTRIES ( 16 )\n\t\t ) i_pmp_data (\n\t\t\t .addr_i ( pmp_addr_reg ),\n\t\t\t .priv_lvl_i ( riscv::PRIV_LVL_U ),\n\t\t\t .access_type_i ( pmp_access_type_reg ),\n\t\t\t // Configuration\n\t\t\t .conf_addr_i ( \n```\npmpaddr_i**  ),\n\t\t\t .conf_i ( \n\t\t\t **pmpcfg_i**  ),\n\t\t\t .allow_o ( pmp_data_allow )\n\t\t\t );\n\t\t endmodule"}, {"BodyText": "However, the above code [REF-1394] allows the values of pmpaddr_i and pmpcfg_i to be changed through DMA's input ports. This causes a race condition and will enable attackers to access sensitive addresses that the configuration is not associated with.\n\n\nAttackers can initialize the DMA access process (CTRL_IDLE) using pmpcfg_i for a non-privileged PMP address (pmpaddr_i). Then during the loading state (CTRL_LOAD), attackers can replace the non-privileged address in pmpaddr_i with a privileged address without the requisite authorized access configuration.\n\n\nTo fix this issue (see [REF-1395]), the value of the pmpaddr_i and pmpcfg_i signals should be stored in local registers (pmpaddr_reg and pmpcfg_reg at the start of the DMA access process and the pmp module should reference those registers instead of the signals directly. The values of the registers can only be updated at the start (CTRL_IDLE) or the end (CTRL_DONE) of the DMA access process, which prevents attackers from changing the PMP address in the middle of the DMA access process."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "module dma # (...)(...);\n ...\n\n```\n\t input [7:0] [16-1:0] pmpcfg_i; \n\t input logic [16-1:0][53:0] pmpaddr_i;\n\t ...\n```\nreg [7:0] [16-1:0] pmpcfg_reg;** \n\t\n\t **reg [16-1:0][53:0] pmpaddr_reg;** \n\t ...\n\t //// Save the input command\n\t always @ (posedge clk_i or negedge rst_ni)\n\t\n\t```\n\t\t begin: save_inputs\n\t\t if (!rst_ni)\n\t\t\t begin\n\t\t\t ...\n```\npmpaddr_reg <= 'b0 ;** \n\t\t\t\n\t\t\t **pmpcfg_reg <= 'b0 ;** \n\t\t\t end\n\t\t\t else \n\t\t\n\t\t```\n\t\t\t begin\n\t\t\t\t if (dma_ctrl_reg == CTRL_IDLE || dma_ctrl_reg == CTRL_DONE) \n\t\t\t\t begin\n\t\t\t\t ...\n```\npmpaddr_reg <= pmpaddr_i;** \n\t\t\t\t\n\t\t\t\t **pmpcfg_reg <= pmpcfg_i;** \n\t\t\t\t end\n\t\t\t\t end \n\t\t\t end // save_inputs\n\t\t ...\n\t\t // Load/store PMP check\n\t\t pmp #(\n\t\t\n\t\t```\n\t\t\t .XLEN ( 64 ),\n\t\t\t .PMP_LEN ( 54 ),\n\t\t\t .NR_ENTRIES ( 16 )\n\t\t ) i_pmp_data (\n\t\t\t .addr_i ( pmp_addr_reg ),\n\t\t\t .priv_lvl_i ( riscv::PRIV_LVL_U ), // we intend to apply filter on\n\t\t\t // DMA always, so choose the least privilege .access_type_i ( pmp_access_type_reg ),\n\t\t\t // Configuration\n\t\t\t .conf_addr_i ( \n```\npmpaddr_reg**  ),\n\t\t\t .conf_i ( \n\t\t\t **pmpcfg_reg**  ),\n\t\t\t .allow_o ( pmp_data_allow )\n\t\t\t );\n\t\t endmodule"}]}], "RelatedAttackPatterns": ["26"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1299", "Name": "Missing Protection Mechanism for Alternate Hardware Interface", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The lack of protections on alternate paths to access\n                control-protected assets (such as unprotected shadow registers\n                and other external facing unguarded interfaces) allows an\n                attacker to bypass existing protections to the asset that are\n\t\tonly performed against the primary path.", "ExtendedDescription": "\n\nAn asset inside a chip might have access-control protections through one interface. However, if all paths to the asset are not protected, an attacker might compromise the asset through alternate paths. These alternate paths could be through shadow or mirror registers inside the IP core, or could be paths from other external-facing interfaces to the IP core or SoC.\n\n\nConsider an SoC with various interfaces such as UART, SMBUS, PCIe, USB, etc. If access control is implemented for SoC internal registers only over the PCIe interface, then an attacker could still modify the SoC internal registers through alternate paths by coming through interfaces such as UART, SMBUS, USB, etc. \n\n\nAlternatively, attackers might be able to bypass existing protections by exploiting unprotected, shadow registers. Shadow registers and mirror registers typically refer to registers that can be accessed from multiple addresses. Writing to or reading from the aliased/mirrored address has the same effect as writing to the address of the main register. They are typically implemented within an IP core or SoC to temporarily hold certain data. These data will later be updated to the main register, and both registers will be in synch. If the shadow registers are not access-protected, attackers could simply initiate transactions to the shadow registers and compromise system security. \n", "RelatedWeaknesses": [{"Nature": "PeerOf", "CweID": "1191", "ViewID": "1194", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "420", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "288", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Microcontroller Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Bus/Interface Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "DoS: Resource Consumption (Other)", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Alter Execution Logic", "Bypass Protection Mechanism", "Quality Degradation"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Protect assets from accesses against all potential interfaces and alternate paths.", "Effectiveness": "Defense in Depth"}, {"Phase": ["Architecture and Design"], "Description": "Protect assets from accesses against all potential interfaces and alternate paths.", "Effectiveness": "Defense in Depth"}, {"Phase": ["Implementation"], "Description": "Protect assets from accesses against all potential interfaces and alternate paths.", "Effectiveness": "Defense in Depth"}], "DemonstrativeExamples": [{"ID": "DX-176", "Entries": [{"IntroText": "Register SECURE_ME is located at address 0xF00. A mirror of this register called COPY_OF_SECURE_ME is at location 0x800F00. The register SECURE_ME is protected from malicious agents and only allows access to select, while COPY_OF_SECURE_ME is not. \n\n\n Access control is implemented using an allowlist (as indicated by acl_oh_allowlist). The identity of the initiator of the transaction is indicated by the one hot input, incoming_id. This is checked against the acl_oh_allowlist (which contains a list of initiators that are allowed to access the asset). \n\n\n Though this example is shown in Verilog, it will apply to VHDL as well."}, {"Nature": "Informative", "Language": "Verilog", "ExampleCode": "module foo_bar(data_out, data_in, incoming_id, address, clk, rst_n);\n output [31:0] data_out;\n input [31:0] data_in, incoming_id, address;\n input clk, rst_n;\n wire write_auth, addr_auth;\n reg [31:0] data_out, acl_oh_allowlist, q;\n assign write_auth = | (incoming_id & acl_oh_allowlist) ? 1 : 0; \n always @*\n\n```\n\t acl_oh_allowlist <= 32'h8312; \n assign addr_auth = (address == 32'hF00) ? 1: 0;\n always @ (posedge clk or negedge rst_n)\n\t if (!rst_n)\n\t\t begin\n\t\t\t q <= 32'h0;\n\t\t\t data_out <= 32'h0;\n\t\t end\n\t else\n\t\t begin\n\t\t\t q <= (addr_auth & write_auth) ? data_in: q;\n\t\t\t data_out <= q;\n\t\t end\n\t end\n endmodule\n```"}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "assign addr_auth = (address == 32'hF00) ? 1: 0;"}, {"BodyText": "The bugged line of code is repeated in the Bad example above. The weakness arises from the fact that the SECURE_ME register can be modified by writing to the shadow register COPY_OF_SECURE_ME. The address of COPY_OF_SECURE_ME should also be included in the check. That buggy line of code should instead be replaced as shown in the Good Code Snippet below."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "assign addr_auth = (address == 32'hF00 || address == 32'h800F00) ? 1: 0;"}]}], "ObservedExamples": [{"Reference": "CVE-2022-38399", "Description": "Missing protection mechanism on serial connection allows for arbitrary OS command execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-38399"}, {"Reference": "CVE-2020-9285", "Description": "Mini-PCI Express slot does not restrict direct memory access.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-9285"}, {"Reference": "CVE-2020-8004", "Description": "When the internal flash is protected by blocking access on the Data Bus (DBUS), it can still be indirectly accessed through the Instruction Bus (IBUS).", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8004"}, {"Reference": "CVE-2017-18293", "Description": "When GPIO is protected by blocking access to corresponding GPIO resource registers, protection can be bypassed by writing to the corresponding banked GPIO registers instead.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-18293"}, {"Reference": "CVE-2020-15483", "Description": "monitor device allows access to physical UART debug port without authentication", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-15483"}], "RelatedAttackPatterns": ["457", "554"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-43557", "Description": "The BD BodyGuard\u2122 infusion pumps specified allow for access through the RS-232 (serial) port interface. If exploited, threat actors with physical access, specialized equipment and knowledge may be able to configure or disable the pump. No electronic protected health information (ePHI), protected health information (PHI) or personally identifiable information (PII) is stored in the pump."}, {"Reference": "CVE-2022-38399", "Description": "Missing protection mechanism for alternate hardware interface in SmaCam CS-QR10 all versions and SmaCam Night Vision CS-QR20 all versions allows an attacker to execute an arbitrary OS command by having the product connect to the product's specific serial connection"}]}
{"ID": "13", "Name": "ASP.NET Misconfiguration: Password in Configuration File", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource making them an easy target for attackers.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "260", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Credentials stored in configuration files should be encrypted, Use standard APIs and industry accepted algorithms to encrypt the credentials stored in configuration files."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database, but the pair is stored in plaintext."}, {"Nature": "Bad", "Language": "ASP.NET", "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"}, {"BodyText": "Username and password information should not be included in a configuration file or a properties file in plaintext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "130", "Name": "Improper Handling of Length Parameter Inconsistency", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.", "ExtendedDescription": "If an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "240", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "119", "ViewID": "1305", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "119", "ViewID": "1340", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "805", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Sometimes"}, {"Type": "Language", "Name": "C++", "Prevalence": "Sometimes"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "length manipulation"}, {"Term": "length tampering"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Memory", "Modify Memory", "Varies by Context"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "When processing structured incoming data containing a size field followed by raw data, ensure that you identify and resolve any inconsistencies between the size field and the actual size of the data."}, {"Phase": ["Implementation"], "Description": "Do not let the user control the size of the buffer."}, {"Phase": ["Implementation"], "Description": "Validate that the length of the user-supplied data is consistent with the buffer size."}], "DemonstrativeExamples": [{"ID": "DX-91", "Entries": [{"IntroText": "In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint processMessageFromSocket(int socket) {\n\t\t\tint success;\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tchar message[MESSAGE_SIZE];\n```\n// get message from socket and store into buffer* \n\t\t\t\n\t\t\t\n\t\t\t *//Ignoring possibliity that buffer > BUFFER_SIZE* \n\t\t\tif (getMessage(socket, buffer, BUFFER_SIZE) > 0) {\n\t\t\t```\n```\n// place contents of the buffer into message structure* \n\t\t\t\t\tExMessage *msg = recastBuffer(buffer);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// copy message body into string for processing* \n\t\t\t\t\tint index;\n\t\t\t\t\tfor (index = 0; index < msg->msgLength; index++) {\n\t\t\t\t\t```\n\t\t\t\t\t\tmessage[index] = msg->msgBody[index];\n\t\t\t\t\t}\n\t\t\t\t\tmessage[index] = '\\0';\n```\n// process message* \n\t\t\t\t\tsuccess = processMessage(message);}\n\t\t\treturn success;}"}, {"BodyText": "However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."}]}], "ObservedExamples": [{"Reference": "CVE-2014-0160", "Description": "Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.", "Link": "https://www.cve.org/CVERecord?id=CVE-2014-0160"}, {"Reference": "CVE-2009-2299", "Description": "Web application firewall consumes excessive memory when an HTTP request contains a large Content-Length value but no POST data.", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2299"}, {"Reference": "CVE-2001-0825", "Description": "Buffer overflow in internal string handling routine allows remote attackers to execute arbitrary commands via a length argument of zero or less, which disables the length check.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0825"}, {"Reference": "CVE-2001-1186", "Description": "Web server allows remote attackers to cause a denial of service via an HTTP request with a content-length value that is larger than the size of the request, which prevents server from timing out the connection.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1186"}, {"Reference": "CVE-2001-0191", "Description": "Service does not properly check the specified length of a cookie, which allows remote attackers to execute arbitrary commands via a buffer overflow, or brute force authentication by using a short cookie length.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0191"}, {"Reference": "CVE-2003-0429", "Description": "Traffic analyzer allows remote attackers to cause a denial of service and possibly execute arbitrary code via invalid IPv4 or IPv6 prefix lengths, possibly triggering a buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0429"}, {"Reference": "CVE-2000-0655", "Description": "Chat client allows remote attackers to cause a denial of service or execute arbitrary commands via a JPEG image containing a comment with an illegal field length of 1.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0655"}, {"Reference": "CVE-2004-0492", "Description": "Server allows remote attackers to cause a denial of service and possibly execute arbitrary code via a negative Content-Length HTTP header field causing a heap-based buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0492"}, {"Reference": "CVE-2004-0201", "Description": "Help program allows remote attackers to execute arbitrary commands via a heap-based buffer overflow caused by a .CHM file with a large length field", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0201"}, {"Reference": "CVE-2003-0825", "Description": "Name services does not properly validate the length of certain packets, which allows attackers to cause a denial of service and possibly execute arbitrary code. Can overlap zero-length issues", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0825"}, {"Reference": "CVE-2004-0095", "Description": "Policy manager allows remote attackers to cause a denial of service (memory consumption and crash) and possibly execute arbitrary code via an HTTP POST request with an invalid Content-Length value.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0095"}, {"Reference": "CVE-2004-0826", "Description": "Heap-based buffer overflow in library allows remote attackers to execute arbitrary code via a modified record length field in an SSLv2 client hello message.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0826"}, {"Reference": "CVE-2004-0808", "Description": "When domain logons are enabled, server allows remote attackers to cause a denial of service via a SAM_UAS_CHANGE request with a length value that is larger than the number of structures that are provided.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0808"}, {"Reference": "CVE-2002-1357", "Description": "Multiple SSH2 servers and clients do not properly handle packets or data elements with incorrect length specifiers, which may allow remote attackers to cause a denial of service or possibly execute arbitrary code.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1357"}, {"Reference": "CVE-2004-0774", "Description": "Server allows remote attackers to cause a denial of service (CPU and memory exhaustion) via a POST request with a Content-Length header set to -1.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0774"}, {"Reference": "CVE-2004-0989", "Description": "Multiple buffer overflows in xml library that may allow remote attackers to execute arbitrary code via long URLs.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0989"}, {"Reference": "CVE-2004-0568", "Description": "Application does not properly validate the length of a value that is saved in a session file, which allows remote attackers to execute arbitrary code via a malicious session file (.ht), web site, or Telnet URL contained in an e-mail message, triggering a buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0568"}, {"Reference": "CVE-2003-0327", "Description": "Server allows remote attackers to cause a denial of service via a remote password array with an invalid length, which triggers a heap-based buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0327"}, {"Reference": "CVE-2003-0345", "Description": "Product allows remote attackers to cause a denial of service and possibly execute arbitrary code via an SMB packet that specifies a smaller buffer length than is required.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0345"}, {"Reference": "CVE-2004-0430", "Description": "Server allows remote attackers to execute arbitrary code via a LoginExt packet for a Cleartext Password User Authentication Method (UAM) request with a PathName argument that includes an AFPName type string that is longer than the associated length field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0430"}, {"Reference": "CVE-2005-0064", "Description": "PDF viewer allows remote attackers to execute arbitrary code via a PDF file with a large /Encrypt /Length keyLength value.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0064"}, {"Reference": "CVE-2004-0413", "Description": "SVN client trusts the length field of SVN protocol URL strings, which allows remote attackers to cause a denial of service and possibly execute arbitrary code via an integer overflow that leads to a heap-based buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0413"}, {"Reference": "CVE-2004-0940", "Description": "Is effectively an accidental double increment of a counter that prevents a length check conditional from exiting a loop.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0940"}, {"Reference": "CVE-2002-1235", "Description": "Length field of a request not verified.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1235"}, {"Reference": "CVE-2005-3184", "Description": "Buffer overflow by modifying a length value.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3184"}], "RelatedAttackPatterns": ["47"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This probably overlaps other categories including zero-length issues."}], "Top25Examples": [{"Reference": "CVE-2022-1543", "Description": "Improper handling of Length parameter in GitHub repository erudika/scoold prior to 1.49.4. When the text size is large enough the service results in a momentary outage in a production environment. That can lead to memory corruption on the server."}, {"Reference": "CVE-2022-32959", "Description": "HiCOS\u2019 client-side citizen digital certificate component has a stack-based buffer overflow vulnerability when reading IC card due to insufficient parameter length validation for OS information. An unauthenticated physical attacker can exploit this vulnerability to execute arbitrary code, manipulate system data or terminate service."}, {"Reference": "CVE-2021-3454", "Description": "Truncated L2CAP K-frame causes assertion failure. Zephyr versions >= 2.4.0, >= v.2.50 contain Improper Handling of Length Parameter Inconsistency (CWE-130), Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fx88-6c29-vrp3"}, {"Reference": "CVE-2021-20608", "Description": "Improper Handling of Length Parameter Inconsistency vulnerability in Mitsubishi Electric GX Works2 versions 1.606G and prior allows a remote unauthenticated attacker to cause a DoS condition in GX Works2 by getting GX Works2 to read a tampered program file from a Mitsubishi Electric PLC by sending malicious crafted packets to tamper with the program file."}, {"Reference": "CVE-2021-20610", "Description": "Improper Handling of Length Parameter Inconsistency vulnerability in Mitsubishi Electric MELSEC iQ-R Series R00/01/02CPU, MELSEC iQ-R Series R04/08/16/32/120(EN)CPU, MELSEC iQ-R Series R08/16/32/120SFCPU, MELSEC iQ-R Series R08/16/32/120PCPU, MELSEC iQ-R Series R08/16/32/120PSFCPU, MELSEC iQ-R Series R16/32/64MTCPU, MELSEC iQ-R Series R12CCPU-V, MELSEC Q Series Q03UDECPU, MELSEC Q Series Q04/06/10/13/20/26/50/100UDEHCPU, MELSEC Q Series Q03/04/06/13/26UDVCPU, MELSEC Q Series Q04/06/13/26UDPVCPU, MELSEC Q Series Q12DCCPU-V, MELSEC Q Series Q24DHCCPU-V(G), MELSEC Q Series Q24/26DHCCPU-LS, MELSEC Q Series MR-MQ100, MELSEC Q Series Q172/173DCPU-S1, MELSEC Q Series Q172/173DSCPU, MELSEC Q Series Q170MCPU, MELSEC Q Series Q170MSCPU(-S1), MELSEC L Series L02/06/26CPU(-P), MELSEC L Series L26CPU-(P)BT and MELIPC Series MI5122-VW allows a remote unauthenticated attacker to cause a denial-of-service (DoS) condition by sending specially crafted packets. System reset is required for recovery."}, {"Reference": "CVE-2022-0677", "Description": "Improper Handling of Length Parameter Inconsistency vulnerability in the Update Server component of Bitdefender Endpoint Security Tools (in relay role), GravityZone (in Update Server role) allows an attacker to cause a Denial-of-Service. This issue affects: Bitdefender Update Server versions prior to 3.4.0.276. Bitdefender GravityZone versions prior to 26.4-1. Bitdefender Endpoint Security Tools for Linux versions prior to 6.2.21.171. Bitdefender Endpoint Security Tools for Windows versions prior to 7.4.1.111."}, {"Reference": "CVE-2022-3272", "Description": "Improper Handling of Length Parameter Inconsistency in GitHub repository ikus060/rdiffweb prior to 2.4.8."}, {"Reference": "CVE-2022-3290", "Description": "Improper Handling of Length Parameter Inconsistency in GitHub repository ikus060/rdiffweb prior to 2.4.8."}, {"Reference": "CVE-2022-30556", "Description": "Apache HTTP Server 2.4.53 and earlier may return lengths to applications calling r:wsread() that point past the end of the storage allocated for the buffer."}]}
{"ID": "1300", "Name": "Improper Protection of Physical Side Channels", "Abstraction": "Base", "Structure": "Simple", "Status": "Stable", "Description": "The device does not contain sufficient protection\n\tmechanisms to prevent physical side channels from exposing\n\tsensitive information due to patterns in physically observable\n\tphenomena such as variations in power consumption,\n\telectromagnetic emissions (EME), or acoustic emissions.", "ExtendedDescription": "\n\nAn adversary could monitor and measure physical phenomena to detect patterns and make inferences, even if it is not possible to extract the information in the digital domain.\n\n\nPhysical side channels have been well-studied for decades in the context of breaking implementations of cryptographic algorithms or other attacks against security features. These side channels may be easily observed by an adversary with physical access to the device, or using a tool that is in close proximity. If the adversary can monitor hardware operation and correlate its data processing with power, EME, and acoustic measurements, the adversary might be able to recover of secret keys and data.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "203", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "203", "ViewID": "1194", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}, {"Ordinality": "Resultant"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory", "Read Application Data"]}], "DetectionMethods": [{"Method": "Manual Analysis", "Description": "Perform a set of leakage detection tests such as the procedure outlined in the Test Vector Leakage Assessment (TVLA) test requirements for AES [REF-1230]. TVLA is the basis for the ISO standard 17825 [REF-1229]. A separate methodology is provided by [REF-1228]. Note that sole reliance on this method might not yield expected results [REF-1239] [REF-1240].", "Effectiveness": "Moderate"}, {"Method": "Manual Analysis", "Description": "\n\nPost-silicon, perform full side-channel attacks (penetration testing) covering as many known leakage models as possible against test code.\n", "Effectiveness": "Moderate"}, {"Method": "Manual Analysis", "Description": "\n\nPre-silicon - while the aforementioned TVLA methods can be performed post-silicon, models of device power consumption or other physical emanations can be built from information present at various stages of the hardware design process before fabrication. TVLA or known side-channel attacks can be applied to these simulated traces and countermeasures applied before tape-out. Academic research in this field includes [REF-1231] [REF-1232] [REF-1233].\n", "Effectiveness": "Moderate"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Apply blinding or masking techniques to implementations of cryptographic algorithms."}, {"Phase": ["Implementation"], "Description": "Add shielding or tamper-resistant protections to the device to increase the difficulty of obtaining measurements of the side-channel."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a device that checks a passcode to unlock the screen."}, {"Nature": "Bad", "ExampleCode": "As each character of the PIN number is entered, a correct character exhibits one current pulse shape while an incorrect character exhibits a different current pulse shape."}, {"BodyText": "PIN numbers used to unlock a cell phone should not exhibit any characteristics about themselves. This creates a side channel. An attacker could monitor the pulses using an oscilloscope or other method. Once the first character is correctly guessed (based on the oscilloscope readings), they can then move to the next character, which is much more efficient than the brute force method of guessing every possible sequence of characters."}, {"Nature": "Good", "ExampleCode": "Rather than comparing each character to the correct PIN value as it is entered, the device could accumulate the PIN in a register, and do the comparison all at once at the end. Alternatively, the components for the comparison could be modified so that the current pulse shape is the same regardless of the correctness of the entered character."}]}, {"Entries": [{"IntroText": "Consider the device vulnerability CVE-2021-3011, which affects certain microcontrollers [REF-1221]. The Google Titan Security Key is used for two-factor authentication using cryptographic algorithms. The device uses an internal secret key for this purpose and exchanges information based on this key for the authentication. If this internal secret key and the encryption algorithm were known to an adversary, the key function could be duplicated, allowing the adversary to masquerade as the legitimate user."}, {"Nature": "Bad", "ExampleCode": "The local method of extracting the secret key consists of plugging the key into a USB port and using electromagnetic (EM) sniffing tools and computers."}, {"Nature": "Good", "ExampleCode": "Several solutions could have been considered by the manufacturer. For example, the manufacturer could shield the circuitry in the key or add randomized delays, indirect calculations with random values involved, or randomly ordered calculations to make extraction much more difficult or a combination of these techniques."}]}, {"Entries": [{"IntroText": "The code snippet provided here is part of the modular exponentiation module found in the HACK@DAC'21 Openpiton System-on-Chip (SoC), specifically within the RSA peripheral [REF-1368]. Modular exponentiation, denoted as \"a^b mod n,\" is a crucial operation in the RSA public/private key encryption. In RSA encryption, where 'c' represents ciphertext, 'm' stands for a message, and 'd' corresponds to the private key, the decryption process is carried out using this modular exponentiation as follows: m = c^d mod n, where 'n' is the result of multiplying two large prime numbers."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "...\n module mod_exp\n\n```\n\t ...\n\t `UPDATE: begin\n\t\t if (exponent_reg != 'd0) begin\n```\nif (exponent_reg[0])** \n\t\t\t\n\t\t\t```\n```\nresult_reg <= result_next;** \n\t\t\t\t base_reg <= base_next;\n\t\t\t exponent_reg <= exponent_next;\n\t\t\t state <= `UPDATE;\n\t\t\t ...\n\t endmodule"}, {"BodyText": "The vulnerable code shows a buggy implementation of binary exponentiation where it updates the result register (result_reg) only when the corresponding exponent bit (exponent_reg[0]) is set to 1. However, when this exponent bit is 0, the output register is not updated. It's important to note that this implementation introduces a physical power side-channel vulnerability within the RSA core. This vulnerability could expose the private exponent to a determined physical attacker. Such exposure of the private exponent could lead to a complete compromise of the private key."}, {"BodyText": "To address mitigation requirements, the developer can develop the module by minimizing dependency on conditions, particularly those reliant on secret keys. In situations where branching is unavoidable, developers can implement masking mechanisms to obfuscate the power consumption patterns exhibited by the module (see good code example). Additionally, certain algorithms, such as the Karatsuba algorithm, can be implemented as illustrative examples of side-channel resistant algorithms, as they necessitate only a limited number of branch conditions [REF-1369]."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "...\n module mod_exp\n\n```\n\t ...\n\t `UPDATE: begin\n\t\t if (exponent_reg != 'd0) begin\n```\nif (exponent_reg[0]) begin** \n\t\t\t\n\t\t\t```\n```\nresult_reg <= result_next;** \n\t\t\t\t\n\t\t\t **end else begin** \n\t\t\t\n\t\t\t```\n```\nmask_reg <= result_next;** \n\t\t\t\t\n\t\t\t **end** \n\t\t\t base_reg <= base_next;\n\t\t\t exponent_reg <= exponent_next;\n\t\t\t state <= `UPDATE;\n\t\t\t ...\n\t endmodule"}]}], "ObservedExamples": [{"Reference": "CVE-2022-35888", "Description": "Power side-channels leak secret information from processor", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35888"}, {"Reference": "CVE-2021-3011", "Description": "electromagnetic-wave side-channel in security-related microcontrollers allows extraction of private key", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3011"}, {"Reference": "CVE-2019-14353", "Description": "Crypto hardware wallet's power consumption relates to total number of pixels illuminated, creating a side channel in the USB connection that allows attackers to determine secrets displayed such as PIN numbers and passwords", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-14353"}, {"Reference": "CVE-2020-27211", "Description": "Chain: microcontroller system-on-chip contains uses a register value stored in flash to set product protection state on the memory bus but does not contain protection against fault injection (CWE-1319), which leads to an incorrect initialization of the memory bus (CWE-1419) leading the product to be in an unprotected state.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-27211"}, {"Reference": "CVE-2013-4576", "Description": "message encryption software uses certain instruction sequences that allows RSA key extraction using a chosen-ciphertext attack and acoustic cryptanalysis", "Link": "https://www.cve.org/CVERecord?id=CVE-2013-4576"}, {"Reference": "CVE-2020-28368", "Description": "virtualization product allows recovery of AES keys from the guest OS using a side channel attack against a power/energy monitoring interface.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-28368"}, {"Reference": "CVE-2019-18673", "Description": "power consumption varies based on number of pixels being illuminated in a display, allowing reading of secrets such as the PIN by using the USB interface to measure power consumption", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-18673"}], "FunctionalAreas": ["Power"], "RelatedAttackPatterns": ["189", "699"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1301", "Name": "Insufficient or Incomplete Data Removal within Hardware Component", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product's data removal process does not completely delete all data and potentially sensitive information within hardware components.", "ExtendedDescription": "\n\nPhysical properties of hardware devices, such as remanence of magnetic media, residual charge of ROMs/RAMs, or screen burn-in may still retain sensitive data after a data removal process has taken place and power is removed.\n\n\nRecovering data after erasure or overwriting is possible due to a phenomenon called data remanence. For example, if the same value is written repeatedly to a memory location, the corresponding memory cells can become physically altered to a degree such that even after the original data is erased that data can still be recovered through physical characterization of the memory cells.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "226", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory", "Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Apply blinding or masking techniques to implementations of cryptographic algorithms."}, {"Phase": ["Implementation"], "Description": "Alter the method of erasure, add protection of media, or destroy the media to protect the data."}], "ObservedExamples": [{"Reference": "CVE-2019-8575", "Description": "Firmware Data Deletion Vulnerability in which a base station factory reset might not delete all user information. The impact of this enables a new owner of a used device that has been \"factory-default reset\" with a vulnerable firmware version can still retrieve, at least, the previous owner's wireless network name, and the previous owner's wireless security (such as WPA2) key. This issue was addressed with improved, data deletion.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-8575"}], "RelatedAttackPatterns": ["37"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}]}
{"ID": "1302", "Name": "Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product implements a security identifier mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. A transaction is sent without a security identifier.", "ExtendedDescription": "\n\nIn a System-On-Chip (SoC), various integrated circuits and hardware engines generate transactions such as to access (reads/writes) assets or perform certain actions (e.g., reset, fetch, compute). A typical transaction is comprised of source identity (to identify the originator of the transaction) and a destination identity (to route the transaction to the respective entity) in addition to much more information in the message. Sometimes the transactions are qualified with a Security Identifier. This Security Identifier helps the destination agent decide on the set of allowed or disallowed actions.\n\n\nA weakness that can exist in such transaction schemes is that the source agent does not consistently include the necessary Security Identifier with the transaction. If the Security Identifier is missing, the destination agent might drop the message (resulting in an inadvertent Denial-of-Service (DoS)) or take inappropriate action by default in its attempt to execute the transaction, resulting in privilege escalation or provision of unintended access.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1294", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during implementation and identified later during Testing or System Configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "DoS: Crash, Exit, or Restart", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Transaction details must be reviewed for design inconsistency and common weaknesses."}, {"Phase": ["Implementation"], "Description": "Security identifier definition and programming flow must be tested in pre-silicon and post-silicon testing."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a system with a register for storing AES key for encryption or decryption. The key is of 128 bits implemented as a set of four 32-bit registers. The key registers are assets, and the register AES_KEY_ACCESS_POLICY is defined to provide the necessary access controls.\n\n\nThe access-policy register defines which agents with a security identifier in the transaction can access the AES-key registers. Each bit in this 32-bit register defines a security identifier. There could be a maximum of 32 security identifiers that are allowed accesses to the AES-key registers. The number of the bit when set (i.e., \"1\") allows for a respective action from an agent whose identity matches the number of the bit; if set to \"0\" (i.e., Clear), it disallows the respective action to that corresponding agent."}, {"Nature": "Bad", "ExampleCode": "| Register | Field description | \n| --- | --- |\n| AES_ENC_DEC_KEY_0 | AES key [0:31] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_1 | AES key [32:63] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_2 | AES key [64:95] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_4 | AES key [96:127] for encryption or decryption, Default 0x00000000  |\n| AES_KEY_ACCESS_POLICY | [31:0] Default 0x00000004 - agent with Security Identifier \"2\" has access to AES_ENC_DEC_KEY_0 through AES_ENC_DEC_KEY_4 registers  |"}, {"BodyText": "The originator sends a transaction with no security identifier, i.e., meaning the value is \"0\" or NULL. The AES-Key-access register does not allow the necessary action and drops the transaction because the originator failed to include the required security identifier."}, {"Nature": "Good", "ExampleCode": "| Register | Field description | \n| --- | --- |\n| AES_ENC_DEC_KEY_0 | AES key [0:31] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_1 | AES key [32:63] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_2 | AES key [64:95] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_4 | AES key [96:127] for encryption or decryption, Default 0x00000000  |\n| AES_KEY_ACCESS_POLICY | [31:0] Default 0x00000002 - agent with security identifier \"2\" has access to AES_ENC_DEC_KEY_0 through AES_ENC_DEC_KEY_4 registers  |"}, {"BodyText": "The originator should send a transaction with Security Identifier \"2\" which will allow access to the AES-Key-access register and allow encryption and decryption operations."}]}], "RelatedAttackPatterns": ["121", "681"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1303", "Name": "Non-Transparent Sharing of Microarchitectural Resources", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "Hardware structures shared across execution contexts (e.g., caches and branch predictors) can violate the expected architecture isolation between contexts.", "ExtendedDescription": "\n\nModern processors use techniques such as out-of-order execution, speculation, prefetching, data forwarding, and caching to increase performance. Details about the implementation of these techniques are hidden from the programmer's view. This is problematic when the hardware implementation of these techniques results in resources being shared across supposedly isolated contexts. Contention for shared resources between different contexts opens covert channels that allow malicious programs executing in one context to recover information from another context.\n\n\nSome examples of shared micro-architectural resources that have been used to leak information between contexts are caches, branch prediction logic, and load or store buffers. Speculative and out-of-order execution provides an attacker with increased control over which data is leaked through the covert channel.\n\n\nIf the extent of resource sharing between contexts in the design microarchitecture is undocumented, it is extremely difficult to ensure system assets are protected against disclosure.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1189", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "203", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during implementation and identified later during Testing or System Configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data", "Read Memory"], "Note": "Microarchitectural side-channels have been used to leak specific information such as cryptographic keys, and Address Space Layout Randomization (ALSR) offsets as well as arbitrary memory."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Microarchitectural covert channels can be addressed using a mixture of hardware and software mitigation techniques. These include partitioned caches, new barrier and flush instructions, and disabling high resolution performance counters and timers."}, {"Phase": ["Requirements"], "Description": "Microarchitectural covert channels can be addressed using a mixture of hardware and software mitigation techniques. These include partitioned caches, new barrier and flush instructions, and disabling high resolution performance counters and timers."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "On some processors the hardware indirect branch predictor is shared between execution contexts, for example, between sibling SMT threads. When SMT thread A executes an indirect branch to a target address X, this target may be temporarily stored by the indirect branch predictor. A subsequent indirect branch mis-prediction for SMT thread B could speculatively execute instructions at X (or at a location in B's address space that partially aliases X). Even though the processor rolls back the architectural effects of the mis-predicted indirect branch, the memory accesses alter data cache state, which is not rolled back after the indirect branch is resolved."}]}], "RelatedAttackPatterns": ["663"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "As of CWE 4.9, members of the CWE Hardware SIG are closely analyzing this entry and others to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks. Additional investigation may include other weaknesses related to microarchitectural state. Finally, this entry's demonstrative example might not be appropriate. As a result, this entry might change significantly in CWE 4.10."}]}
{"ID": "1304", "Name": "Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product performs a power save/restore\n            operation, but it does not ensure that the integrity of\n            the configuration state is maintained and/or verified between\n\t    the beginning and ending of the operation.", "ExtendedDescription": "\n\nBefore powering down, the Intellectual Property (IP) saves current state (S) to persistent storage such as flash or always-on memory in order to optimize the restore operation. During this process, an attacker with access to the persistent storage may alter (S) to a configuration that could potentially modify privileges, disable protections, and/or cause damage to the hardware. If the IP does not validate the configuration state stored in persistent memory, upon regaining power or becoming operational again, the IP could be compromised through the activation of an unwanted/harmful configuration. \n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "345", "ViewID": "1000"}, {"Nature": "PeerOf", "CweID": "1271", "ViewID": "1194"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Weakness introduced via missing internal integrity guarantees during power save/restore"}, {"Phase": "Integration", "Note": "Weakness introduced via missing external integrity verification during power save/restore"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["DoS: Instability", "DoS: Crash, Exit, or Restart", "DoS: Resource Consumption (Other)", "Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Alter Execution Logic", "Quality Degradation", "Unexpected State", "Reduce Maintainability", "Reduce Performance", "Reduce Reliability"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Inside the IP, incorporate integrity checking on the configuration state via a cryptographic hash. The hash can be protected inside the IP such as by storing it in internal registers which never lose power. Before powering down, the IP performs a hash of the configuration and saves it in these persistent registers. Upon restore, the IP performs a hash of the saved configuration and compares it with the saved hash. If they do not match, then the IP should not trust the configuration."}, {"Phase": ["Integration"], "Description": "Outside the IP, incorporate integrity checking of the configuration state via a trusted agent. Before powering down, the trusted agent performs a hash of the configuration and saves the hash in persistent storage. Upon restore, the IP requests the trusted agent validate its current configuration. If the configuration hash is invalid, then the IP should not trust the configuration."}, {"Phase": ["Integration"], "Description": "Outside the IP, incorporate a protected environment that prevents undetected modification of the configuration state by untrusted agents. Before powering down, a trusted agent saves the IP's configuration state in this protected location that only it is privileged to. Upon restore, the trusted agent loads the saved state into the IP."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following pseudo code demonstrates the power save/restore workflow which may lead to weakness through a lack of validation of the config state after restore."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "void save_config_state()\n {\n\n```\n\t void* cfg;\n\t cfg = get_config_state();\n\t save_config_state(cfg);\n\t go_to_sleep();\n }\n void restore_config_state()\n {\n\t void* cfg;\n\t cfg = get_config_file();\n\t load_config_file(cfg);\n }\n```"}, {"BodyText": "The following pseudo-code is the proper workflow for the integrity checking mitigation:"}, {"Nature": "Good", "Language": "C", "ExampleCode": "void save_config_state()\n {\n\n```\n\t void* cfg;\n\t void* sha;\n\t cfg = get_config_state();\n\t save_config_state(cfg);\n\t // save hash(cfg) to trusted location\n\t sha = get_hash_of_config_state(cfg);\n\t save_hash(sha); \n\t go_to_sleep();\n }\n void restore_config_state()\n {\n\t void* cfg;\n\t void* sha_1, sha_2;\n\t cfg = get_config_file();\n\t // restore hash of config from trusted memory\n\t sha_1 = get_persisted_sha_value();\n\t sha_2 = get_hash_of_config_state(cfg);\n\t if (sha_1 != sha_2)\n\t\t assert_error_and_halt();\n\t load_config_file(cfg);\n }\n```"}, {"BodyText": "It must be noted that in the previous example of good pseudo code, the memory (where the hash of the config state is stored) must be trustworthy while the hardware is between the power save and restore states."}]}], "FunctionalAreas": ["Power"], "RelatedAttackPatterns": ["176"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "131", "Name": "Incorrect Calculation of Buffer Size", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "682", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "682", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "682", "ViewID": "1305", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "682", "ViewID": "1340", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "119", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Availability", "Confidentiality"], "Impact": ["DoS: Crash, Exit, or Restart", "Execute Unauthorized Code or Commands", "Read Memory", "Modify Memory"], "Note": "If the incorrect calculation is used in the context of memory allocation, then the software may create a buffer that is smaller or larger than expected. If the allocated buffer is smaller than expected, this could lead to an out-of-bounds read or write (CWE-119), possibly causing a crash, allowing arbitrary code execution, or exposing sensitive data."}], "DetectionMethods": [{"DetectionMethodID": "DM-1", "Method": "Automated Static Analysis", "Description": "\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n", "Effectiveness": "High", "EffectivenessNotes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."}, {"DetectionMethodID": "DM-2", "Method": "Automated Dynamic Analysis", "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "Effectiveness": "Moderate", "EffectivenessNotes": "Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem."}, {"DetectionMethodID": "DM-9", "Method": "Manual Analysis", "Description": "Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."}, {"DetectionMethodID": "DM-7", "Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.\n", "Effectiveness": "High", "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."}, {"Method": "Automated Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis", "Effectiveness": "High"}, {"Method": "Manual Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)", "Effectiveness": "SOAR Partial"}, {"Method": "Automated Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource Code Quality Analyzer", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts \"&\" characters to \"&amp;\" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer."}, {"MitigationID": "MIT-36", "Phase": ["Implementation"], "Description": "\n\nUnderstand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]\n\n\nAlso be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.\n"}, {"MitigationID": "MIT-8", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range."}, {"MitigationID": "MIT-15", "Phase": ["Architecture and Design"], "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."}, {"Phase": ["Implementation"], "Description": "When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130)."}, {"Phase": ["Implementation"], "Description": "When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated."}, {"MitigationID": "MIT-13", "Phase": ["Implementation"], "Description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.", "Effectiveness": "Moderate", "EffectivenessNotes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131). Additionally, this only addresses potential overflow issues. Resource consumption / exhaustion issues are still possible."}, {"Phase": ["Implementation"], "Description": "Use sizeof() on the appropriate data type to avoid CWE-467."}, {"Phase": ["Implementation"], "Description": "Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify validation and will reduce surprises related to unexpected casting."}, {"MitigationID": "MIT-4", "Phase": ["Architecture and Design"], "Strategy": "Libraries or Frameworks", "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nUse libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size.\n\n\nExamples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]\n"}, {"MitigationID": "MIT-10", "Phase": ["Operation", "Build and Compilation"], "Strategy": "Environment Hardening", "Description": "\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"}, {"MitigationID": "MIT-11", "Phase": ["Operation", "Build and Compilation"], "Strategy": "Environment Hardening", "Description": "\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"}, {"MitigationID": "MIT-12", "Phase": ["Operation"], "Strategy": "Environment Hardening", "Description": "\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."}, {"MitigationID": "MIT-26", "Phase": ["Implementation"], "Strategy": "Compilation or Build Hardening", "Description": "Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."}, {"MitigationID": "MIT-17", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Environment Hardening", "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."}, {"MitigationID": "MIT-22", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Sandbox or Jail", "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n", "Effectiveness": "Limited", "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."}], "DemonstrativeExamples": [{"ID": "DX-20", "Entries": [{"IntroText": "The following code allocates memory for a maximum number of widgets. It then gets a user-specified number of widgets, making sure that the user does not request too many. It then initializes the elements of the array using InitializeWidget(). Because the number of widgets can vary for each request, the code inserts a NULL pointer to signify the location of the last widget."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint i;\n\tunsigned int numWidgets;\n\tWidget **WidgetList;\n\tnumWidgets = GetUntrustedSizeValue();\n\tif ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {\n\t\tExitError(\"Incorrect number of widgets requested!\");\n\t}\n\tWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\n\tprintf(\"WidgetList ptr=%p\\n\", WidgetList);\n\tfor(i=0; i<numWidgets; i++) {\n\t\tWidgetList[i] = InitializeWidget();\n\t}\n\tWidgetList[numWidgets] = NULL;\n\tshowWidgets(WidgetList);\n```"}, {"BodyText": "However, this code contains an off-by-one calculation error (CWE-193). It allocates exactly enough space to contain the specified number of widgets, but it does not include the space for the NULL pointer. As a result, the allocated buffer is smaller than it is supposed to be (CWE-131). So if the user ever requests MAX_NUM_WIDGETS, there is an out-of-bounds write (CWE-787) when the NULL is assigned. Depending on the environment and compilation settings, this could cause memory corruption."}]}, {"ID": "DX-33", "Entries": [{"IntroText": "The following image processing code allocates a table for images."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\timg_t table_ptr; /*struct containing img data, 10kB each*/\n\tint num_imgs;\n\t...\n\tnum_imgs = get_num_imgs();\n\ttable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n\t...\n```"}, {"BodyText": "This code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119)."}]}, {"ID": "DX-19", "Entries": [{"IntroText": "This example applies an encoding procedure to an input string and stores it into a buffer."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE <= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i < strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '&' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '&';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('<' == user_supplied_string[i] ){\n```\n/* encode to &lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"}, {"BodyText": "The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."}]}, {"ID": "DX-21", "Entries": [{"IntroText": "The following code is intended to read an incoming packet from a socket and extract one or more headers."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tDataPacket *packet;\n\tint numHeaders;\n\tPacketHeader *headers;\n\tsock=AcceptSocketConnection();\n\tReadPacket(packet, sock);\n\tnumHeaders =packet->headers;\n\tif (numHeaders > 100) {\n\t\tExitError(\"too many headers!\");\n\t}\n\theaders = malloc(numHeaders * sizeof(PacketHeader);\n\tParsePacketHeaders(packet, headers);\n```"}, {"BodyText": "The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}]}, {"Entries": [{"IntroText": "The following code attempts to save three different identification numbers into an array. The array is allocated from memory using a call to malloc()."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint *id_sequence;\n```\n/* Allocate space for an array of three ids. */* \n\t\n\t\n\tid_sequence = (int*) malloc(3);\n\tif (id_sequence == NULL) exit(1);\n\t\n\t\n\t */* Populate the id array. */* \n\t\n\t\n\tid_sequence[0] = 13579;\n\tid_sequence[1] = 24680;\n\tid_sequence[2] = 97531;"}, {"BodyText": "The problem with the code above is the value of the size parameter used during the malloc() call. It uses a value of '3' which by definition results in a buffer of three bytes to be created. However the intention was to create a buffer that holds three ints, and in C, each int requires 4 bytes worth of memory, so an array of 12 bytes is needed, 4 bytes for each int. Executing the above code could result in a buffer overflow as 12 bytes of data is being saved into 3 bytes worth of allocated space. The overflow would occur during the assignment of id_sequence[0] and would continue with the assignment of id_sequence[1] and id_sequence[2]."}, {"BodyText": "The malloc() call could have used '3*sizeof(int)' as the value for the size parameter in order to allocate the correct amount of space required to store the three ints."}]}], "ObservedExamples": [{"Reference": "CVE-2020-17087", "Description": "Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-17087"}, {"Reference": "CVE-2004-1363", "Description": "substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1363"}, {"Reference": "CVE-2004-0747", "Description": "substitution overflow: buffer overflow using expansion of environment variables", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0747"}, {"Reference": "CVE-2005-2103", "Description": "substitution overflow: buffer overflow using a large number of substitution strings", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2103"}, {"Reference": "CVE-2005-3120", "Description": "transformation overflow: product adds extra escape characters to incoming data, but does not account for them in the buffer length", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3120"}, {"Reference": "CVE-2003-0899", "Description": "transformation overflow: buffer overflow when expanding \">\" to \"&gt;\", etc.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0899"}, {"Reference": "CVE-2001-0334", "Description": "expansion overflow: buffer overflow using wildcards", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0334"}, {"Reference": "CVE-2001-0248", "Description": "expansion overflow: long pathname + glob = overflow", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0248"}, {"Reference": "CVE-2001-0249", "Description": "expansion overflow: long pathname + glob = overflow", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0249"}, {"Reference": "CVE-2002-0184", "Description": "special characters in argument are not properly expanded", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0184"}, {"Reference": "CVE-2004-0434", "Description": "small length value leads to heap overflow", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0434"}, {"Reference": "CVE-2002-1347", "Description": "multiple variants", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1347"}, {"Reference": "CVE-2005-0490", "Description": "needs closer investigation, but probably expansion-based", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0490"}, {"Reference": "CVE-2004-0940", "Description": "needs closer investigation, but probably expansion-based", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0940"}, {"Reference": "CVE-2008-0599", "Description": "Chain: Language interpreter calculates wrong buffer size (CWE-131) by using \"size = ptr ? X : Y\" instead of \"size = (ptr ? X : Y)\" expression.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0599"}], "RelatedAttackPatterns": ["100", "47"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "\n\nThis is a broad category. Some examples include:\n\n\n  - simple math errors,\n\n  - incorrectly updating parallel counters,\n\n  - not accounting for size differences when \"transforming\" one input to another format (e.g. URL canonicalization or other transformation that can generate a result that's larger than the original input, i.e. \"expansion\").\n\nThis level of detail is rarely available in public reports, so it is difficult to find good examples."}, {"Type": "Maintenance", "Note": "\n\nThis weakness may be a composite or a chain. It also may contain layering or perspective differences.\n\n\nThis issue may be associated with many different types of incorrect calculations (CWE-682), although the integer overflow (CWE-190) is probably the most prevalent. This can be primary to resource consumption problems (CWE-400), including uncontrolled memory allocation (CWE-789). However, its relationship with out-of-bounds buffer access (CWE-119) must also be considered.\n"}], "Top25Examples": [{"Reference": "CVE-2021-21776", "Description": "An out-of-bounds write vulnerability exists in the SGI Format Buffer Size Processing functionality of Accusoft ImageGear 19.8. A specially crafted malformed file can lead to memory corruption. An attacker can provide a malicious file to trigger this vulnerability."}, {"Reference": "CVE-2021-21939", "Description": "A heap-based buffer overflow vulnerability exists in the XWD parser functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability."}, {"Reference": "CVE-2021-21943", "Description": "A heap-based buffer overflow vulnerability exists in the XWD parser functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability."}, {"Reference": "CVE-2021-35134", "Description": "Due to insufficient validation of ELF headers, an Incorrect Calculation of Buffer Size can occur in Boot leading to memory corruption in Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile"}, {"Reference": "CVE-2021-4206", "Description": "A flaw was found in the QXL display device emulation in QEMU. An integer overflow in the cursor_alloc() function can lead to the allocation of a small cursor object followed by a subsequent heap-based buffer overflow. This flaw allows a malicious privileged guest user to crash the QEMU process on the host or potentially execute arbitrary code within the context of the QEMU process."}, {"Reference": "CVE-2022-22137", "Description": "A memory corruption vulnerability exists in the ioca_mys_rgb_allocate functionality of Accusoft ImageGear 19.10. A specially-crafted malformed file can lead to an arbitrary free. An attacker can provide a malicious file to trigger this vulnerability."}, {"Reference": "CVE-2022-2566", "Description": "A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05"}, {"Reference": "CVE-2022-26474", "Description": "In sensorhub, there is a possible out of bounds write due to an incorrect calculation of buffer size. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07129717; Issue ID: ALPS07129717."}, {"Reference": "CVE-2022-32617", "Description": "In typec, there is a possible out of bounds write due to an incorrect calculation of buffer size. This could lead to local escalation of privilege, for an attacker who has physical access to the device, with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07262364; Issue ID: ALPS07262364."}, {"Reference": "CVE-2022-32618", "Description": "In typec, there is a possible out of bounds write due to an incorrect calculation of buffer size. This could lead to local escalation of privilege, for an attacker who has physical access to the device, with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07262454; Issue ID: ALPS07262454."}, {"Reference": "CVE-2022-32624", "Description": "In throttling, there is a possible out of bounds write due to an incorrect calculation of buffer size. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07405923; Issue ID: ALPS07405923."}, {"Reference": "CVE-2022-32630", "Description": "In throttling, there is a possible out of bounds write due to an incorrect calculation of buffer size. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07405966; Issue ID: ALPS07405966."}, {"Reference": "CVE-2022-32649", "Description": "In jpeg, there is a possible use after free due to a logic error. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07225840; Issue ID: ALPS07225840."}, {"Reference": "CVE-2022-32650", "Description": "In mtk-isp, there is a possible use after free due to a logic error. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07225853; Issue ID: ALPS07225853."}, {"Reference": "CVE-2022-32651", "Description": "In mtk-aie, there is a possible use after free due to a logic error. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07225857; Issue ID: ALPS07225857."}]}
{"ID": "1310", "Name": "Missing Ability to Patch ROM Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "Missing an ability to patch ROM code may leave a System or System-on-Chip (SoC) in a vulnerable state.", "ExtendedDescription": "\n\nA System or System-on-Chip (SoC) that implements a boot process utilizing security mechanisms such as Root-of-Trust (RoT) typically starts by executing code from a Read-only-Memory (ROM) component. The code in ROM is immutable, hence any security vulnerabilities discovered in the ROM code can never be fixed for the systems that are already in use.\n\n\nA common weakness is that the ROM does not have the ability to patch if security vulnerabilities are uncovered after the system gets shipped. This leaves the system in a vulnerable state where an adversary can compromise the SoC.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1329", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "This issue could be introduced during hardware architecture and design and can be identified later during Testing."}, {"Phase": "Implementation", "Note": "This issue could be introduced during implementation and can be identified later during Testing."}, {"Phase": "Integration", "Note": "This issue could be introduced during integration and can be identified later during Testing."}, {"Phase": "Manufacturing", "Note": "This issue could be introduced during manufacturing and can be identified later during Testing."}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context", "Reduce Maintainability"], "Likelihood": ["High"], "Note": "When the system is unable to be patched, it can be left in a vulnerable state."}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "Secure patch support to allow ROM code to be patched on the next boot.", "Effectiveness": "Moderate", "EffectivenessNotes": "Some parts of the hardware initialization or signature verification done to authenticate patches will always be \"not patchable.\""}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "Support patches that can be programmed in-field or during manufacturing through hardware fuses. This feature can be used for limited patching of devices after shipping, or for the next batch of silicon devices manufactured, without changing the full device ROM.", "Effectiveness": "Moderate", "EffectivenessNotes": "Patches that use hardware fuses will have limitations in terms of size and the number of patches that can be supported. Note that some parts of the hardware initialization or signature verification done to authenticate patches will always be \"not patchable.\""}], "DemonstrativeExamples": [{"ID": "DX-146", "Entries": [{"IntroText": "A System-on-Chip (SOC) implements a Root-of-Trust (RoT) in ROM to boot secure code. However, at times this ROM code might have security vulnerabilities and need to be patched. Since ROM is immutable, it can be impossible to patch."}, {"BodyText": "ROM does not have built-in application-programming interfaces (APIs) to patch if the code is vulnerable. Implement mechanisms to patch the vulnerable ROM code."}]}, {"Entries": [{"IntroText": "The example code is taken from the SoC peripheral wrapper inside the buggy OpenPiton SoC of HACK@DAC'21. The wrapper is used for connecting the communications between SoC peripherals, such as crypto-engines, direct memory access (DMA), reset controllers, JTAG, etc. The secure implementation of the SoC wrapper should allow users to boot from a ROM for Linux (i_bootrom_linux) or from a patchable ROM (i_bootrom_patch) if the Linux bootrom has security or functional issues.The example code is taken from the SoC peripheral wrapper inside the buggy OpenPiton SoC of HACK@DAC'21. The wrapper is used for connecting the communications between SoC peripherals, such as crypto-engines, direct memory access (DMA), reset controllers, JTAG, etc. The secure implementation of the SoC wrapper should allow users to boot from a ROM for Linux (i_bootrom_linux) or from a patchable ROM (i_bootrom_patch) if the Linux bootrom has security or functional issues."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "...\n\n```\n\t bootrom i_bootrom_patch (\n\t\t .clk_i ,\n\t\t .req_i ( rom_req ),\n\t\t .addr_i ( rom_addr ),\n\t\t .rdata_o ( rom_rdata_patch )\n\t );\n\t bootrom_linux i_bootrom_linux (\n\t\t .clk_i ,\n\t\t .req_i ( rom_req ),\n\t\t .addr_i ( rom_addr ),\n\t\t .rdata_o ( rom_rdata_linux )\n\t );\n```\nassign rom_rdata = (ariane_boot_sel_i) ? rom_rdata_linux : rom_rdata_linux;** \n ..."}, {"BodyText": "The above implementation causes the ROM data to be hardcoded for the linux system (rom_rdata_linux) regardless of the value of ariane_boot_sel_i. Therefore, the data (rom_rdata_patch) from the patchable ROM code is never used [REF-1396].\n\n\nThis weakness disables the ROM's ability to be patched. If attackers uncover security vulnerabilities in the ROM, the users must replace the entire device. Otherwise, the weakness exposes the system to a vulnerable state forever.\n\n\nA fix to this issue is to enable rom_rdata to be selected from the patchable rom (rom_rdata_patch) [REF-1397]."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "...\n\n```\n\t bootrom i_bootrom_patch (\n\t\t .clk_i ,\n\t\t .req_i ( rom_req ),\n\t\t .addr_i ( rom_addr ),\n\t\t .rdata_o ( rom_rdata_patch )\n\t );\n\t bootrom_linux i_bootrom_linux (\n\t\t .clk_i ,\n\t\t .req_i ( rom_req ),\n\t\t .addr_i ( rom_addr ),\n\t\t .rdata_o ( rom_rdata_linux )\n\t );\n```\nassign rom_rdata = (ariane_boot_sel_i) ? rom_rdata_patch : rom_rdata_linux;** \n ..."}]}], "RelatedAttackPatterns": ["682"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1311", "Name": "Improper Translation of Security Attributes by Fabric Bridge", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The bridge incorrectly translates security attributes from either trusted to untrusted or from untrusted to trusted when converting from one fabric protocol to another.", "ExtendedDescription": "\n\nA bridge allows IP blocks supporting different fabric protocols to be integrated into the system. Fabric end-points or interfaces usually have dedicated signals to transport security attributes. For example, HPROT signals in AHB, AxPROT signals in AXI, and MReqInfo and SRespInfo signals in OCP.\n\n\nThe values on these signals are used to indicate the security attributes of the transaction. These include the immutable hardware identity of the controller initiating the transaction, privilege level, and type of transaction (e.g., read/write, cacheable/non-cacheable, posted/non-posted).\n\n\nA weakness can arise if the bridge IP block, which translates the signals from the protocol used in the IP block endpoint to the protocol used by the central bus, does not properly translate the security attributes. As a result, the identity of the initiator could be translated from untrusted to trusted or vice-versa. This could result in access-control bypass, privilege escalation, or denial of service.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Verilog", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "VHDL", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "The translation must map signals in such a way that untrusted agents cannot map to trusted agents or vice-versa."}, {"Phase": ["Implementation"], "Description": "Ensure that the translation maps signals in such a way that untrusted agents cannot map to trusted agents or vice-versa."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The bridge interfaces between OCP and AHB end points. OCP uses MReqInfo signal to indicate security attributes, whereas AHB uses HPROT signal to indicate the security attributes. The width of MReqInfo can be customized as needed. In this example, MReqInfo is 5-bits wide and carries the privilege level of the OCP controller.\n\n\nThe values 5'h11, 5'h10, 5'h0F, 5'h0D, 5'h0C, 5'h0B, 5'h09, 5'h08, 5'h04, and 5'h02 in MReqInfo indicate that the request is coming from a privileged state of the OCP bus controller. Values 5'h1F, 5'h0E, and 5'h00 indicate untrusted, privilege state.\n\n\nThough HPROT is a 5-bit signal, we only consider the lower, two bits in this example. HPROT values 2'b00 and 2'b10 are considered trusted, and 2'b01 and 2'b11 are considered untrusted.\n\n\nThe OCP2AHB bridge is expected to translate trusted identities on the controller side to trusted identities on the responder side. Similarly, it is expected to translate untrusted identities on the controller side to untrusted identities on the responder side."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "module ocp2ahb\n ( \n\n```\n\t ahb_hprot, \n\t ocp_mreqinfo \n ); \n output [1:0] ahb_hprot; // output is 2 bit signal for AHB HPROT\n input [4:0] ocp_mreqinfo; // input is 5 bit signal from OCP MReqInfo\n wire [6:0] p0_mreqinfo_o_temp; // OCP signal that transmits hardware identity of bus controller\n wire y;\n reg [1:0] ahb_hprot;\n // hardware identity of bus controller is in bits 5:1 of p0_mreqinfo_o_temp signal\n assign p0_mreqinfo_o_temp[6:0] = {1'b0, ocp_mreqinfo[4:0], y};\n always @*\n begin\n\t case (p0_mreqinfo_o_temp[4:2])\n\t\t 000: ahb_hprot = 2'b11; // OCP MReqInfo to AHB HPROT mapping\n\t\t 001: ahb_hprot = 2'b00;\n\t\t 010: ahb_hprot = 2'b00;\n\t\t 011: ahb_hprot = 2'b01;\n\t\t 100: ahb_hprot = 2'b00;\n\t\t 101: ahb_hprot = 2'b00;\n\t\t 110: ahb_hprot = 2'b10;\n\t\t 111: ahb_hprot = 2'b00;\n\t endcase\n end\n endmodule\n```"}, {"BodyText": "Logic in the case statement only checks for MReqInfo bits 4:2, i.e., hardware-identity bits 3:1. When ocp_mreqinfo is 5'h1F or 5'h0E, p0_mreqinfo_o_temp[2] will be 1. As a result, untrusted IDs from OCP 5'h1F and 5'h0E get translated to trusted ahb_hprot values 2'b00."}]}], "RelatedAttackPatterns": ["1", "180", "233"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1312", "Name": "Missing Protection for Mirrored Regions in On-Chip Fabric Firewall", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The firewall in an on-chip fabric protects the main addressed region, but it does not protect any mirrored memory or memory-mapped-IO (MMIO) regions.", "ExtendedDescription": "\n\nFew fabrics mirror memory and address ranges, where mirrored regions contain copies of the original data. This redundancy is used to achieve fault tolerance. Whatever protections the fabric firewall implements for the original region should also apply to the mirrored regions. If not, an attacker could bypass existing read/write protections by reading from/writing to the mirrored regions to leak or corrupt the original data.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "1251", "ViewID": "1194"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control"], "Impact": ["Modify Memory", "Read Memory", "Bypass Protection Mechanism"]}], "DetectionMethods": [{"Method": "Manual Dynamic Analysis", "Description": "Using an external debugger, send write transactions to mirrored regions to test if original, write-protected regions are modified. Similarly, send read transactions to mirrored regions to test if the original, read-protected signals can be read.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "The fabric firewall should apply the same protections as the original region to the mirrored regions."}, {"Phase": ["Implementation"], "Description": "The fabric firewall should apply the same protections as the original region to the mirrored regions."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A memory-controller IP block is connected to the on-chip fabric in a System on Chip (SoC). The memory controller is configured to divide the memory into four parts: one original and three mirrored regions inside the memory. The upper two bits of the address indicate which region is being addressed. 00 indicates the original region and 01, 10, and 11 are used to address the mirrored regions. All four regions operate in a lock-step manner and are always synchronized. The firewall in the on-chip fabric is programmed to protect the assets in the memory."}, {"BodyText": "The firewall only protects the original range but not the mirrored regions."}, {"BodyText": "The attacker (as an unprivileged user) sends a write transaction to the mirrored region. The mirrored region has an address with the upper two bits set to \"10\" and the remaining bits of the address pointing to an asset. The firewall does not block this write transaction. Once the write is successful, contents in the protected-memory region are also updated. Thus, the attacker can bypass existing, memory protections."}, {"BodyText": "Firewall should protect mirrored regions."}]}], "RelatedAttackPatterns": ["456", "679"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1313", "Name": "Hardware Allows Activation of Test or Debug Logic at Runtime", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "During runtime, the hardware allows for test or debug logic (feature) to be activated, which allows for changing the state of the hardware. This feature can alter the intended behavior of the system and allow for alteration and leakage of sensitive data by an adversary.", "ExtendedDescription": "\n\nAn adversary can take advantage of test or debug logic that is made accessible through the hardware during normal operation to modify the intended behavior of the system. For example, an accessible Test/debug mode may allow read/write access to any system data. Using error injection (a common test/debug feature) during a transmit/receive operation on a bus, data may be modified to produce an unintended message. Similarly, confidentiality could be compromised by such features allowing access to secrets.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during implementation and identified later during Testing or System Configuration phases."}, {"Phase": "Integration", "Note": "Such issues could be introduced during integration and identified later during Testing or System configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Modify Memory", "Read Memory", "DoS: Crash, Exit, or Restart", "DoS: Instability", "DoS: Resource Consumption (CPU)", "DoS: Resource Consumption (Memory)", "DoS: Resource Consumption (Other)", "Execute Unauthorized Code or Commands", "Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Alter Execution Logic", "Quality Degradation", "Unexpected State", "Reduce Performance", "Reduce Reliability"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Insert restrictions on when the hardware's test or debug features can be activated. For example, during normal operating modes, the hardware's privileged modes that allow access to such features cannot be activated. Configuring the hardware to only enter a test or debug mode within a window of opportunity such as during boot or configuration stage. The result is disablement of such test/debug features and associated modes during normal runtime operations."}, {"Phase": ["Implementation"], "Description": "Insert restrictions on when the hardware's test or debug features can be activated. For example, during normal operating modes, the hardware's privileged modes that allow access to such features cannot be activated. Configuring the hardware to only enter a test or debug mode within a window of opportunity such as during boot or configuration stage. The result is disablement of such test/debug features and associated modes during normal runtime operations."}, {"Phase": ["Integration"], "Description": "Insert restrictions on when the hardware's test or debug features can be activated. For example, during normal operating modes, the hardware's privileged modes that allow access to such features cannot be activated. Configuring the hardware to only enter a test or debug mode within a window of opportunity such as during boot or configuration stage. The result is disablement of such test/debug features and associated modes during normal runtime operations."}], "ObservedExamples": [{"Reference": "CVE-2021-33150", "Description": "Hardware processor allows activation of test or debug logic at runtime.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33150"}, {"Reference": "CVE-2021-0146", "Description": "Processor allows the activation of test or debug logic at runtime, allowing escalation of privileges", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-0146"}], "RelatedAttackPatterns": ["121"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-33150", "Description": "Hardware allows activation of test or debug logic at runtime for some Intel(R) Trace Hub instances which may allow an unauthenticated user to potentially enable escalation of privilege via physical access."}]}
{"ID": "1314", "Name": "Missing Write Protection for Parametric Data Values", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The device does not write-protect the parametric data values for sensors that scale the sensor value, allowing untrusted software to manipulate the apparent result and potentially damage hardware or cause operational failure.", "ExtendedDescription": "\n\nVarious sensors are used by hardware to detect any devices operating outside of the design limits. The threshold limit values are set by hardware fuses or trusted software such as the BIOS. These limits may be related to thermal, power, voltage, current, and frequency. Hardware mechanisms may be used to protect against alteration of the threshold limit values by untrusted software.\n\n\nThe limit values are generally programmed in standard units for the type of value being read. However, the hardware-sensor blocks may report the settings in different units depending upon sensor design and operation. The raw sensor output value is converted to the desired units using a scale conversion based on the parametric data programmed into the sensor. The final converted value is then compared with the previously programmed limits.\n\n\nWhile the limit values are usually protected, the sensor parametric data values may not be. By changing the parametric data, safe operational limits may be bypassed.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "862", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "1299", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Sensor Hardware", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "The lack of a requirement to protect parametric values may contribute to this weakness."}, {"Phase": "Implementation", "Note": "The lack of parametric value protection may be a cause of this weakness."}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["Quality Degradation", "DoS: Resource Consumption (Other)"], "Likelihood": ["High"], "Note": "Sensor value manipulation, particularly thermal or power, may allow physical damage to occur or disabling of the device by a false fault shutdown causing a Denial-Of-Service."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Access controls for sensor blocks should ensure that only trusted software is allowed to change threshold limits and sensor parametric data.", "Effectiveness": "High"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Malicious software executes instructions to increase power consumption to the highest possible level while causing the clock frequency to increase to its maximum value. Such a program executing for an extended period of time would likely overheat the device, possibly resulting in permanent damage to the device. \n\n\nA ring, oscillator-based temperature sensor will generally report the sensed value as oscillator frequency rather than degrees centigrade. The temperature sensor will have calibration values that are used to convert the detected frequency into the corresponding temperature in degrees centigrade. \n\n\nConsider a SoC design where the critical maximum temperature limit is set in fuse values to 100C and is not modifiable by software. If the scaled thermal sensor output equals or exceeds this limit, the system is commanded to shut itself down. \n\n\nThe thermal sensor calibration values are programmable through registers that are exposed to system software. These registers allow software to affect the converted temperature output such that the output will never exceed the maximum temperature limit."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "The sensor frequency value is scaled by applying the function:\n\n```\n\tSensed Temp = a + b * Sensor Freq\n```\nwhere a and b are the programmable calibration data coefficients. Software sets a and b to zero ensuring the sensed temperature is always zero."}, {"BodyText": "This weakness may be addressed by preventing access to a and b."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "The sensor frequency value is scaled by applying the function:\n\n```\n\tSensed Temp = a + b * Sensor Freq\n```\nwhere a and b are the programmable calibration data coefficients. Untrusted software is prevented from changing the values of either a or b, preventing this method of manipulating the temperature."}]}], "ObservedExamples": [{"Reference": "CVE-2017-8252", "Description": "Kernel can inject faults in computations during the execution of TrustZone leading to information disclosure in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer Electronics Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice and Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-8252"}], "RelatedAttackPatterns": ["1"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1315", "Name": "Improper Setting of Bus Controlling Capability in Fabric End-point", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The bus controller enables bits in the fabric end-point to allow responder devices to control transactions on the fabric.", "ExtendedDescription": "\n\nTo support reusability, certain fabric interfaces and end points provide a configurable register bit that allows IP blocks connected to the controller to access other peripherals connected to the fabric. This allows the end point to be used with devices that function as a controller or responder. If this bit is set by default in hardware, or if firmware incorrectly sets it later, a device intended to be a responder on a fabric is now capable of controlling transactions to other devices and might compromise system security.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}, {"Phase": "System Configuration"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Modify Memory", "Read Memory", "Bypass Protection Mechanism"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "For responder devices, the register bit in the fabric end-point that enables the bus controlling capability must be set to 0 by default. This bit should not be set during secure-boot flows. Also, writes to this register must be access-protected to prevent malicious modifications to obtain bus-controlling capability."}, {"Phase": ["Implementation"], "Description": "For responder devices, the register bit in the fabric end-point that enables the bus controlling capability must be set to 0 by default. This bit should not be set during secure-boot flows. Also, writes to this register must be access-protected to prevent malicious modifications to obtain bus-controlling capability."}, {"Phase": ["System Configuration"], "Description": "For responder devices, the register bit in the fabric end-point that enables the bus controlling capability must be set to 0 by default. This bit should not be set during secure-boot flows. Also, writes to this register must be access-protected to prevent malicious modifications to obtain bus-controlling capability."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A typical, phone platform consists of the main, compute core or CPU, a DRAM-memory chip, an audio codec, a baseband modem, a power-management-integrated circuit (\"PMIC\"), a connectivity (WiFi and Bluetooth) modem, and several other analog/RF components. The main CPU is the only component that can control transactions, and all the other components are responder-only devices. All the components implement a PCIe end-point to interface with the rest of the platform. The responder devices should have the bus-control-enable bit in the PCIe-end-point register set to 0 in hardware to prevent the devices from controlling transactions to the CPU or other peripherals."}, {"BodyText": "The audio-codec chip does not have the bus-controller-enable-register bit hardcoded to 0. There is no platform-firmware flow to verify that the bus-controller-enable bit is set to 0 in all responders."}, {"BodyText": "Audio codec can now master transactions to the CPU and other platform components. Potentially, it can modify assets in other platform components to subvert system security."}, {"BodyText": "Platform firmware includes a flow to check the configuration of bus-controller-enable bit in all responder devices. If this register bit is set on any of the responders, platform firmware sets it to 0. Ideally, the default value of this register bit should be hardcoded to 0 in RTL. It should also have access control to prevent untrusted entities from setting this bit to become bus controllers."}]}], "RelatedAttackPatterns": ["1", "180"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1316", "Name": "Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The address map of the on-chip fabric has protected and unprotected regions overlapping, allowing an attacker to bypass access control to the overlapping portion of the protected region.", "ExtendedDescription": "\n\nVarious ranges can be defined in the system-address map, either in the memory or in Memory-Mapped-IO (MMIO) space. These ranges are usually defined using special range registers that contain information, such as base address and size. Address decoding is the process of determining for which range the incoming transaction is destined. To ensure isolation, ranges containing secret data are access-control protected.\n\n\nOccasionally, these ranges could overlap. The overlap could either be intentional (e.g. due to a limited number of range registers or limited choice in choosing size of the range) or unintentional (e.g. introduced by errors). Some hardware designs allow dynamic remapping of address ranges assigned to peripheral MMIO ranges. In such designs, intentional address overlaps can be created through misconfiguration by malicious software. When protected and unprotected ranges overlap, an attacker could send a transaction and potentially compromise the protections in place, violating the principle of least privilege. \n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Bus/Interface Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Authorization"], "Impact": ["Bypass Protection Mechanism", "Read Memory", "Modify Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Automated Dynamic Analysis", "Description": "Review address map in specification to see if there are any overlapping ranges.", "Effectiveness": "High"}, {"Method": "Manual Static Analysis", "Description": "Negative testing of access control on overlapped ranges.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "When architecting the address map of the chip, ensure that protected and unprotected ranges are isolated and do not overlap. When designing, ensure that ranges hardcoded in Register-Transfer Level (RTL) do not overlap."}, {"Phase": ["Implementation"], "Description": "Ranges configured by firmware should not overlap. If overlaps are mandatory because of constraints such as a limited number of registers, then ensure that no assets are present in the overlapped portion."}, {"Phase": ["Testing"], "Description": "Validate mitigation actions with robust testing."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "An on-chip fabric supports a 64KB address space that is memory-mapped. The fabric has two range registers that support creation of two protected ranges with specific size constraints--4KB, 8KB, 16KB or 32KB. Assets that belong to user A require 4KB, and those of user B require 20KB. Registers and other assets that are not security-sensitive require 40KB. One range register is configured to program 4KB to protect user A's assets. Since a 20KB range cannot be created with the given size constraints, the range register for user B's assets is configured as 32KB. The rest of the address space is left as open. As a result, some part of untrusted and open-address space overlaps with user B range."}, {"BodyText": "The fabric does not support least privilege, and an attacker can send a transaction to the overlapping region to tamper with user B data."}, {"BodyText": "Since range B only requires 20KB but is allotted 32KB, there is 12KB of reserved space. Overlapping this region of user B data, where there are no assets, with the untrusted space will prevent an attacker from tampering with user B data."}]}], "ObservedExamples": [{"Reference": "CVE-2009-4419", "Description": "Attacker can modify MCHBAR register to overlap with an attacker-controlled region, which modification prevents the SENTER instruction from properly applying VT-d protection while a Measured Launch Environment is being launched.", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4419"}], "RelatedAttackPatterns": ["456", "679"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "As of CWE 4.6, CWE-1260 and CWE-1316 are siblings under view 1000, but CWE-1260 might be a parent of CWE-1316. More analysis is warranted."}]}
{"ID": "1317", "Name": "Improper Access Control in Fabric Bridge", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product uses a fabric bridge for transactions between two Intellectual Property (IP) blocks, but the bridge does not properly perform the expected privilege, identity, or other access control checks between those IP blocks.", "ExtendedDescription": "\n\nIn hardware designs, different IP blocks are connected through interconnect-bus fabrics (e.g. AHB and OCP). Within a System on Chip (SoC), the IP block subsystems could be using different bus protocols. In such a case, the IP blocks are then linked to the central bus (and to other IP blocks) through a fabric bridge. Bridges are used as bus-interconnect-routing modules that link different protocols or separate, different segments of the overall SoC interconnect.\n\n\nFor overall system security, it is important that the access-control privileges associated with any fabric transaction are consistently maintained and applied, even when they are routed or translated by a fabric bridge. A bridge that is connected to a fabric without security features forwards transactions to the slave without checking the privilege level of the master and results in a weakness in SoC access-control security. The same weakness occurs if a bridge does not check the hardware identity of the transaction received from the slave interface of the bridge.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Availability"], "Impact": ["DoS: Crash, Exit, or Restart", "Bypass Protection Mechanism", "Read Memory", "Modify Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Simulation / Emulation", "Description": "RTL simulation to ensure that bridge-access controls are implemented properly.", "Effectiveness": "High"}, {"Method": "Formal Verification", "Description": "Formal verification of bridge RTL to ensure that access control cannot be bypassed.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Ensure that the design includes provisions for access-control checks in the bridge for both upstream and downstream transactions."}, {"Phase": ["Implementation"], "Description": "Implement access-control checks in the bridge for both upstream and downstream transactions."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example is from CVE-2019-6260 [REF-1138]. The iLPC2AHB bridge connects a CPU (with multiple, privilege levels, such as user, super user, debug, etc.) over AHB interface to an LPC bus. Several peripherals are connected to the LPC bus. The bridge is expected to check the privilege level of the transactions initiated in the core before forwarding them to the peripherals on the LPC bus."}, {"BodyText": "The bridge does not implement the checks and allows reads and writes from all privilege levels."}, {"BodyText": "To address this, designers should implement hardware-based checks that are either hardcoded to block untrusted agents from accessing secure peripherals or implement firmware flows that configure the bridge to block untrusted agents from making arbitrary reads or writes."}]}, {"Entries": [{"IntroText": "The example code below is taken from the AES and core local interrupt (CLINT) peripherals of the HACK@DAC'21 buggy OpenPiton SoC. The access to all the peripherals for a given privilege level of the processor is controlled by an access control module in the SoC. This ensures that malicious users with insufficient privileges do not get access to sensitive data, such as the AES keys used by the operating system to encrypt and decrypt information. The security of the entire system will be compromised if the access controls are incorrectly enforced. The access controls are enforced through the interconnect-bus fabrics, where access requests with insufficient access control permissions will be rejected."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "...\n module aes0_wrapper #(...)(...);\n ...\n\n```\n\t input logic acct_ctrl_i;\n ...\n\t axi_lite_interface #(...\n\t ) axi_lite_interface_i (\n\t ...\n```\n.en_o ( en_acct ),** \n\t\t ...\n ..);\n\n```\n```\nassign en = en_acct && acct_ctrl_i;** \n\t ...\n endmodule\n ...\n module clint #(...)(...);\n ...\n\n```\n\t axi_lite_interface #(...\n\t ) axi_lite_interface_i (\n\t ...\n```\n.en_o ( en ),** \n\t\t ...\n );\n ...\n endmodule"}, {"BodyText": "The previous code snippet [REF-1382] illustrates an instance of a vulnerable implementation of access control for the CLINT peripheral (see module clint). It also shows a correct implementation of access control for the AES peripheral (see module aes0_wrapper) [REF-1381]. An enable signal (en_o) from the fabric's AXI interface (present in both modules) is used to determine if an access request is made to the peripheral. In the case of the AES peripheral, this en_o signal is first received in a temporary signal en_acct. Then, the access request is enabled (by asserting the en signal) only if the request has sufficient access permissions (i.e., acct_ctrl_i signal should be enabled). However, in the case of the CLINT peripheral, the enable signal, en_o, from the AXI interface, is directly used to enable accesses. As a result, users with insufficient access permissions also get full access to the CLINT peripheral."}, {"BodyText": "To fix this, enable access requests to CLINT [REF-1383] only if the user has sufficient access as indicated by the acct_ctrl_i signal in the boolean && with en_acct."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "module clint #(...\n ) (\n ... \n\n```\n```\ninput logic acct_ctrl_i,** \n\t ...\n );\n\n```\n\t logic en\n```\n, en_acct** ;\n\t ...\n\n```\n\t axi_lite_interface #(...\n\t ) axi_lite_interface_i (\n ...\n\t .en_o ( \n```\nen_acct**  ),\n\t ...\n\n```\n\t );\n```\nassign en = en_acct && acct_ctrl_i;** \n\t ...\n endmodule"}]}], "ObservedExamples": [{"Reference": "CVE-2019-6260", "Description": "Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-6260"}], "RelatedAttackPatterns": ["122"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1318", "Name": "Missing Support for Security Features in On-chip Fabrics or Buses", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": " On-chip fabrics or buses either do not support or are not configured to support privilege separation or other security features, such as access control. ", "ExtendedDescription": "\n\nCertain on-chip fabrics and buses, especially simple and low-power buses, do not support security features. Apart from data transfer and addressing ports, some fabrics and buses do not have any interfaces to transfer privilege, immutable identity, or any other security attribute coming from the bus master. Similarly, they do not have dedicated signals to transport security-sensitive data from slave to master, such as completions for certain types of transactions. Few other on-chip fabrics and buses support security features and define specific interfaces/signals for transporting security attributes from master to slave or vice-versa. However, including these signals is not mandatory and could be left unconfigured when generating the register-transfer-level (RTL) description for the fabric. Such fabrics or buses should not be used to transport any security attribute coming from the bus master. In general, peripherals with security assets should not be connected to such buses before the transaction from the bus master reaches the bus, unless some form of access control is performed at a fabric bridge or another intermediate module.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "693", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Availability"], "Impact": ["DoS: Crash, Exit, or Restart", "Read Memory", "Modify Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "Review the fabric specification and ensure that it contains signals to transfer security-sensitive signals.", "Effectiveness": "High"}, {"Method": "Manual Static Analysis - Source Code", "Description": "Lack of security features can also be confirmed through manual RTL review of the fabric RTL.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "If fabric does not support security features, implement security checks in a bridge or any component that is between the master and the fabric. Alternatively, connect all fabric slaves that do not have any security assets under one such fabric and connect peripherals with security assets to a different fabric that supports security features."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Several systems on chips (SoCs) use the Advanced-Microcontroller Bus Architecture (AMBA) Advanced-Peripheral Bus (APB) protocol. APB is a simple, low-power bus and uses the PPROT[2:0] bits to indicate the security state of the bus masters ;PPROT[0] indicates privilege, PPROT[1] indicates secure/non-secure transaction, and PPROT[2] indicates instruction/data. Assume that there is no fabric bridge in the SoC. One of the slaves, the power-management unit, contains registers that store the thermal-shutdown limits."}, {"BodyText": "The APB bus is used to connect several bus masters, each with a unique and immutable hardware identity, to several slaves. For a CPU supporting 8 potential identities (each with varying privilege levels), 16 types of outgoing transactions can be made--8 read transactions with each supported privilege level and 8 write transactions with each supported privilege level."}, {"BodyText": "Since APB PPROT can only support up to 8 transaction types, access-control checks cannot be performed on transactions going to the slaves at the right granularity for all possible transaction types. Thus, potentially, user code running on the CPU could maliciously corrupt the thermal-shutdown-configuration registers to burn the device, resulting in permanent denial of service."}, {"BodyText": "In this scenario, only peripherals that need access protection from 8 of the 16 possible transaction types can be connected to the APB bus. Peripherals that require protection from the remaining 8 transaction types can be connected to a different APB bus. Alternatively, a bridge could be implemented to handle such complex scenarios before forwarding traffic to the APB bus."}]}, {"Entries": [{"IntroText": "The Open-Core-Protocol (OCP) fabric supports two configurable, width-optional signals for transporting security attributes: MReqInfo and SRespInfo. MReqInfo is used to transport security attributes from bus master to slave, and SRespInfo is used to transport security attributes from slave to bus master. An SoC uses OCP to connect several bus masters, each with a unique and immutable hardware identity, to several slaves. One of the bus masters, the CPU, reports the privilege level (user or super user) in addition to the unique identity. One of the slaves, the power-management unit, contains registers that store the thermal-shutdown limits."}, {"BodyText": "Since MReqInfo and SRespInfo are not mandatory, these signals are not configured when autogenerating RTL for the OCP fabric. Thus, the fabric cannot be used to transport security attributes from bus masters to slave."}, {"BodyText": "Code running at user-privilege level on the CPU could maliciously corrupt the thermal-shutdown-configuration registers to burn the device and cause permanent denial of service."}, {"BodyText": "To address this, configure the fabric to include MReqInfo and SRespInfo signals and use these to transport security identity and privilege level to perform access-control checks at the slave interface."}]}], "RelatedAttackPatterns": ["1", "180"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1319", "Name": "Improper Protection against Electromagnetic Fault Injection (EM-FI)", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The device is susceptible to electromagnetic fault injection attacks, causing device internal information to be compromised or security mechanisms to be bypassed.", "ExtendedDescription": "\n\nElectromagnetic fault injection may allow an attacker to locally and dynamically modify the signals (both internal and external) of an integrated circuit. EM-FI attacks consist of producing a local, transient magnetic field near the device, inducing current in the device wires. A typical EMFI setup is made up of a pulse injection circuit that generates a high current transient in an EMI coil, producing an abrupt magnetic pulse which couples to the target producing faults in the device, which can lead to:\n\n\n  - Bypassing security mechanisms such as secure JTAG or Secure Boot\n\n  - Leaking device information\n\n  - Modifying program flow\n\n  - Perturbing secure hardware modules (e.g. random number generators)\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "693", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Microcontroller Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Memory Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Power Management Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Test/Debug Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Sensor Hardware", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Availability"], "Impact": ["Modify Memory", "Read Memory", "Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "\n\n  - 1. Redundancy - By replicating critical operations and comparing the two outputs can help indicate whether a fault has been injected.\n\n  - 2. Error detection and correction codes - Gay, Mael, et al. proposed a new scheme that not only detects faults injected by a malicious adversary but also automatically corrects single nibble/byte errors introduced by low-multiplicity faults.\n\n  - 3. Fail by default coding - When checking conditions (switch or if) check all possible cases and fail by default because the default case in a switch (or the else part of a cascaded if-else-if construct) is used for dealing with the last possible (and valid) value without checking. This is prone to fault injection because this alternative is easily selected as a result of potential data manipulation [REF-1141].\n\n  - 4. Random Behavior - adding random delays before critical operations, so that timing is not predictable.\n\n  - 5. Program Flow Integrity Protection - The program flow can be secured by integrating run-time checking aiming at detecting control flow inconsistencies. One such example is tagging the source code to indicate the points not to be bypassed [REF-1147].\n\n  - 6. Sensors - Usage of sensors can detect variations in voltage and current.\n\n  - 7. Shields - physical barriers to protect the chips from malicious manipulation.\n\n"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In many devices, security related information is stored in fuses. These fuses are loaded into shadow registers at boot time. Disturbing this transfer phase with EM-FI can lead to the shadow registers storing erroneous values potentially resulting in reduced security."}, {"BodyText": "Colin O'Flynn has demonstrated an attack scenario which uses electro-magnetic glitching during booting to bypass security and gain read access to flash, read and erase access to shadow memory area (where the private password is stored). Most devices in the MPC55xx and MPC56xx series that include the Boot Assist Module (BAM) (a serial or CAN bootloader mode) are susceptible to this attack. In this paper, a GM ECU was used as a real life target. While the success rate appears low (less than 2 percent), in practice a success can be found within 1-5 minutes once the EMFI tool is setup. In a practical scenario, the author showed that success can be achieved within 30-60 minutes from a cold start."}]}], "ObservedExamples": [{"Reference": "CVE-2020-27211", "Description": "Chain: microcontroller system-on-chip uses a register value stored in flash to set product protection state on the memory bus and does not contain protection against fault injection (CWE-1319) which leads to an incorrect initialization of the memory bus (CWE-1419) causing the product to be in an unprotected state.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-27211"}], "RelatedAttackPatterns": ["624", "625"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "This entry is attack-oriented and may require significant modification in future versions, or even deprecation. It is not clear whether there is really a design \"mistake\" that enables such attacks, so this is not necessarily a weakness and may be more appropriate for CAPEC."}]}
{"ID": "132", "Name": "DEPRECATED: Miscalculated Null Termination", "Abstraction": "Base", "Structure": "Simple", "Status": "Deprecated", "Description": "This entry has been deprecated because it was a duplicate of CWE-170. All content has been transferred to CWE-170.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "1320", "Name": "Improper Protection for Outbound Error Messages and Alert Signals", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "Untrusted agents can disable alerts about signal conditions exceeding limits or the response mechanism that handles such alerts.\n\t\t\t", "ExtendedDescription": "\n\nHardware sensors are used to detect whether a device is operating within design limits. The threshold values for these limits are set by hardware fuses or trusted software such as a BIOS. Modification of these limits may be protected by hardware mechanisms.\n\n\nWhen device sensors detect out of bound conditions, alert signals may be generated for remedial action, which may take the form of device shutdown or throttling.\n\n\nWarning signals that are not properly secured may be disabled or used to generate spurious alerts, causing degraded performance or denial-of-service (DoS). These alerts may be masked by untrusted software. Examples of these alerts involve thermal and power sensor alerts.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Microcontroller Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Memory Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Power Management Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Test/Debug Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Sensor Hardware", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Instability", "DoS: Crash, Exit, or Restart", "Reduce Reliability", "Unexpected State"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Alert signals generated by critical events should be protected from access by untrusted agents. Only hardware or trusted firmware modules should be able to alter the alert configuration."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a platform design where a Digital-Thermal Sensor (DTS) is used to monitor temperature and compare that output against a threshold value. If the temperature output equals or exceeds the threshold value, the DTS unit sends an alert signal to the processor.\n\n\nThe processor, upon getting the alert, input triggers system shutdown. The alert signal is handled as a General-Purpose-I/O (GPIO) pin in input mode."}, {"Nature": "Bad", "ExampleCode": "The processor-GPIO controller exposes software-programmable controls that allow untrusted software to reprogram the state of the GPIO pin."}, {"BodyText": "Reprogramming the state of the GPIO pin allows malicious software to trigger spurious alerts or to set the alert pin to a zero value so that thermal sensor alerts are not received by the processor."}, {"Nature": "Good", "ExampleCode": "The GPIO alert-signal pin is blocked from untrusted software access and is controlled only by trusted software, such as the System BIOS."}]}], "RelatedAttackPatterns": ["1", "180"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1321", "Name": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component that specifies attributes that are to be initialized or updated in an object, but it does not properly control modifications of attributes of the object prototype.", "ExtendedDescription": "\n\nBy adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the product depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf).\n\n\nThis weakness is usually exploited by using a special attribute of objects called proto, constructor or prototype. Such attributes give access to the object prototype. This weakness is often found in code that assigns object attributes based on user input, or merges or clones objects recursively.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "915", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "913", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "471", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "JavaScript", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Likelihood": ["High"], "Note": "An attacker can inject attributes that are used in other components."}, {"Scope": ["Availability"], "Impact": ["DoS: Crash, Exit, or Restart"], "Likelihood": ["High"], "Note": "An attacker can override existing attributes with ones that have incompatible type, which may lead to a crash."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "By freezing the object prototype first (for example, Object.freeze(Object.prototype)), modification of the prototype becomes impossible.", "Effectiveness": "High", "EffectivenessNotes": "While this can mitigate this weakness completely, other methods are recommended when possible, especially in components used by upstream software (\"libraries\")."}, {"Phase": ["Architecture and Design"], "Description": "By blocking modifications of attributes that resolve to object prototype, such as proto or prototype, this weakness can be mitigated.", "Effectiveness": "High"}, {"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "When handling untrusted objects, validating using a schema can be used.", "Effectiveness": "Limited"}, {"Phase": ["Implementation"], "Description": "By using an object without prototypes (via Object.create(null) ), adding object prototype attributes by accessing the prototype via the special attributes becomes impossible, mitigating this weakness.", "Effectiveness": "High"}, {"Phase": ["Implementation"], "Description": "Map can be used instead of objects in most cases. If Map methods are used instead of object attributes, it is not possible to access the object prototype or modify it.", "Effectiveness": "Moderate"}], "DemonstrativeExamples": [{"ID": "DX-206", "Entries": [{"IntroText": "This function sets object attributes based on a dot-separated path."}, {"Nature": "Bad", "Language": "JavaScript", "ExampleCode": "```\n\tfunction setValueByPath (object, path, value) {\n\t\t const pathArray = path.split(\".\");\n\t\t const attributeToSet = pathArray.pop();\n\t\t let objectToModify = object;\n\t\t for (const attr of pathArray) {\n\t\t\tif (typeof objectToModify[attr] !== 'object') {\n\t\t\t\tobjectToModify[attr] = {};\n\t\t\t\t }\n\t\t\t objectToModify = objectToModify[attr];\n\t\t\t }\n\t\t objectToModify[attributeToSet] = value;\n\t\t return object;\n\t\t }\n```"}, {"BodyText": "This function does not check if the attribute resolves to the object prototype. These codes can be used to add \"isAdmin: true\" to the object prototype."}, {"Nature": "Bad", "Language": "JavaScript", "ExampleCode": "```\n\t setValueByPath({}, \"__proto__.isAdmin\", true)\n\t setValueByPath({}, \"constructor.prototype.isAdmin\", true)\n```"}, {"BodyText": "By using a denylist of dangerous attributes, this weakness can be eliminated."}, {"Nature": "Good", "Language": "JavaScript", "ExampleCode": "```\n\t function setValueByPath (object, path, value) {\n\t\t const pathArray = path.split(\".\");\n\t\t const attributeToSet = pathArray.pop();\n\t\t let objectToModify = object;\n\t\t for (const attr of pathArray) {\n```\n// Ignore attributes which resolve to object prototype* \n\t\t\t if (attr === \"__proto__\" || attr === \"constructor\" || attr === \"prototype\") {\n\t\t\t\n\t\t\t```\n\t\t\t\t continue;\n\t\t\t\t }\n\t\t\t if (typeof objectToModify[attr] !== \"object\") {\n\t\t\t\t objectToModify[attr] = {};\n\t\t\t\t }\n\t\t\t objectToModify = objectToModify[attr];\n\t\t\t }\n\t\t objectToModify[attributeToSet] = value;\n\t\t return object;\n\t\t }\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2018-3721", "Description": "Prototype pollution by merging objects.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-3721"}, {"Reference": "CVE-2019-10744", "Description": "Prototype pollution by setting default values to object attributes recursively.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-10744"}, {"Reference": "CVE-2019-11358", "Description": "Prototype pollution by merging objects recursively.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-11358"}, {"Reference": "CVE-2020-8203", "Description": "Prototype pollution by setting object attributes based on dot-separated path.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8203"}], "RelatedAttackPatterns": ["1", "180", "77"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-21169", "Description": "The package express-xss-sanitizer before 1.1.3 are vulnerable to Prototype Pollution via the allowedTags attribute, allowing the attacker to bypass xss sanitization."}, {"Reference": "CVE-2022-23395", "Description": "jQuery Cookie 1.4.1 is affected by prototype pollution, which can lead to DOM cross-site scripting (XSS)."}, {"Reference": "CVE-2022-3901", "Description": "Prototype Pollution in Visioweb.js 1.10.6 allows attackers to execute XSS on the client system."}, {"Reference": "CVE-2022-46175", "Description": "JSON5 is an extension to the popular JSON file format that aims to be easier to write and maintain by hand (e.g. for config files). The `parse` method of the JSON5 library before and including versions 1.0.1 and 2.2.1 does not restrict parsing of keys named `__proto__`, allowing specially crafted strings to pollute the prototype of the resulting object. This vulnerability pollutes the prototype of the object returned by `JSON5.parse` and not the global Object prototype, which is the commonly understood definition of Prototype Pollution. However, polluting the prototype of a single object can have significant security impact for an application if the object is later used in trusted operations. This vulnerability could allow an attacker to set arbitrary and unexpected keys on the object returned from `JSON5.parse`. The actual impact will depend on how applications utilize the returned object and how they filter unwanted keys, but could include denial of service, cross-site scripting, elevation of privilege, and in extreme cases, remote code execution. `JSON5.parse` should restrict parsing of `__proto__` keys when parsing JSON strings to objects. As a point of reference, the `JSON.parse` method included in JavaScript ignores `__proto__` keys. Simply changing `JSON5.parse` to `JSON.parse` in the examples above mitigates this vulnerability. This vulnerability is patched in json5 versions 1.0.2, 2.2.2, and later."}, {"Reference": "CVE-2021-20084", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in jquery-sparkle 1.5.2-beta allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-20085", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in backbone-query-parameters 0.4.0 allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-20086", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in jquery-bbq 1.2.1 allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-20087", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in jquery-deparam 0.5.1 allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-20088", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in mootools-more 1.6.0 allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-20089", "Description": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') in purl 2.3.2 allows a malicious user to inject properties into Object.prototype."}, {"Reference": "CVE-2021-23329", "Description": "The package nested-object-assign before 1.0.4 are vulnerable to Prototype Pollution via the default function, as demonstrated by running the PoC below."}, {"Reference": "CVE-2021-23395", "Description": "This affects all versions of package nedb. The library could be tricked into adding or modifying properties of Object.prototype using a __proto__ or constructor.prototype payload."}, {"Reference": "CVE-2021-23396", "Description": "All versions of package lutils are vulnerable to Prototype Pollution via the main (merge) function."}, {"Reference": "CVE-2021-23408", "Description": "This affects the package com.graphhopper:graphhopper-web-bundle before 3.2, from 4.0-pre1 and before 4.0. The URL parser could be tricked into adding or modifying properties of Object.prototype using a constructor or __proto__ payload."}, {"Reference": "CVE-2021-25912", "Description": "Prototype pollution vulnerability in 'dotty' versions 0.0.1 through 0.1.0 allows attackers to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25913", "Description": "Prototype pollution vulnerability in 'set-or-get' version 1.0.0 through 1.2.10 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25914", "Description": "Prototype pollution vulnerability in 'object-collider' versions 1.0.0 through 1.0.3 allows attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25916", "Description": "Prototype pollution vulnerability in 'patchmerge' versions 1.0.0 through 1.0.1 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25927", "Description": "Prototype pollution vulnerability in 'safe-flat' versions 2.0.0 through 2.0.1 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25928", "Description": "Prototype pollution vulnerability in 'safe-obj' versions 1.0.0 through 1.0.2 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25941", "Description": "Prototype pollution vulnerability in 'deep-override' versions 1.0.0 through 1.0.1 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25943", "Description": "Prototype pollution vulnerability in '101' versions 1.0.0 through 1.6.3 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25944", "Description": "Prototype pollution vulnerability in 'deep-defaults' versions 1.0.0 through 1.0.5 allows attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25946", "Description": "Prototype pollution vulnerability in `nconf-toml` versions 0.0.1 through 0.0.2 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25947", "Description": "Prototype pollution vulnerability in 'nestie' versions 0.0.0 through 1.0.0 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2021-25953", "Description": "Prototype pollution vulnerability in 'putil-merge' versions1.0.0 through 3.6.6 allows attacker to cause a denial of service and may lead to remote code execution."}, {"Reference": "CVE-2022-23623", "Description": "Frourio is a full stack framework, for TypeScript. Frourio users who uses frourio version prior to v0.26.0 and integration with class-validator through `validators/` folder are subject to a input validation vulnerability. Validators do not work properly for request bodies and queries in specific situations and some input is not validated at all. Users are advised to update frourio to v0.26.0 or later and to install `class-transformer` and `reflect-metadata`."}, {"Reference": "CVE-2022-23624", "Description": "Frourio-express is a minimal full stack framework, for TypeScript. Frourio-express users who uses frourio-express version prior to v0.26.0 and integration with class-validator through `validators/` folder are subject to a input validation vulnerability. Validators do not work properly for request bodies and queries in specific situations and some input is not validated at all. Users are advised to update frourio to v0.26.0 or later and to install `class-transformer` and `reflect-metadata`."}]}
{"ID": "1322", "Name": "Use of Blocking Code in Single-threaded, Non-blocking Context", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses a non-blocking model that relies on a single threaded process\n\t\t\tfor features such as scalability, but it contains code that can block when it is invoked.", "ExtendedDescription": "\n\nWhen an attacker can directly invoke the blocking code, or the blocking code can be affected by environmental conditions that can be influenced by an attacker, then this can lead to a denial of service by causing unexpected hang or freeze of the code. Examples of blocking code might be an expensive computation or calling blocking library calls, such as those that perform exclusive file operations or require a successful network operation.\n\n\nDue to limitations in multi-thread models, single-threaded models are used to overcome the resource constraints that are caused by using many threads. In such a model, all code should generally be non-blocking. If blocking code is called, then the event loop will effectively be stopped, which can be undesirable or dangerous. Such models are used in Python asyncio, Vert.x, and Node.js, or other custom event loop code.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "834", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "835", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Resource Consumption (CPU)"], "Note": "An unexpected call to blocking code can trigger an infinite loop, or a large loop that causes the software to pause and wait indefinitely."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Generally speaking, blocking calls should be replaced with non-blocking alternatives that can be used asynchronously. Expensive computations should be passed off to worker threads, although the correct approach depends on the framework being used."}, {"Phase": ["Implementation"], "Description": "For expensive computations, consider breaking them up into multiple smaller computations. Refer to the documentation of the framework being used for guidance."}], "RelatedAttackPatterns": ["25"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1323", "Name": "Improper Management of Sensitive Trace Data", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "Trace data collected from several sources on the\n                System-on-Chip (SoC) is stored in unprotected locations or\n                transported to untrusted agents.", "ExtendedDescription": "\n\nTo facilitate verification of complex System-on-Chip (SoC) designs, SoC integrators add specific IP blocks that trace the SoC's internal signals in real-time. This infrastructure enables observability of the SoC's internal behavior, validation of its functional design, and detection of hardware and software bugs. Such tracing IP blocks collect traces from several sources on the SoC including the CPU, crypto coprocessors, and on-chip fabrics. Traces collected from these sources are then aggregated inside trace IP block and forwarded to trace sinks, such as debug-trace ports that facilitate debugging by external hardware and software debuggers.\n\n\nSince these traces are collected from several security-sensitive sources, they must be protected against untrusted debuggers. If they are stored in unprotected memory, an untrusted software debugger can access these traces and extract secret information. Additionally, if security-sensitive traces are not tagged as secure, an untrusted hardware debugger might access them to extract confidential information.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Note": "An adversary can read secret values if they are captured in debug traces and stored unsafely."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Tag traces to indicate owner and debugging privilege level (designer, OEM, or end user) needed to access that trace."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In a SoC, traces generated from sources include security-sensitive IP blocks such as CPU (with tracing information such as instructions executed and memory operands), on-chip fabric (e.g., memory-transfer signals, transaction type and destination, and on-chip-firewall-error signals), power-management IP blocks (e.g., clock- and power-gating signals), and cryptographic coprocessors (e.g., cryptographic keys and intermediate values of crypto operations), among other non-security-sensitive IP blocks including timers and other functional blocks. The collected traces are then forwarded to the debug and trace interface used by the external hardware debugger."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "The traces do not have any privilege level attached to them. All collected traces can be viewed by any debugger (i.e., SoC designer, OEM debugger, or end user)."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "Some of the traces are SoC-design-house secrets, while some are OEM secrets. Few are end-user secrets and the rest are not security-sensitive. Tag all traces with the appropriate, privilege level at the source. The bits indicating the privilege level must be immutable in their transit from trace source to the final, trace sink. Debugger privilege level must be checked before providing access to traces."}]}], "RelatedAttackPatterns": ["150", "167", "545"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1324", "Name": "DEPRECATED: Sensitive Information Accessible by Physical Probing of JTAG Interface", "Abstraction": "Base", "Structure": "Simple", "Status": "Deprecated", "Description": "This entry has been deprecated because it was at a lower level of abstraction than supported by CWE. All relevant content has been integrated into CWE-319.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "1325", "Name": "Improperly Controlled Sequential Memory Allocation", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.", "ExtendedDescription": "\n\nWhile the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "770", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "789", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "476", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "Stack Exhaustion", "Description": "When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325."}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Resource Consumption (Memory)"], "Note": "Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Ensure multiple allocations of the same kind of object are properly tracked - possibly across multiple sessions, requests, or messages. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."}, {"Phase": ["Operation"], "Description": "Run the program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example contains a small allocation of stack memory. When the program was first constructed, the number of times this memory was allocated was probably inconsequential and presented no problem. Over time, as the number of objects in the database grow, the number of allocations will grow - eventually consuming the available stack, i.e. \"stack exhaustion.\" An attacker who is able to add elements to the database could cause stack exhaustion more rapidly than assumed by the developer."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n```\n// Gets the size from the number of objects in a database, which over time can conceivably get very large* \n\t int end_limit = get_nmbr_obj_from_db();\n\t int i;\n\t int *base = NULL;\n\t int *p =base;\n\t for (i = 0; i < end_limit; i++)\n\t {\n\t\n\t```\n\t\t *p = alloca(sizeof(int *)); \n```\n// Allocate memory on the stack* \n\t\t p = *p; \n\t\t *// // Point to the next location to be saved* \n\t\t }"}, {"BodyText": "Since this uses alloca(), it allocates memory directly on the stack. If end_limit is large enough, then the stack can be entirely consumed."}]}], "ObservedExamples": [{"Reference": "CVE-2020-36049", "Description": "JavaScript-based packet decoder uses concatenation of many small strings, causing out-of-memory (OOM) condition", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-36049"}, {"Reference": "CVE-2019-20176", "Description": "Product allocates a new buffer on the stack for each file in a directory, allowing stack exhaustion", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-20176"}, {"Reference": "CVE-2013-1591", "Description": "Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.", "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1591"}], "RelatedAttackPatterns": ["130"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-23486", "Description": "libp2p-rust is the official rust language Implementation of the libp2p networking stack. In versions prior to 0.45.1 an attacker node can cause a victim node to allocate a large number of small memory chunks, which can ultimately lead to the victim\u2019s process running out of memory and thus getting killed by its operating system. When executed continuously, this can lead to a denial of service attack, especially relevant on a larger scale when run against more than one node of a libp2p based network. Users are advised to upgrade to `libp2p` `v0.45.1` or above. Users unable to upgrade should reference the DoS Mitigation page for more information on how to incorporate mitigation strategies, monitor their application, and respond to attacks: https://docs.libp2p.io/reference/dos-mitigation/."}]}
{"ID": "1326", "Name": "Missing Immutable Root of Trust in Hardware", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "A missing immutable root of trust in the hardware results in the ability to bypass secure boot or execute untrusted or adversarial boot code.", "ExtendedDescription": "\n\nA System-on-Chip (SoC) implements secure boot by verifying or authenticating signed boot code. The signing of the code is achieved by an entity that the SoC trusts. Before executing the boot code, the SoC verifies that the code or the public key with which the code has been signed has not been tampered with. The other data upon which the SoC depends are system-hardware settings in fuses such as whether \"Secure Boot is enabled\". These data play a crucial role in establishing a Root of Trust (RoT) to execute secure-boot flows.\n\n\nOne of the many ways RoT is achieved is by storing the code and data in memory or fuses. This memory should be immutable, i.e., once the RoT is programmed/provisioned in memory, that memory should be locked and prevented from further programming or writes. If the memory contents (i.e., RoT) are mutable, then an adversary can modify the RoT to execute their choice of code, resulting in a compromised secure boot.\n\n\nNote that, for components like ROM, secure patching/update features should be supported to allow authenticated and authorized updates in the field. \n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "693", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Security Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation", "Note": "Such issues could be introduced during policy definition, hardware architecture, design, manufacturing, and/or provisioning. They can be identified later during testing or system configuration phases."}], "CommonConsequences": [{"Scope": ["Authentication", "Authorization"], "Impact": ["Gain Privileges or Assume Identity", "Execute Unauthorized Code or Commands", "Modify Memory"], "Likelihood": ["High"]}], "DetectionMethods": [{"Method": "Automated Dynamic Analysis", "Description": "Automated testing can verify that RoT components are immutable.", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "Root of trust elements and memory should be part of architecture and design reviews.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "When architecting the system, the RoT should be designated for storage in a memory that does not allow further programming/writes."}, {"Phase": ["Implementation"], "Description": "During implementation and test, the RoT memory location should be demonstrated to not allow further programming/writes."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The RoT is stored in memory. This memory can be modified by an adversary. For example, if an SoC implements \"Secure Boot\" by storing the boot code in an off-chip/on-chip flash, the contents of the flash can be modified by using a flash programmer. Similarly, if the boot code is stored in ROM (Read-Only Memory) but the public key or the hash of the public key (used to enable \"Secure Boot\") is stored in Flash or a memory that is susceptible to modifications or writes, the implementation is vulnerable."}, {"BodyText": "In general, if the boot code, key materials and data that enable \"Secure Boot\" are all mutable, the implementation is vulnerable."}, {"BodyText": "Good architecture defines RoT as immutable in hardware. One of the best ways to achieve immutability is to store boot code, public key or hash of the public key and other relevant data in Read-Only Memory (ROM) or One-Time Programmable (OTP) memory that prevents further programming or writes."}]}, {"Entries": [{"IntroText": "The example code below is a snippet from the bootrom of the HACK@DAC'19 buggy OpenPiton SoC [REF-1348]. The contents of the bootrom are critical in implementing the hardware root of trust."}, {"BodyText": "It performs security-critical functions such as defining the system's device tree, validating the hardware cryptographic accelerators in the system, etc. Hence, write access to bootrom should be strictly limited to authorized users or removed completely so that bootrom is immutable. In this example (see the vulnerable code source), the boot instructions are stored in bootrom memory, mem. This memory can be read using the read address, addr_i, but write access should be restricted or removed."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "```\n\t...\n\t\talways_ff @(posedge clk_i) begin\n\t\t\tif (req_i) begin\n\t\t\t\tif (!we_i) begin\n\t\t\t\t\traddr_q <= addr_i[$clog2(RomSize)-1+3:3];\n\t\t\t\t end else begin \n```\nmem[addr_i[$clog2(RomSize)-1+3:3]] <= wdata_i;**  end end end ...\n\n```\n\t // this prevents spurious Xes from propagating into the speculative fetch stage of the core \n\tassign rdata_o = (raddr_q < RomSize) ? mem[raddr_q] : '0;\n\t ... \n```"}, {"BodyText": "The vulnerable code shows an insecure implementation of the bootrom where bootrom can be written directly by enabling write enable, we_i, and using write address, addr_i, and write data, wdata_i."}, {"BodyText": "To mitigate this issue, remove the write access to bootrom memory. [REF-1349]"}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "```\n\t...\n\t\talways_ff @(posedge clk_i) begin\n```\nif (req_i) begin** \n\t\t\t\n\t\t\t```\n\t\t\t\traddr_q <= addr_i[$clog2(RomSize)-1+3:3];\n\t\t\t end\n\t\t end\n\t ...\n\t // this prevents spurious Xes from propagating into the speculative fetch stage of the core \n\tassign rdata_o = (raddr_q < RomSize) ? mem[raddr_q] : '0;\n\t ... \n```"}]}], "RelatedAttackPatterns": ["679", "68"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1327", "Name": "Binding to an Unrestricted IP Address", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product assigns the address 0.0.0.0 for a database server, a cloud service/instance, or any computing resource that communicates remotely.", "ExtendedDescription": "\n\nWhen a server binds to the address 0.0.0.0, it allows connections from every IP address on the local machine, effectively exposing the server to every possible network. This might be much broader access than intended by the developer or administrator, who might only be expecting the server to be reachable from a single interface/network.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Other", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Web Server", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Client Server", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Cloud Computing", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "System Configuration"}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Amplification"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["System Configuration"], "Description": "Assign IP addresses that are not 0.0.0.0.", "Effectiveness": "High"}, {"Phase": ["System Configuration"], "Strategy": "Firewall", "Description": "Unwanted connections to the configured server may be denied through a firewall or other packet filtering measures.", "Effectiveness": "High"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code snippet uses 0.0.0.0 in a Puppet script."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "signingserver::instance {\n\n```\n\t \"nightly-key-signing-server\": \n\t\t listenaddr => \"0.0.0.0\",\n\t\t port => \"9100\",\n\t\t code_tag => \"SIGNING_SERVER\",\n\t }\n```"}, {"BodyText": "The Puppet code snippet is used to provision a signing server that will use 0.0.0.0 to accept traffic. However, as 0.0.0.0 is unrestricted, malicious users may use this IP address to launch frequent requests and cause denial of service attacks."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "signingserver::instance {\n\n```\n\t \"nightly-key-signing-server\": \n\t\t listenaddr => \"127.0.0.1\",\n\t\t port => \"9100\",\n\t\t code_tag => \"SIGNING_SERVER\",\n\t }\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2022-21947", "Description": "Desktop manager for Kubernetes and container management binds a service to 0.0.0.0, allowing users on the network to make requests to a dashboard API.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-21947"}], "RelatedAttackPatterns": ["1"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-21947", "Description": "A Exposure of Resource to Wrong Sphere vulnerability in Rancher Desktop of SUSE allows attackers in the local network to connect to the Dashboard API (steve) to carry out arbitrary actions. This issue affects: SUSE Rancher Desktop versions prior to V."}, {"Reference": "CVE-2022-29820", "Description": "In JetBrains PyCharm before 2022.1 exposure of the debugger port to the internal network was possible"}]}
{"ID": "1328", "Name": "Security Version Number Mutable to Older Versions", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "Security-version number in hardware is mutable, resulting in the ability to downgrade (roll-back) the boot firmware to vulnerable code versions.", "ExtendedDescription": "\n\nA System-on-Chip (SoC) implements secure boot or verified boot. It might support a security version number, which prevents downgrading the current firmware to a vulnerable version. Once downgraded to a previous version, an adversary can launch exploits on the SoC and thus compromise the security of the SoC. These downgrade attacks are also referred to as roll-back attacks.\n\n\nThe security version number must be stored securely and persistently across power-on resets. A common weakness is that the security version number is modifiable by an adversary, allowing roll-back or downgrade attacks or, under certain circumstances, preventing upgrades (i.e. Denial-of-Service on upgrades). In both cases, the SoC is in a vulnerable state.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "285", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "757", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Security Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation", "Note": "Such issues could be introduced during hardware architecture and design, and can be identified later during testing or system configuration phases."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Authentication", "Authorization"], "Impact": ["Other"], "Likelihood": ["High"], "Note": "Impact includes roll-back or downgrade to a vulnerable version of the firmware or DoS (prevent upgrades)."}], "DetectionMethods": [{"Method": "Automated Dynamic Analysis", "Description": "Mutability of stored security version numbers and programming with older firmware images should be part of automated testing.", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "Anti-roll-back features should be reviewed as part of Architecture or Design review.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "When architecting the system, security version data should be designated for storage in registers that are either read-only or have access controls that prevent modification by an untrusted agent."}, {"Phase": ["Implementation"], "Description": "During implementation and test, security version data should be demonstrated to be read-only and access controls should be validated."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A new version of firmware is signed with a security version number higher than the previous version. During the firmware update process the SoC checks for the security version number and upgrades the SoC firmware with the latest version. This security version number is stored in persistent memory upon successful upgrade for use across power-on resets."}, {"BodyText": "In general, if the security version number is mutable, the implementation is vulnerable. A mutable security version number allows an adversary to change the security version to a lower value to allow roll-back or to a higher value to prevent future upgrades."}, {"BodyText": "The security version number should be stored in immutable hardware such as fuses, and the writes to these fuses should be highly access-controlled with appropriate authentication and authorization protections."}]}], "RelatedAttackPatterns": ["176"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1329", "Name": "Reliance on Component That is Not Updateable", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product contains a component that cannot be updated or patched in order to remove vulnerabilities or significant bugs.", "ExtendedDescription": "\n\n If the component is discovered to contain a vulnerability or critical bug, but the issue cannot be fixed using an update or patch, then the product's owner will not be able to protect against the issue. The only option might be replacement of the product, which could be too financially or operationally expensive for the product owner. As a result, the inability to patch or update can leave the product open to attacker exploitation or critical operation failures. This weakness can be especially difficult to manage when using ROM, firmware, or similar components that traditionally have had limited or no update capabilities. \n\n\n In industries such as healthcare, \"legacy\" devices can be operated for decades. As a US task force report [REF-1197] notes, \"the inability to update or replace equipment has both large and small health care delivery organizations struggle with numerous unsupported legacy systems that cannot easily be replaced (hardware, software, and operating systems) with large numbers of vulnerabilities and few modern countermeasures.\" \n\n\n While hardware can be prone to this weakness, software systems can also be affected, such as when a third-party driver or library is no longer actively maintained or supported but is still critical for the required functionality.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1357", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "664", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Requirements", "Note": "Requirements development might not consider the importance of updates over the lifetime of the product or might intentionally exclude this capability due to concerns such as expense or speed to market."}, {"Phase": "Architecture and Design", "Note": "Lack of planning during architecture development and design, or external pressures such as speed to market, could ignore the capability to update."}, {"Phase": "Architecture and Design", "Note": "Designers might omit capabilities for updating a component due to time pressures to release the product or assumptions about the stability of the component."}, {"Phase": "Implementation", "Note": "The weakness can appear through oversight during implementation."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control", "Authentication", "Authorization", "Other"], "Impact": ["Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Execute Unauthorized Code or Commands", "DoS: Crash, Exit, or Restart", "Quality Degradation", "Reduce Maintainability"], "Note": "If an attacker can identify an exploitable vulnerability in one product that has no means of patching, the attack may be used against all affected versions of that product."}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "Check the consumer or maintainer documentation, the architecture/design documentation, or the original requirements to ensure that the documentation includes details for how to update the firmware.", "Effectiveness": "Moderate"}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Specify requirements that each component should be updateable, including ROM, firmware, etc."}, {"Phase": ["Architecture and Design"], "Description": "Design the product to allow for updating of its components. Include the external infrastructure that might be necessary to support updates, such as distribution servers."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "With hardware, support patches that can be programmed in-field or during manufacturing through hardware fuses. This feature can be used for limited patching of devices after shipping, or for the next batch of silicon devices manufactured, without changing the full device ROM.", "Effectiveness": "Moderate", "EffectivenessNotes": "Some parts of the hardware initialization or signature verification done to authenticate patches will always be \"not patchable.\" Hardware-fuse-based patches will also have limitations in terms of size and the number of patches that can be supported."}, {"Phase": ["Implementation"], "Description": "Implement the necessary functionality to allow each component to be updated."}], "DemonstrativeExamples": [{"ID": "DX-145", "Entries": [{"IntroText": "A refrigerator has an Internet interface for the official purpose of alerting the manufacturer when that refrigerator detects a fault. Because the device is attached to the Internet, the refrigerator is a target for hackers who may wish to use the device other potentially more nefarious purposes."}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "The refrigerator has no means of patching and is hacked becoming a spewer of email spam."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "The device automatically patches itself and provides considerable more protection against being hacked."}]}, {"ID": "DX-146", "Entries": [{"IntroText": "A System-on-Chip (SOC) implements a Root-of-Trust (RoT) in ROM to boot secure code. However, at times this ROM code might have security vulnerabilities and need to be patched. Since ROM is immutable, it can be impossible to patch."}, {"BodyText": "ROM does not have built-in application-programming interfaces (APIs) to patch if the code is vulnerable. Implement mechanisms to patch the vulnerable ROM code."}]}, {"Entries": [{"IntroText": "The example code is taken from the JTAG module of the buggy OpenPiton SoC of HACK@DAC'21. JTAG is protected with a password checker. Access to JTAG operations will be denied unless the correct password is provided by the user. This user-provided password is first sent to the HMAC module where it is hashed with a secret crypto key. This user password hash (pass_hash) is then compared with the hash of the correct password (exp_hash). If they match, JTAG will then be unlocked."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "module dmi_jtag(...)(...);\n ...\n\n```\n\t\t\t PassChkValid: begin\n\t\t\t if(hashValid) begin\n\t\t\t\t\t if(exp_hash == pass_hash) begin\n\t\t\t\t\t\t pass_check = 1'b1;\n\t\t\t\t\t end else begin\n\t\t\t\t\t\t pass_check = 1'b0;\n\t\t\t\t\t end\n\t\t\t\t\t state_d = Idle;\n\t\t\t\t end else begin\n\t\t\t\t state_d = PassChkValid;\n\t\t\t\t end\n\t\t\t end\n ...\n\t hmac hmac(\n ...\n```\n.key_i(256'h24e6fa2254c2ff632a41b...),** \n\t\t ...\n\n```\n\t );\n ...\n endmodule\n```"}, {"BodyText": "However, the SoC's crypto key is hardcoded into the design and cannot be updated [REF-1387]. Therefore, if the key is leaked somehow, there is no way to reprovision the key without having the device replaced."}, {"BodyText": "To fix this issue, a local register should be used (hmac_key_reg) to store the crypto key. If designers need to update the key, they can upload the new key through an input port (hmac_key_i) to the local register by enabling the patching signal (hmac_patch_en) [REF-1388]."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "module dmi_jtag(...\n ) (\n\n```\n```\ninput logic [255:0] hmac_key_i,** \n\t\n\t **input logic hmac_patch_en,** \n\t ... \n\t\n\t **reg [255:0] hmac_key_reg;** \n\t ...\n\t );\n ...\n\n```\n\t always_ff @(posedge tck_i or negedge trst_ni) begin\n\t ...\n```\nif (hmac_patch_en)** \n\t\n\t```\n```\nhmac_key_reg <= hmac_key_i;** \n\t\t ...\n\t end\n\t ...\n\n```\n\t hmac hmac(\n\t ...\n```\n.key_i(hmac_key_reg),** \n\t ...\n\t );\n\t ...\n endmodule"}]}], "ObservedExamples": [{"Reference": "CVE-2020-9054", "Description": "Chain: network-attached storage (NAS) device has a critical OS command injection (CWE-78) vulnerability that is actively exploited to place IoT devices into a botnet, but some products are \"end-of-support\" and cannot be patched (CWE-1277). [REF-1097]", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-9054"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1330", "Name": "Remanent Data Readable after Memory Erase", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Confidential information stored in memory circuits is readable or recoverable after being cleared or erased.", "ExtendedDescription": "\n\nData remanence occurs when stored, memory content is not fully lost after a memory-clear or -erase operation. Confidential memory contents can still be readable through data remanence in the hardware.\n\n\nData remanence can occur because of performance optimization or memory organization during 'clear' or 'erase' operations, like a design that allows the memory-organization metadata (e.g., file pointers) to be erased without erasing the actual memory content. To protect against this weakness, memory devices will often support different commands for optimized memory erase and explicit secure erase.\n\n\nData remanence can also happen because of the physical properties of memory circuits in use. For example, static, random-access-memory (SRAM) and dynamic, random-access-memory (DRAM) data retention is based on the charge retained in the memory cell, which depends on factors such as power supply, refresh rates, and temperature.\n\n\nOther than explicit erase commands, self-encrypting, secure-memory devices can also support secure erase through cryptographic erase commands. In such designs, only the decryption keys for encrypted data stored on the device are erased. That is, the stored data are always remnant in the media after a cryptographic erase. However, only the encrypted data can be extracted. Thus, protection against data recovery in such designs relies on the strength of the encryption algorithm.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1301", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1301", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Security Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Modify Memory", "Read Memory"], "Note": "Confidential data are readable to untrusted agent."}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "\n\n  - Testing of memory-device contents after clearing or erase commands.\n\n  - Dynamic analysis of memory contents during device operation to detect specific, confidential assets.\n\n  - Architecture and design analysis of memory clear and erase operations.\n\n"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\n  - Testing of memory-device contents after clearing or erase commands.\n\n  - Dynamic analysis of memory contents during device operation to detect specific, confidential assets.\n\n  - Architecture and design analysis of memory clear and erase operations.\n\n"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\n  - Support for secure-erase commands that apply multiple cycles of overwriting memory with known patterns and of erasing actual content.\n\n  - Support for cryptographic erase in self-encrypting, memory devices.\n\n  - External, physical tools to erase memory such as ultraviolet-rays-based erase of Electrically erasable, programmable, read-only memory (EEPROM).\n\n  - Physical destruction of media device. This is done for repurposed or scrapped devices that are no longer in use.\n\n"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a device that uses flash memory for non-volatile-data storage. To optimize flash-access performance or reliable-flash lifetime, the device might limit the number of flash writes/erases by maintaining some state in internal SRAM and only committing changes to flash memory periodically."}, {"BodyText": "The device also supports user reset to factory defaults with the expectation that all personal information is erased from the device after this operation. On factory reset, user files are erased using explicit, erase commands supported by the flash device."}, {"BodyText": "In the given, system design, the flash-file system can support performance-optimized erase such that only the file metadata are erased and not the content. If this optimized erase is used for files containing user data during factory-reset flow, then device, flash memory can contain remanent data from these files."}, {"BodyText": "On device-factory reset, the implementation might not erase these copies, since the file organization has changed and the flash file system does not have the metadata to track all previous copies."}, {"BodyText": "A flash-memory region that is used by a flash-file system should be fully erased as part of the factory-reset flow. This should include secure-erase flow for the flash media such as overwriting patterns multiple times followed by erase."}]}], "ObservedExamples": [{"Reference": "CVE-2019-8575", "Description": "Firmware Data Deletion Vulnerability in which a base station factory reset might not delete all user information. The impact of this enables a new owner of a used device that has been \"factory-default reset\" with a vulnerable firmware version can still retrieve, at least, the previous owner's wireless network name, and the previous owner's wireless security (such as WPA2) key. This issue was addressed with improved, data deletion.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-8575"}], "RelatedAttackPatterns": ["150", "37", "545"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1331", "Name": "Improper Isolation of Shared Resources in Network On Chip (NoC)", "Abstraction": "Base", "Structure": "Simple", "Status": "Stable", "Description": "The Network On Chip (NoC) does not isolate or incorrectly isolates its on-chip-fabric and internal resources such that they are shared between trusted and untrusted agents, creating timing channels.", "ExtendedDescription": "\n\nTypically, network on chips (NoC) have many internal resources that are shared between packets from different trust domains. These resources include internal buffers, crossbars and switches, individual ports, and channels. The sharing of resources causes contention and introduces interference between differently trusted domains, which poses a security threat via a timing channel, allowing attackers to infer data that belongs to a trusted agent. This may also result in introducing network interference, resulting in degraded throughput and latency.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "653", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "668", "ViewID": "1000"}, {"Nature": "PeerOf", "CweID": "1189", "ViewID": "1194"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Security Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "BackgroundDetails": ["\n\n\"Network-on-chip\" (NoC) is a commonly-used term used for hardware interconnect fabrics used by multicore Systems-on-Chip (SoC). Communication between modules on the chip uses packet-based methods, with improved efficiency and scalability compared to bus architectures [REF-1241].\n"], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Availability"], "Impact": ["DoS: Resource Consumption (Other)", "Varies by Context", "Other"], "Likelihood": ["Medium"], "Note": "Attackers may infer data that belongs to a trusted agent. The methods used to perform this attack may result in noticeably increased resource consumption."}], "DetectionMethods": [{"Method": "Manual Analysis", "Description": "Providing marker flags to send through the interfaces coupled with examination of which users are able to read or manipulate the flags will help verify that the proper isolation has been achieved and is effective.", "Effectiveness": "Moderate"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "Implement priority-based arbitration inside the NoC and have dedicated buffers or virtual channels for routing secret data from trusted agents."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Consider a NoC that implements a one-dimensional mesh network with four nodes. This supports two flows: Flow A from node 0 to node 3 (via node 1 and node 2) and Flow B from node 1 to node 2. Flows A and B share a common link between Node 1 and Node 2. Only one flow can use the link in each cycle."}, {"BodyText": "One of the masters to this NoC implements a cryptographic algorithm (RSA), and another master to the NoC is a core that can be exercised by an attacker. The RSA algorithm performs a modulo multiplication of two large numbers and depends on each bit of the secret key. The algorithm examines each bit in the secret key and only performs multiplication if the bit is 1. This algorithm is known to be prone to timing attacks. Whenever RSA performs multiplication, there is additional network traffic to the memory controller. One of the reasons for this is cache conflicts."}, {"BodyText": "Since this is a one-dimensional mesh, only one flow can use the link in each cycle. Also, packets from the attack program and the RSA program share the output port of the network-on-chip. This contention results in network interference, and the throughput and latency of one flow can be affected by the other flow's demand."}, {"Nature": "Attack", "ExampleCode": "The attacker runs a loop program on the core they control, and this causes a cache miss in every iteration for the RSA algorithm. Thus, by observing network-traffic bandwidth and timing, the attack program can determine when the RSA algorithm is doing a multiply operation (i.e., when the secret key bit is 1) and eventually extract the entire, secret key."}, {"BodyText": "There may be different ways to fix this particular weakness."}, {"Nature": "Good", "Language": "Other", "ExampleCode": "Implement priority-based arbitration inside the NoC and have dedicated buffers or virtual channels for routing secret data from trusted agents."}]}], "ObservedExamples": [{"Reference": "CVE-2021-33096", "Description": "Improper isolation of shared resource in a network-on-chip leads to denial of service", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33096"}], "RelatedAttackPatterns": ["124"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1332", "Name": "Improper Handling of Faults that Lead to Instruction Skips", "Abstraction": "Base", "Structure": "Simple", "Status": "Stable", "Description": "The device is missing or incorrectly implements circuitry or sensors that detect and mitigate the skipping of security-critical CPU instructions when they occur.", "ExtendedDescription": "\n\nThe operating conditions of hardware may change in ways that cause unexpected behavior to occur, including the skipping of security-critical CPU instructions. Generally, this can occur due to electrical disturbances or when the device operates outside of its expected conditions.\n\n\nIn practice, application code may contain conditional branches that are security-sensitive (e.g., accepting or rejecting a user-provided password). These conditional branches are typically implemented by a single conditional branch instruction in the program binary which, if skipped, may lead to effectively flipping the branch condition - i.e., causing the wrong security-sensitive branch to be taken. This affects processes such as firmware authentication, password verification, and other security-sensitive decision points.\n\n\nAttackers can use fault injection techniques to alter the operating conditions of hardware so that security-critical instructions are skipped more frequently or more reliably than they would in a \"natural\" setting.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1384", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "1247", "ViewID": "1194", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Failure to design appropriate countermeasures to common fault injection techniques can manifest this weakness."}, {"Phase": "Implementation", "Note": "This weakness can arise if the hardware design incorrectly implements countermeasures to prevent fault injection."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Authentication"], "Impact": ["Bypass Protection Mechanism", "Alter Execution Logic", "Unexpected State"], "Likelihood": ["High"], "Note": "Depending on the context, instruction skipping can have a broad range of consequences related to the generic bypassing of security critical code."}], "DetectionMethods": [{"Method": "Automated Static Analysis", "Description": "This weakness can be found using automated static analysis once a developer has indicated which code paths are critical to protect.", "Effectiveness": "Moderate"}, {"Method": "Simulation / Emulation", "Description": "This weakness can be found using automated dynamic analysis. Both emulation of a CPU with instruction skips, as well as RTL simulation of a CPU IP, can indicate parts of the code that are sensitive to faults due to instruction skips.", "Effectiveness": "Moderate"}, {"Method": "Manual Analysis", "Description": "This weakness can be found using manual (static) analysis. The analyst has security objectives that are matched against the high-level code. This method is less precise than emulation, especially if the analysis is done at the higher level language rather than at assembly level.", "Effectiveness": "Moderate"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Design strategies for ensuring safe failure if inputs, such as Vcc, are modified out of acceptable ranges."}, {"Phase": ["Architecture and Design"], "Description": "Design strategies for ensuring safe behavior if instructions attempt to be skipped."}, {"Phase": ["Architecture and Design"], "Description": "Identify mission critical secrets that should be wiped if faulting is detected, and design a mechanism to do the deletion."}, {"Phase": ["Implementation"], "Description": "Add redundancy by performing an operation multiple times, either in space or time, and perform majority voting. Additionally, make conditional instruction timing unpredictable."}, {"Phase": ["Implementation"], "Description": "Use redundant operations or canaries to detect and respond to faults."}, {"Phase": ["Implementation"], "Description": "Ensure that fault mitigations are strong enough in practice. For example, a low power detection mechanism that takes 50 clock cycles to trigger at lower voltages may be an insufficient security mechanism if the instruction counter has already progressed with no other CPU activity occurring."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A smart card contains authentication credentials that are used as authorization to enter a building. The credentials are only accessible when a correct PIN is presented to the card."}, {"Nature": "Bad", "ExampleCode": "The card emits the credentials when a voltage anomaly is injected into the power line to the device at a particular time after providing an incorrect PIN to the card, causing the internal program to accept the incorrect PIN."}, {"BodyText": "There are several ways this weakness could be fixed."}, {"Nature": "Good", "ExampleCode": "- add an internal filter or internal power supply in series with the power supply pin on the device\n\n  - add sensing circuitry to reset the device if out of tolerance conditions are detected\n\n  - add additional execution sensing circuits to monitor the execution order for anomalies and abort the action or reset the device under fault conditions"}]}], "ObservedExamples": [{"Reference": "CVE-2019-15894", "Description": "fault injection attack bypasses the verification mode, potentially allowing arbitrary code execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-15894"}], "FunctionalAreas": ["Power"], "RelatedAttackPatterns": ["624", "625"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1333", "Name": "Inefficient Regular Expression Complexity", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.", "ExtendedDescription": "Some regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. ", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "407", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "407", "ViewID": "1003", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "ReDoS", "Description": "ReDoS is an abbreviation of \"Regular expression Denial of Service\"."}, {"Term": "Regular Expression Denial of Service", "Description": "While this term is attack-focused, this is commonly used to describe the weakness."}, {"Term": "Catastrophic backtracking", "Description": "This term is used to describe the behavior of the regular expression as a negative technical impact."}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "A RegEx can be easy to create and read using unbounded matching characters, but the programmer might not consider the risk of excessive backtracking."}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Resource Consumption (CPU)"], "Likelihood": ["High"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Use regular expressions that do not support backtracking, e.g. by removing nested quantifiers.", "Effectiveness": "High", "EffectivenessNotes": "This is one of the few effective solutions when using user-provided regular expressions."}, {"Phase": ["System Configuration"], "Description": "Set backtracking limits in the configuration of the regular expression implementation, such as PHP's pcre.backtrack_limit. Also consider limits on execution time for the process.", "Effectiveness": "Moderate"}, {"Phase": ["Implementation"], "Description": "Do not use regular expressions with untrusted input. If regular expressions must be used, avoid using backtracking in the expression.", "Effectiveness": "High"}, {"Phase": ["Implementation"], "Description": "Limit the length of the input that the regular expression will process.", "Effectiveness": "Moderate"}], "DemonstrativeExamples": [{"ID": "DX-158", "Entries": [{"IntroText": "This example attempts to check if an input string is a \"sentence\" [REF-1164]."}, {"Nature": "Bad", "Language": "JavaScript", "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var bad_pattern = /^(\\w+\\s?)*$/i;\n var result = test_string.search(bad_pattern);"}, {"BodyText": "The regular expression has a vulnerable backtracking clause inside (\\w+\\s?)*$ which can be triggered to cause a Denial of Service by processing particular phrases.\n\n\nTo fix the backtracking problem, backtracking is removed with the ?= portion of the expression which changes it to a lookahead and the \\2 which prevents the backtracking. The modified example is:"}, {"Nature": "Good", "Language": "JavaScript", "ExampleCode": "var test_string = \"Bad characters: $@#\";\n var good_pattern = /^((?=(\\w+))\\2\\s?)*$/i;\n var result = test_string.search(good_pattern);"}, {"BodyText": "Note that [REF-1164] has a more thorough (and lengthy) explanation of everything going on within the RegEx."}]}, {"Entries": [{"IntroText": "This example attempts to check if an input string is a \"sentence\" and is modified for Perl [REF-1164]."}, {"Nature": "Bad", "Language": "Perl", "ExampleCode": "my $test_string = \"Bad characters: \\$\\@\\#\";\n my $bdrslt = $test_string;\n $bdrslt =~ /^(\\w+\\s?)*$/i;"}, {"BodyText": "The regular expression has a vulnerable backtracking clause inside (\\w+\\s?)*$ which can be triggered to cause a Denial of Service by processing particular phrases.\n\n\nTo fix the backtracking problem, backtracking is removed with the ?= portion of the expression which changes it to a lookahead and the \\2 which prevents the backtracking. The modified example is:"}, {"Nature": "Good", "Language": "Perl", "ExampleCode": "my $test_string = \"Bad characters: \\$\\@\\#\";\n my $gdrslt = $test_string;\n $gdrslt =~ /^((?=(\\w+))\\2\\s?)*$/i;"}, {"BodyText": "Note that [REF-1164] has a more thorough (and lengthy) explanation of everything going on within the RegEx."}]}], "ObservedExamples": [{"Reference": "CVE-2020-5243", "Description": "server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5243"}, {"Reference": "CVE-2021-21317", "Description": "npm package for user-agent parser prone to ReDoS due to overlapping capture groups", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21317"}, {"Reference": "CVE-2019-16215", "Description": "Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-16215"}, {"Reference": "CVE-2019-6785", "Description": "Long string in a version control product allows DoS due to an inefficient regex.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-6785"}, {"Reference": "CVE-2019-12041", "Description": "Javascript code allows ReDoS via a long string due to excessive backtracking.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-12041"}, {"Reference": "CVE-2015-8315", "Description": "ReDoS when parsing time.", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-8315"}, {"Reference": "CVE-2015-8854", "Description": "ReDoS when parsing documents.", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-8854"}, {"Reference": "CVE-2017-16021", "Description": "ReDoS when validating URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-16021"}], "RelatedAttackPatterns": ["492"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-23354", "Description": "The package printf before 0.6.1 are vulnerable to Regular Expression Denial of Service (ReDoS) via the regex string /\\\\%(?:\\\\(([\\\\w_.]+)\\\\)|([1-9]\\\\d*)\\\\$)?([0 +\\\\-\\\\]*)(\\\\*|\\\\d+)?(\\\\.)?(\\\\*|\\\\d+)?[hlL]?([\\\\%bscdeEfFgGioOuxX])/g in lib/printf.js. The vulnerable regular expression has cubic worst-case time complexity."}, {"Reference": "CVE-2021-23362", "Description": "The package hosted-git-info before 3.0.8 are vulnerable to Regular Expression Denial of Service (ReDoS) via regular expression shortcutMatch in the fromUrl function in index.js. The affected regular expression exhibits polynomial worst-case time complexity."}, {"Reference": "CVE-2021-23364", "Description": "The package browserslist from 4.0.0 and before 4.16.5 are vulnerable to Regular Expression Denial of Service (ReDoS) during parsing of queries."}, {"Reference": "CVE-2021-23382", "Description": "The package postcss before 8.2.13 are vulnerable to Regular Expression Denial of Service (ReDoS) via getAnnotationURL() and loadAnnotation() in lib/previous-map.js. The vulnerable regexes are caused mainly by the sub-pattern \\\\/\\\\*\\\\s* sourceMappingURL=(.*)."}, {"Reference": "CVE-2021-23446", "Description": "The package handsontable before 10.0.0; the package handsontable from 0 and before 10.0.0 are vulnerable to Regular Expression Denial of Service (ReDoS) in Handsontable.helper.isNumeric function."}, {"Reference": "CVE-2021-23490", "Description": "The package parse-link-header before 2.0.0 are vulnerable to Regular Expression Denial of Service (ReDoS) via the checkHeader function."}, {"Reference": "CVE-2021-25292", "Description": "An issue was discovered in Pillow before 8.1.1. The PDF parser allows a regular expression DoS (ReDoS) attack via a crafted PDF file because of a catastrophic backtracking regex."}, {"Reference": "CVE-2021-26813", "Description": "markdown2 >=1.0.1.18, fixed in 2.4.0, is affected by a regular expression denial of service vulnerability. If an attacker provides a malicious string, it can make markdown2 processing difficult or delayed for an extended period of time."}, {"Reference": "CVE-2021-27291", "Description": "In pygments 1.1+, fixed in 2.7.4, the lexers used to parse programming languages rely heavily on regular expressions. Some of the regular expressions have exponential or cubic worst-case complexity and are vulnerable to ReDoS. By crafting malicious input, an attacker can cause a denial of service."}, {"Reference": "CVE-2021-28092", "Description": "The is-svg package 2.1.0 through 4.2.1 for Node.js uses a regular expression that is vulnerable to Regular Expression Denial of Service (ReDoS). If an attacker provides a malicious string, is-svg will get stuck processing the input for a very long time."}, {"Reference": "CVE-2021-33502", "Description": "The normalize-url package before 4.5.1, 5.x before 5.3.1, and 6.x before 6.0.1 for Node.js has a ReDoS (regular expression denial of service) issue because it has exponential performance for data: URLs."}, {"Reference": "CVE-2021-3765", "Description": "validator.js is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-3795", "Description": "semver-regex is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-3803", "Description": "nth-check is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-3804", "Description": "taro is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-3807", "Description": "ansi-regex is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-3810", "Description": "code-server is vulnerable to Inefficient Regular Expression Complexity"}, {"Reference": "CVE-2021-39933", "Description": "An issue has been discovered in GitLab CE/EE affecting all versions starting from 12.10 before 14.3.6, all versions starting from 14.4 before 14.4.4, all versions starting from 14.5 before 14.5.2. A regular expression used for handling user input (notes, comments, etc) was susceptible to catastrophic backtracking that could cause a DOS attack."}, {"Reference": "CVE-2021-39940", "Description": "An issue has been discovered in GitLab CE/EE affecting all versions starting from 13.2 before 14.3.6, all versions starting from 14.4 before 14.4.4, all versions starting from 14.5 before 14.5.2. GitLab Maven Package registry is vulnerable to a regular expression denial of service when a specifically crafted string is sent."}, {"Reference": "CVE-2021-40660", "Description": "An issue was discovered in Delight Nashorn Sandbox 0.2.0. There is an ReDoS vulnerability that can be exploited to launching a denial of service (DoS) attack."}, {"Reference": "CVE-2021-40892", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in validate-color v2.1.0 when handling crafted invalid rgb(a) strings."}, {"Reference": "CVE-2021-40893", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in validate-data v0.1.1 when validating crafted invalid emails."}, {"Reference": "CVE-2021-40894", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in underscore-99xp v1.7.2 when the deepValueSearch function is called."}, {"Reference": "CVE-2021-40895", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in todo-regex v0.1.1 when matching crafted invalid TODO statements."}, {"Reference": "CVE-2021-40896", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in that-value v0.1.3 when validating crafted invalid emails."}, {"Reference": "CVE-2021-40897", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in split-html-to-chars v1.0.5 when splitting crafted invalid htmls."}, {"Reference": "CVE-2021-40898", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in scaffold-helper v1.2.0 when copying crafted invalid files."}, {"Reference": "CVE-2021-40899", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in repo-git-downloader v0.1.1 when downloading crafted invalid git repositories."}, {"Reference": "CVE-2021-40900", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in regexfn v1.0.5 when validating crafted invalid emails."}, {"Reference": "CVE-2021-40901", "Description": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in scniro-validator v1.0.1 when validating crafted invalid emails."}, {"Reference": "CVE-2021-41115", "Description": "Zulip is an open source team chat server. In affected versions Zulip allows organization administrators on a server to configure \"linkifiers\" that automatically create links from messages that users send, detected via arbitrary regular expressions. Malicious organization administrators could subject the server to a denial-of-service via regular expression complexity attacks; most simply, by configuring a quadratic-time regular expression in a linkifier, and sending messages that exploited it. A regular expression attempted to parse the user-provided regexes to verify that they were safe from ReDoS -- this was both insufficient, as well as _itself_ subject to ReDoS if the organization administrator entered a sufficiently complex invalid regex. Affected users should [upgrade to the just-released Zulip 4.7](https://zulip.readthedocs.io/en/latest/production/upgrade-or-modify.html#upgrading-to-a-release), or [`main`](https://zulip.readthedocs.io/en/latest/production/upgrade-or-modify.html#upgrading-from-a-git-repository)."}, {"Reference": "CVE-2021-41817", "Description": "Date.parse in the date gem through 3.2.0 for Ruby allows ReDoS (regular expression Denial of Service) via a long string. The fixed versions are 3.2.1, 3.1.2, 3.0.2, and 2.0.1."}, {"Reference": "CVE-2021-42248", "Description": "GJSON <= 1.9.2 allows attackers to cause a redos via crafted JSON input."}, {"Reference": "CVE-2021-43306", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the jquery-validation npm package, when an attacker is able to supply arbitrary input to the url2 method"}, {"Reference": "CVE-2021-43307", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the semver-regex npm package, when an attacker is able to supply arbitrary input to the test() method"}, {"Reference": "CVE-2021-43308", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the markdown-link-extractor npm package, when an attacker is able to supply arbitrary input to the module's exported function"}, {"Reference": "CVE-2021-43309", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the uri-template-lite npm package, when an attacker is able to supply arbitrary input to the \"URI.expand\" method"}, {"Reference": "CVE-2021-43838", "Description": "jsx-slack is a library for building JSON objects for Slack Block Kit surfaces from JSX. In versions prior to 4.5.1 users are vulnerable to a regular expression denial-of-service (ReDoS) attack. If attacker can put a lot of JSX elements into `<blockquote>` tag, an internal regular expression for escaping characters may consume an excessive amount of computing resources. jsx-slack v4.5.1 has patched to a regex for escaping blockquote characters. Users are advised to upgrade as soon as possible."}, {"Reference": "CVE-2021-45470", "Description": "lib/DatabaseLayer.py in cve-search before 4.1.0 allows regular expression injection, which can lead to ReDoS (regular expression denial of service) or other impacts."}, {"Reference": "CVE-2021-46823", "Description": "python-ldap before 3.4.0 is vulnerable to a denial of service when ldap.schema is used for untrusted schema definitions, because of a regular expression denial of service (ReDoS) flaw in the LDAP schema parser. By sending crafted regex input, a remote authenticated attacker could exploit this vulnerability to cause a denial of service condition."}, {"Reference": "CVE-2022-1929", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the devcert npm package, when an attacker is able to supply arbitrary input to the certificateFor method"}, {"Reference": "CVE-2022-1930", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the eth-account PyPI package, when an attacker is able to supply arbitrary input to the encode_structured_data method"}, {"Reference": "CVE-2022-1954", "Description": "A Regular Expression Denial of Service vulnerability in GitLab CE/EE affecting all versions from 1.0.2 prior to 14.10.5, 15.0 prior to 15.0.4, and 15.1 prior to 15.1.1 allows an attacker to make a GitLab instance inaccessible via specially crafted web server response headers"}, {"Reference": "CVE-2022-21195", "Description": "All versions of package url-regex are vulnerable to Regular Expression Denial of Service (ReDoS) which can cause the CPU usage to crash."}, {"Reference": "CVE-2022-21222", "Description": "The package css-what before 2.1.3 are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of insecure regular expression in the re_attr variable of index.js. The exploitation of this vulnerability could be triggered via the parse function."}, {"Reference": "CVE-2022-21681", "Description": "Marked is a markdown parser and compiler. Prior to version 4.0.10, the regular expression `inline.reflinkSearch` may cause catastrophic backtracking against some strings and lead to a denial of service (DoS). Anyone who runs untrusted markdown through a vulnerable version of marked and does not use a worker with a time limit may be affected. This issue is patched in version 4.0.10. As a workaround, avoid running untrusted markdown through marked or run marked on a worker thread and set a reasonable time limit to prevent draining resources."}, {"Reference": "CVE-2022-24373", "Description": "The package react-native-reanimated before 3.0.0-rc.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper usage of regular expression in the parser of Colors.js."}, {"Reference": "CVE-2022-24713", "Description": "regex is an implementation of regular expressions for the Rust language. The regex crate features built-in mitigations to prevent denial of service attacks caused by untrusted regexes, or untrusted input matched by trusted regexes. Those (tunable) mitigations already provide sane defaults to prevent attacks. This guarantee is documented and it's considered part of the crate's API. Unfortunately a bug was discovered in the mitigations designed to prevent untrusted regexes to take an arbitrary amount of time during parsing, and it's possible to craft regexes that bypass such mitigations. This makes it possible to perform denial of service attacks by sending specially crafted regexes to services accepting user-controlled, untrusted regexes. All versions of the regex crate before or equal to 1.5.4 are affected by this issue. The fix is include starting from regex 1.5.5. All users accepting user-controlled regexes are recommended to upgrade immediately to the latest version of the regex crate. Unfortunately there is no fixed set of problematic regexes, as there are practically infinite regexes that could be crafted to exploit this vulnerability. Because of this, it us not recommend to deny known problematic regexes."}, {"Reference": "CVE-2022-25598", "Description": "Apache DolphinScheduler user registration is vulnerable to Regular express Denial of Service (ReDoS) attacks, Apache DolphinScheduler users should upgrade to version 2.0.5 or higher."}, {"Reference": "CVE-2022-25758", "Description": "All versions of package scss-tokenizer are vulnerable to Regular Expression Denial of Service (ReDoS) via the loadAnnotation() function, due to the usage of insecure regex."}, {"Reference": "CVE-2022-25844", "Description": "The package angular after 1.7.0 are vulnerable to Regular Expression Denial of Service (ReDoS) by providing a custom locale rule that makes it possible to assign the parameter in posPre: ' '.repeat() of NUMBER_FORMATS.PATTERNS[1].posPre with a very high value. **Note:** 1) This package has been deprecated and is no longer maintained. 2) The vulnerable versions are 1.7.0 and higher."}, {"Reference": "CVE-2022-25858", "Description": "The package terser before 4.8.1, from 5.0.0 and before 5.14.2 are vulnerable to Regular Expression Denial of Service (ReDoS) due to insecure usage of regular expressions."}, {"Reference": "CVE-2022-25887", "Description": "The package sanitize-html before 2.7.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to insecure global regular expression replacement logic of HTML comment removal."}, {"Reference": "CVE-2022-25918", "Description": "The package shescape from 1.5.10 and before 1.6.1 are vulnerable to Regular Expression Denial of Service (ReDoS) via the escape function in index.js, due to the usage of insecure regex in the escapeArgBash function."}, {"Reference": "CVE-2022-29158", "Description": "Apache OFBiz up to version 18.12.05 is vulnerable to Regular Expression Denial of Service (ReDoS) in the way it handles URLs provided by external, unauthenticated users. Upgrade to 18.12.06 or apply patches at https://issues.apache.org/jira/browse/OFBIZ-12599"}, {"Reference": "CVE-2022-29167", "Description": "Hawk is an HTTP authentication scheme providing mechanisms for making authenticated HTTP requests with partial cryptographic verification of the request and response, covering the HTTP method, request URI, host, and optionally the request payload. Hawk used a regular expression to parse `Host` HTTP header (`Hawk.utils.parseHost()`), which was subject to regular expression DoS attack - meaning each added character in the attacker's input increases the computation time exponentially. `parseHost()` was patched in `9.0.1` to use built-in `URL` class to parse hostname instead. `Hawk.authenticate()` accepts `options` argument. If that contains `host` and `port`, those would be used instead of a call to `utils.parseHost()`."}, {"Reference": "CVE-2022-29169", "Description": "BigBlueButton is an open source web conferencing system. Versions starting with 2.2 and prior to 2.3.19, 2.4.7, and 2.5.0-beta.2 are vulnerable to regular expression denial of service (ReDoS) attacks. By using specific a RegularExpression, an attacker can cause denial of service for the bbb-html5 service. The useragent library performs checking of device by parsing the input of User-Agent header and lets it go through lookupUserAgent() (alias of useragent.lookup() ). This function handles input by regexing and attackers can abuse that by providing some ReDos payload using `SmartWatch`. The maintainers removed `htmlclient/useragent` from versions 2.3.19, 2.4.7, and 2.5.0-beta.2. As a workaround, disable NginX forwarding the requests to the handler according to the directions in the GitHub Security Advisory."}, {"Reference": "CVE-2022-31129", "Description": "moment is a JavaScript date library for parsing, validating, manipulating, and formatting dates. Affected versions of moment were found to use an inefficient parsing algorithm. Specifically using string-to-date parsing in moment (more specifically rfc2822 parsing, which is tried by default) has quadratic (N^2) complexity on specific inputs. Users may notice a noticeable slowdown is observed with inputs above 10k characters. Users who pass user-provided strings without sanity length checks to moment constructor are vulnerable to (Re)DoS attacks. The problem is patched in 2.29.4, the patch can be applied to all affected versions with minimal tweaking. Users are advised to upgrade. Users unable to upgrade should consider limiting date lengths accepted from user input."}, {"Reference": "CVE-2022-31147", "Description": "The jQuery Validation Plugin (jquery-validation) provides drop-in validation for forms. Versions of jquery-validation prior to 1.19.5 are vulnerable to regular expression denial of service (ReDoS) when an attacker is able to supply arbitrary input to the url2 method. This is due to an incomplete fix for CVE-2021-43306. Users should upgrade to version 1.19.5 to receive a patch."}, {"Reference": "CVE-2022-31781", "Description": "Apache Tapestry up to version 5.8.1 is vulnerable to Regular Expression Denial of Service (ReDoS) in the way it handles Content Types. Specially crafted Content Types may cause catastrophic backtracking, taking exponential time to complete. Specifically, this is about the regular expression used on the parameter of the org.apache.tapestry5.http.ContentType class. Apache Tapestry 5.8.2 has a fix for this vulnerability. Notice the vulnerability cannot be triggered by web requests in Tapestry code alone. It would only happen if there's some non-Tapestry codepath passing some outside input to the ContentType class constructor."}, {"Reference": "CVE-2022-34402", "Description": "Dell Wyse ThinOS 2205 contains a Regular Expression Denial of Service Vulnerability in UI. An admin privilege attacker could potentially exploit this vulnerability, leading to denial-of-service."}, {"Reference": "CVE-2022-34428", "Description": "Dell Hybrid Client prior to version 1.8 contains a Regular Expression Denial of Service Vulnerability in the UI. An adversary with WMS group admin access could potentially exploit this vulnerability, leading to temporary denial-of-service."}, {"Reference": "CVE-2022-34749", "Description": "In mistune through 2.0.2, support of inline markup is implemented by using regular expressions that can involve a high amount of backtracking on certain edge cases. This behavior is commonly named catastrophic backtracking."}, {"Reference": "CVE-2022-3517", "Description": "A vulnerability was found in the minimatch package. This flaw allows a Regular Expression Denial of Service (ReDoS) when calling the braceExpand function with specific arguments, resulting in a Denial of Service."}, {"Reference": "CVE-2022-35923", "Description": "v8n is a javascript validation library. Versions of v8n prior to 1.5.1 were found to have an inefficient regular expression complexity in the `lowercase()` and `uppercase()` regex which could lead to a denial of service attack. In testing of the `lowercase()` function a payload of 'a' + 'a'.repeat(i) + 'A' with 32 leading characters took 29443 ms to execute. The same issue happens with uppercase(). Users are advised to upgrade. There are no known workarounds for this issue."}, {"Reference": "CVE-2022-36034", "Description": "nitrado.js is a type safe wrapper for the Nitrado API. Possible ReDoS with lib input of `{{` and with many repetitions of `{{|`. This issue has been patched in all versions above `0.2.5`. There are currently no known workarounds."}, {"Reference": "CVE-2022-37259", "Description": "A Regular Expression Denial of Service (ReDoS) flaw was found in stealjs steal 2.2.4 via the string variable in babel.js."}, {"Reference": "CVE-2022-37260", "Description": "A Regular Expression Denial of Service (ReDoS) flaw was found in stealjs steal 2.2.4 via the input variable in main.js."}, {"Reference": "CVE-2022-37262", "Description": "A Regular Expression Denial of Service (ReDoS) flaw was found in stealjs steal 2.2.4 via the source and sourceWithComments variable in main.js."}, {"Reference": "CVE-2022-37599", "Description": "A Regular expression denial of service (ReDoS) flaw was found in Function interpolateName in interpolateName.js in webpack loader-utils 2.0.0 via the resourcePath variable in interpolateName.js."}, {"Reference": "CVE-2022-37603", "Description": "A Regular expression denial of service (ReDoS) flaw was found in Function interpolateName in interpolateName.js in webpack loader-utils 2.0.0 via the url variable in interpolateName.js."}, {"Reference": "CVE-2022-37620", "Description": "A Regular Expression Denial of Service (ReDoS) flaw was found in kangax html-minifier 4.0.0 via the candidate variable in htmlminifier.js."}, {"Reference": "CVE-2022-39280", "Description": "dparse is a parser for Python dependency files. dparse in versions before 0.5.2 contain a regular expression that is vulnerable to a Regular Expression Denial of Service. All the users parsing index server URLs with dparse are impacted by this vulnerability. A patch has been applied in version `0.5.2`, all the users are advised to upgrade to `0.5.2` as soon as possible. Users unable to upgrade should avoid passing index server URLs in the source file to be parsed."}, {"Reference": "CVE-2022-40023", "Description": "Sqlalchemy mako before 1.2.2 is vulnerable to Regular expression Denial of Service when using the Lexer class to parse. This also affects babelplugin and linguaplugin."}, {"Reference": "CVE-2022-40897", "Description": "Python Packaging Authority (PyPA) setuptools before 65.5.1 allows remote attackers to cause a denial of service via HTML in a crafted package or custom PackageIndex page. There is a Regular Expression Denial of Service (ReDoS) in package_index.py."}, {"Reference": "CVE-2022-42124", "Description": "ReDoS vulnerability in LayoutPageTemplateEntryUpgradeProcess in Liferay Portal 7.3.2 through 7.4.3.4 and Liferay DXP 7.2 fix pack 9 through fix pack 18, 7.3 before update 4, and DXP 7.4 GA allows remote attackers to consume an excessive amount of server resources via a crafted payload injected into the 'name' field of a layout prototype."}, {"Reference": "CVE-2022-42964", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the pymatgen PyPI package, when an attacker is able to supply arbitrary input to the GaussianInput.from_string method"}, {"Reference": "CVE-2022-42965", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the snowflake-connector-python PyPI package, when an attacker is able to supply arbitrary input to the undocumented get_file_transfer_type method"}, {"Reference": "CVE-2022-42966", "Description": "An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the cleo PyPI package, when an attacker is able to supply arbitrary input to the Table.set_rows method"}, {"Reference": "CVE-2022-1510", "Description": "An issue has been discovered in GitLab affecting all versions starting from 13.9 before 14.8.6, all versions starting from 14.9 before 14.9.4, all versions starting from 14.10 before 14.10.1. GitLab was not correctly handling malicious text in the CI Editor and CI Pipeline details page allowing the attacker to cause uncontrolled resource consumption."}, {"Reference": "CVE-2022-26650", "Description": "In Apache ShenYui, ShenYu-Bootstrap, RegexPredicateJudge.java uses Pattern.matches(conditionData.getParamValue(), realData) to make judgments, where both parameters are controllable by the user. This can cause an attacker pass in malicious regular expressions and characters causing a resource exhaustion. This issue affects Apache ShenYu (incubating) 2.4.0, 2.4.1 and 2.4.2 and is fixed in 2.4.3."}, {"Reference": "CVE-2022-21670", "Description": "markdown-it is a Markdown parser. Prior to version 1.3.2, special patterns with length greater than 50 thousand characterss could slow down the parser significantly. Users should upgrade to version 12.3.2 to receive a patch. There are no known workarounds aside from upgrading."}, {"Reference": "CVE-2022-21680", "Description": "Marked is a markdown parser and compiler. Prior to version 4.0.10, the regular expression `block.def` may cause catastrophic backtracking against some strings and lead to a regular expression denial of service (ReDoS). Anyone who runs untrusted markdown through a vulnerable version of marked and does not use a worker with a time limit may be affected. This issue is patched in version 4.0.10. As a workaround, avoid running untrusted markdown through marked or run marked on a worker thread and set a reasonable time limit to prevent draining resources."}, {"Reference": "CVE-2022-24729", "Description": "CKEditor4 is an open source what-you-see-is-what-you-get HTML editor. CKEditor4 prior to version 4.18.0 contains a vulnerability in the `dialog` plugin. The vulnerability allows abuse of a dialog input validator regular expression, which can cause a significant performance drop resulting in a browser tab freeze. A patch is available in version 4.18.0. There are currently no known workarounds."}, {"Reference": "CVE-2022-24836", "Description": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri `< v1.13.4` contains an inefficient regular expression that is susceptible to excessive backtracking when attempting to detect encoding in HTML documents. Users are advised to upgrade to Nokogiri `>= 1.13.4`. There are no known workarounds for this issue."}, {"Reference": "CVE-2022-2596", "Description": "Inefficient Regular Expression Complexity in GitHub repository node-fetch/node-fetch prior to 3.2.10. "}, {"Reference": "CVE-2022-2908", "Description": "A potential DoS vulnerability was discovered in Gitlab CE/EE versions starting from 10.7 before 15.1.5, all versions starting from 15.2 before 15.2.3, all versions starting from 15.3 before 15.3.1 allowed an attacker to trigger high CPU usage via a special crafted input added in the Commit message field."}, {"Reference": "CVE-2022-30122", "Description": "A possible denial of service vulnerability exists in Rack <2.0.9.1, <2.1.4.1 and <2.2.3.1 in the multipart parsing component of Rack."}, {"Reference": "CVE-2022-31110", "Description": "RSSHub is an open source, extensible RSS feed generator. In commits prior to 5c4177441417 passing some special values to the `filter` and `filterout` parameters can cause an abnormally high CPU. This results in an impact on the performance of the servers and RSSHub services which may lead to a denial of service. This issue has been fixed in commit 5c4177441417 and all users are advised to upgrade. There are no known workarounds for this issue."}, {"Reference": "CVE-2022-36064", "Description": "Shescape is a shell escape package for JavaScript. An Inefficient Regular Expression Complexity vulnerability impacts users that use Shescape to escape arguments for the Unix shells `Bash` and `Dash`, or any not-officially-supported Unix shell; and/or using the `escape` or `escapeAll` functions with the `interpolation` option set to `true`. An attacker can cause polynomial backtracking or quadratic runtime in terms of the input string length due to two Regular Expressions in Shescape that are vulnerable to Regular Expression Denial of Service (ReDoS). This bug has been patched in v1.5.10. For `Dash` only, this bug has been patched since v1.5.9. As a workaround, a maximum length can be enforced on input strings to Shescape to reduce the impact of the vulnerability. It is not recommended to try and detect vulnerable input strings, as the logic for this may end up being vulnerable to ReDoS itself."}, {"Reference": "CVE-2022-44570", "Description": "A denial of service vulnerability in the Range header parsing component of Rack >= 1.5.0. A Carefully crafted input can cause the Range header parsing component in Rack to take an unexpected amount of time, possibly resulting in a denial of service attack vector. Any applications that deal with Range requests (such as streaming applications, or applications that serve files) may be impacted."}]}
{"ID": "1334", "Name": "Unauthorized Error Injection Can Degrade Hardware Redundancy", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "An unauthorized agent can inject errors into a redundant block to deprive the system of redundancy or put the system in a degraded operating mode.", "ExtendedDescription": "\n\nTo ensure the performance and functional reliability of certain components, hardware designers can implement hardware blocks for redundancy in the case that others fail. This redundant block can be prevented from performing as intended if the design allows unauthorized agents to inject errors into it. In this way, a path with injected errors may become unavailable to serve as a redundant channel. This may put the system into a degraded mode of operation which could be exploited by a subsequent attack.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "284", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases."}, {"Phase": "Implementation", "Note": "Such issues could be introduced during implementation and identified later during Testing or System Configuration phases."}, {"Phase": "Integration", "Note": "Such issues could be introduced during integration and identified later during Testing or System Configuration phases."}], "CommonConsequences": [{"Scope": ["Integrity", "Availability"], "Impact": ["DoS: Crash, Exit, or Restart", "DoS: Instability", "Quality Degradation", "DoS: Resource Consumption (CPU)", "DoS: Resource Consumption (Memory)", "DoS: Resource Consumption (Other)", "Reduce Performance", "Reduce Reliability", "Unexpected State"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Ensure the design does not allow error injection in modes intended for normal run-time operation. Provide access controls on interfaces for injecting errors."}, {"Phase": ["Implementation"], "Description": "Disallow error injection in modes which are expected to be used for normal run-time operation. Provide access controls on interfaces for injecting errors."}, {"Phase": ["Integration"], "Description": "Add an access control layer atop any unprotected interfaces for injecting errors."}], "RelatedAttackPatterns": ["624", "625"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1335", "Name": "Incorrect Bitwise Shift of Integer", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result.", "ExtendedDescription": "\n\nSpecifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue.\n\n\nSpecifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "682", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "JavaScript", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "Adding shifts without properly verifying the size and sign of the shift amount."}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["DoS: Crash, Exit, or Restart"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Implicitly or explicitly add checks and mitigation for negative or over-shift values."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A negative shift amount for an x86 or x86_64 shift instruction will produce the number of bits to be shifted by taking a 2's-complement of the shift amount and effectively masking that amount to the lowest 6 bits for a 64 bit shift instruction."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "unsigned int r = 1 << -5;"}, {"BodyText": "The example above ends up with a shift amount of -5. The hexadecimal value is FFFFFFFFFFFFFFFD which, when bits above the 6th bit are masked off, the shift amount becomes a binary shift value of 111101 which is 61 decimal. A shift of 61 produces a very different result than -5. The previous example is a very simple version of the following code which is probably more realistic of what happens in a real system."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "int choose_bit(int reg_bit, int bit_number_from_elsewhere) \n {\n\n```\n\t if (NEED_TO_SHIFT)\n\t {\n\t\t reg_bit -= bit_number_from_elsewhere;\n\t }\n\t return reg_bit;\n }\n unsigned int handle_io_register(unsigned int *r)\n {\n\t unsigned int the_bit = 1 << choose_bit(5, 10);\n\t *r |= the_bit;\n\t return the_bit;\n }\n```"}, {"Nature": "Good", "Language": "C", "ExampleCode": "int choose_bit(int reg_bit, int bit_number_from_elsewhere) \n {\n\n```\n\t if (NEED_TO_SHIFT)\n\t {\n\t\t reg_bit -= bit_number_from_elsewhere;\n\t }\n\t return reg_bit;\n }\n unsigned int handle_io_register(unsigned int *r)\n {\n\t int the_bit_number = choose_bit(5, 10);\n\t if ((the_bit_number > 0) && (the_bit_number < 63))\n\t {\n\t\t unsigned int the_bit = 1 << the_bit_number;\n\t\t *r |= the_bit;\n\t }\n\t return the_bit;\n }\n```"}, {"BodyText": "Note that the good example not only checks for negative shifts and disallows them, but it also checks for over-shifts. No bit operation is done if the shift is out of bounds. Depending on the program, perhaps an error message should be logged."}]}], "ObservedExamples": [{"Reference": "CVE-2009-4307", "Description": "An unexpected large value in the ext4 filesystem causes an overshift condition resulting in a divide by zero.", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4307"}, {"Reference": "CVE-2012-2100", "Description": "An unexpected large value in the ext4 filesystem causes an overshift condition resulting in a divide by zero - fix of CVE-2009-4307.", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-2100"}, {"Reference": "CVE-2020-8835", "Description": "An overshift in a kernel allowed out of bounds reads and writes resulting in a root takeover.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8835"}, {"Reference": "CVE-2015-1607", "Description": "Program is not properly handling signed bitwise left-shifts causing an overlapping memcpy memory range error.", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-1607"}, {"Reference": "CVE-2016-9842", "Description": "Compression function improperly executes a signed left shift of a negative integer.", "Link": "https://www.cve.org/CVERecord?id=CVE-2016-9842"}, {"Reference": "CVE-2018-18445", "Description": "Some kernels improperly handle right shifts of 32 bit numbers in a 64 bit register.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-18445"}, {"Reference": "CVE-2013-4206", "Description": "Putty has an incorrectly sized shift value resulting in an overshift.", "Link": "https://www.cve.org/CVERecord?id=CVE-2013-4206"}, {"Reference": "CVE-2018-20788", "Description": "LED driver overshifts under certain conditions resulting in a DoS.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-20788"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1336", "Name": "Improper Neutralization of Special Elements Used in a Template Engine", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.", "ExtendedDescription": "\n\nMany web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates.\n\n\nTemplate engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression \"{{7*7}}\" and determine if the output returns \"49\" instead. The syntax varies depending on the language.\n\n\nIn some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error.\n\n\nTemplate engines can be used on the server or client, so both \"sides\" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "94", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "PHP", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Python", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "JavaScript", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Interpreted", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "AI/ML", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Client Server", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "Server-Side Template Injection / SSTI", "Description": "This term is used for injection into template engines being used by a server."}, {"Term": "Client-Side Template Injection / CSTI", "Description": "This term is used for injection into template engines being used by a client."}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "The developer might choose a template engine that makes it easier for programmers to write vulnerable code."}, {"Phase": "Implementation", "Note": "The programmer might not use engine's built-in sandboxes or other capabilities to escape or otherwise prevent template injection from untrusted input."}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Choose a template engine that offers a sandbox or restricted mode, or at least limits the power of any available expressions, function calls, or commands."}, {"Phase": ["Implementation"], "Description": "Use the template engine's sandbox or restricted mode, if available."}], "ObservedExamples": [{"Reference": "CVE-2024-34359", "Description": "Chain: Python bindings for LLM library do not use a sandboxed environment when parsing a template and constructing a prompt, allowing jinja2 Server Side Template Injection and code execution - one variant of a \"prompt injection\" attack.", "Link": "https://www.cve.org/CVERecord?id=CVE-2024-34359"}, {"Reference": "CVE-2017-16783", "Description": "server-side template injection in content management server", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-16783"}, {"Reference": "CVE-2020-9437", "Description": "authentication / identity management product has client-side template injection", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-9437"}, {"Reference": "CVE-2020-12790", "Description": "Server-Side Template Injection using a Twig template", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-12790"}, {"Reference": "CVE-2021-21244", "Description": "devops platform allows SSTI", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-21244"}, {"Reference": "CVE-2020-4027", "Description": "bypass of Server-Side Template Injection protection mechanism with macros in Velocity templates", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-4027"}, {"Reference": "CVE-2020-26282", "Description": "web browser proxy server allows Java EL expressions from Server-Side Template Injection", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-26282"}, {"Reference": "CVE-2020-1961", "Description": "SSTI involving mail templates and JEXL expressions", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-1961"}, {"Reference": "CVE-2019-19999", "Description": "product does not use a \"safe\" setting for a FreeMarker configuration, allowing SSTI", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-19999"}, {"Reference": "CVE-2018-20465", "Description": "product allows read of sensitive database username/password variables using server-side template injection", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-20465"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "Since expression languages are often used in templating languages, there may be some overlap with CWE-917 (Expression Language Injection). XSS (CWE-79) is also co-located with template injection."}, {"Type": "Maintenance", "Note": "The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified."}], "Top25Examples": [{"Reference": "CVE-2021-41749", "Description": "In the SEOmatic plugin up to 3.4.11 for Craft CMS 3, it is possible for unauthenticated attackers to perform a Server-Side Template Injection, allowing for remote code execution."}, {"Reference": "CVE-2021-42651", "Description": "A Server Side Template Injection (SSTI) vulnerability in Pentest-Collaboration-Framework v1.0.8 allows an authenticated remote attacker to execute arbitrary code through /project/PROJECTNAME/reports/."}, {"Reference": "CVE-2022-22954", "Description": "VMware Workspace ONE Access and Identity Manager contain a remote code execution vulnerability due to server-side template injection. A malicious actor with network access can trigger a server-side template injection that may result in remote code execution."}, {"Reference": "CVE-2022-24881", "Description": "Ballcat Codegen provides the function of online editing code to generate templates. In versions prior to 1.0.0.beta.2, attackers can implement remote code execution through malicious code injection of the template engine. This happens because Velocity and freemarker templates are introduced but input verification is not done. The fault is rectified in version 1.0.0.beta.2."}, {"Reference": "CVE-2022-25813", "Description": "In Apache OFBiz, versions 18.12.05 and earlier, an attacker acting as an anonymous user of the ecommerce plugin, can insert a malicious content in a message \u201cSubject\u201d field from the \"Contact us\" page. Then a party manager needs to list the communications in the party component to activate the SSTI. A RCE is then possible."}, {"Reference": "CVE-2022-34625", "Description": "Mealie1.0.0beta3 was discovered to contain a Server-Side Template Injection vulnerability, which allows attackers to execute arbitrary code via a crafted Jinja2 template."}, {"Reference": "CVE-2022-39365", "Description": "Pimcore is an open source data and experience management platform. Prior to version 10.5.9, the user controlled twig templates rendering in `Pimcore/Mail` & `ClassDefinition\\\\Layout\\\\Text` is vulnerable to server-side template injection, which could lead to remote code execution. Version 10.5.9 contains a patch for this issue. As a workaround, one may apply the patch manually."}, {"Reference": "CVE-2022-47896", "Description": "In JetBrains IntelliJ IDEA before 2022.3.1 code Templates were vulnerable to SSTI attacks."}, {"Reference": "CVE-2021-26622", "Description": "An remote code execution vulnerability due to SSTI vulnerability and insufficient file name parameter validation was discovered in Genian NAC. Remote attackers are able to execute arbitrary malicious code with SYSTEM privileges on all connected nodes in NAC through this vulnerability."}, {"Reference": "CVE-2021-46362", "Description": "A Server-Side Template Injection (SSTI) vulnerability in the Registration and Forgotten Password forms of Magnolia v6.2.3 and below allows attackers to execute arbitrary code via a crafted payload entered into the fullname parameter."}, {"Reference": "CVE-2022-24442", "Description": "JetBrains YouTrack before 2021.4.40426 was vulnerable to SSTI (Server-Side Template Injection) via FreeMarker templates."}, {"Reference": "CVE-2022-29078", "Description": "The ejs (aka Embedded JavaScript templates) package 3.1.6 for Node.js allows server-side template injection in settings[view options][outputFunctionName]. This is parsed as an internal option, and overwrites the outputFunctionName option with an arbitrary OS command (which is executed upon template compilation)."}, {"Reference": "CVE-2022-35847", "Description": "An improper neutralization of special elements used in a template engine vulnerability [CWE-1336] in FortiSOAR management interface 7.2.0, 7.0.0 through 7.0.3, 6.4.0 through 6.4.4 may allow a remote and authenticated attacker to execute arbitrary code via a crafted payload."}, {"Reference": "CVE-2021-4315", "Description": "A vulnerability has been found in NYUCCL psiTurk up to 3.2.0 and classified as critical. This vulnerability affects unknown code of the file psiturk/experiment.py. The manipulation of the argument mode leads to improper neutralization of special elements used in a template engine. The exploit has been disclosed to the public and may be used. Upgrading to version 3.2.1 is able to address this issue. The name of the patch is 47787e15cecd66f2aa87687bf852ae0194a4335f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-219676."}, {"Reference": "CVE-2022-0323", "Description": "Improper Neutralization of Special Elements Used in a Template Engine in Packagist mustache/mustache prior to 2.14.1."}, {"Reference": "CVE-2022-0896", "Description": "Improper Neutralization of Special Elements Used in a Template Engine in GitHub repository microweber/microweber prior to 1.3."}, {"Reference": "CVE-2022-23810", "Description": "Template injection (Improper Neutralization of Special Elements Used in a Template Engine) vulnerability in a-blog cms Ver.2.8.x series versions prior to Ver.2.8.75, Ver.2.9.x series versions prior to Ver.2.9.40, Ver.2.10.x series versions prior to Ver.2.10.44, Ver.2.11.x series versions prior to Ver.2.11.42, and Ver.3.0.x series versions prior to Ver.3.0.1 allows a remote authenticated attacker to obtain an arbitrary file on the server via unspecified vectors."}, {"Reference": "CVE-2022-0944", "Description": "Template injection in connection test endpoint leads to RCE in GitHub repository sqlpad/sqlpad prior to 6.10.1."}, {"Reference": "CVE-2022-2073", "Description": "Code Injection in GitHub repository getgrav/grav prior to 1.7.34."}, {"Reference": "CVE-2022-21686", "Description": "PrestaShop is an Open Source e-commerce platform. Starting with version 1.7.0.0 and ending with version 1.7.8.3, an attacker is able to inject twig code inside the back office when using the legacy layout. The problem is fixed in version 1.7.8.3. There are no known workarounds."}, {"Reference": "CVE-2022-22909", "Description": "HotelDruid v3.0.3 was discovered to contain a remote code execution (RCE) vulnerability which is exploited via an attacker inserting a crafted payload into the name field under the Create New Room module."}, {"Reference": "CVE-2022-24780", "Description": "Combodo iTop is a web based IT Service Management tool. In versions prior to 2.7.6 and 3.0.0, users of the iTop user portal can send TWIG code to the server by forging specific http queries, and execute arbitrary code on the server using http server user privileges. This issue is fixed in versions 2.7.6 and 3.0.0. There are currently no known workarounds."}, {"Reference": "CVE-2022-29221", "Description": "Smarty is a template engine for PHP, facilitating the separation of presentation (HTML/CSS) from application logic. Prior to versions 3.1.45 and 4.1.1, template authors could inject php code by choosing a malicious {block} name or {include} file name. Sites that cannot fully trust template authors should upgrade to versions 3.1.45 or 4.1.1 to receive a patch for this issue. There are currently no known workarounds."}, {"Reference": "CVE-2022-35944", "Description": "October is a self-hosted Content Management System (CMS) platform based on the Laravel PHP Framework. This vulnerability only affects installations that rely on the safe mode restriction, commonly used when providing public access to the admin panel. Assuming an attacker has access to the admin panel and permission to open the \"Editor\" section, they can bypass the Safe Mode (`cms.safe_mode`) restriction to introduce new PHP code in a CMS template using a specially crafted request. The issue has been patched in versions 2.2.34 and 3.0.66."}, {"Reference": "CVE-2022-36799", "Description": "This issue exists to document that a security improvement in the way that Jira Server and Data Center use templates has been implemented. Affected versions of Atlassian Jira Server and Data Center allowed remote attackers with system administrator permissions to execute arbitrary code via Template Injection leading to Remote Code Execution (RCE) in the Email Templates feature. In this case the security improvement was to protect against using the XStream library to be able to execute arbitrary code in velocity templates. The affected versions are before version 8.13.19, from version 8.14.0 before 8.20.7, and from version 8.21.0 before 8.22.1."}, {"Reference": "CVE-2022-4300", "Description": "A vulnerability was found in FastCMS. It has been rated as critical. This issue affects some unknown processing of the file /template/edit of the component Template Handler. The manipulation leads to injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-214901 was assigned to this vulnerability."}, {"Reference": "CVE-2022-45132", "Description": "In Linaro Automated Validation Architecture (LAVA) before 2022.11.1, remote code execution can be achieved through user-submitted Jinja2 template. The REST API endpoint for validating device configuration files in lava-server loads input as a Jinja2 template in a way that can be used to trigger remote code execution in the LAVA server."}]}
{"ID": "1338", "Name": "Improper Protections Against Hardware Overheating", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "A hardware device is missing or has inadequate protection features to prevent overheating.", "ExtendedDescription": "\n\nHardware, electrical circuits, and semiconductor silicon have thermal side effects, such that some of the energy consumed by the device gets dissipated as heat and increases the temperature of the device. For example, in semiconductors, higher-operating frequency of silicon results in higher power dissipation and heat. The leakage current in CMOS circuits increases with temperature, and this creates positive feedback that can result in thermal runaway and damage the device permanently.\n\n\nAny device lacking protections such as thermal sensors, adequate platform cooling, or thermal insulation is susceptible to attacks by malicious software that might deliberately operate the device in modes that result in overheating. This can be used as an effective denial of service (DoS) or permanent denial of service (PDoS) attack.\n\n\nDepending on the type of hardware device and its expected usage, such thermal overheating can also cause safety hazards and reliability issues. Note that battery failures can also cause device overheating but the mitigations and examples included in this submission cannot reliably protect against a battery failure. \n\n\nThere can be similar weaknesses with lack of protection from attacks based on overvoltage or overcurrent conditions. However, thermal heat is generated by hardware operation and the device should implement protection from overheating.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "693", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Power Management Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation", "Note": "Such issues could be introduced during hardware architecture, design or implementation."}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Resource Consumption (Other)"], "Likelihood": ["High"]}], "DetectionMethods": [{"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "Dynamic tests should be performed to stress-test temperature controls.", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "Power management controls should be part of Architecture and Design reviews.", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Temperature maximum and minimum limits should be enforced using thermal sensors both in silicon and at the platform level."}, {"Phase": ["Implementation"], "Description": "The platform should support cooling solutions such as fans that can be modulated based on device-operation needs to maintain a stable temperature."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Malicious software running on a core can execute instructions that consume maximum power or increase core frequency. Such a power-virus program could execute on the platform for an extended time to overheat the device, resulting in permanent damage."}, {"BodyText": "Execution core and platform do not support thermal sensors, performance throttling, or platform-cooling countermeasures to ensure that any software executing on the system cannot cause overheating past the maximum allowable temperature."}, {"BodyText": "The platform and SoC should have failsafe thermal limits that are enforced by thermal sensors that trigger critical temperature alerts when high temperature is detected. Upon detection of high temperatures, the platform should trigger cooling or shutdown automatically."}]}], "RelatedAttackPatterns": ["624", "625"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1339", "Name": "Insufficient Precision or Accuracy of a Real Number", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product processes a real number with an implementation in which the number's representation does not preserve required accuracy and precision in its fractional part, causing an incorrect result.", "ExtendedDescription": "\n\nWhen a security decision or calculation requires highly precise, accurate numbers such as financial calculations or prices, then small variations in the number could be exploited by an attacker. \n\n\nThere are multiple ways to store the fractional part of a real number in a computer. In all of these cases, there is a limit to the accuracy of recording a fraction. If the fraction can be represented in a fixed number of digits (binary or decimal), there might not be enough digits assigned to represent the number. In other cases the number cannot be represented in a fixed number of digits due to repeating in decimal or binary notation (e.g. 0.333333...) or due to a transcendental number such as \u03a0 or \u221a2. Rounding of numbers can lead to situations where the computer results do not adequately match the result of sufficiently accurate math. \n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "682", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "190", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "834", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "119", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "BackgroundDetails": ["There are three major ways to store real numbers in computers. Each method is described along with the limitations of how they store their numbers. \n\n  - Fixed: Some implementations use a fixed number of binary bits to represent both the integer and the fraction. In the demonstrative example about Muller's Recurrence, the fraction 108.0 - ((815.0 - 1500.0 / z) / y) cannot be represented in 8 binary digits. The numeric accuracy within languages such as PL/1, COBOL and Ada is expressed in decimal digits rather than binary digits. In SQL and most databases, the length of the integer and the fraction are specified by the programmer in decimal. In the language C, fixed reals are implemented according to ISO/IEC TR18037\n\n  - Floating: The number is stored in a version of scientific notation with a fixed length for the base and the significand. This allows flexibility for more accuracy when the integer portion is smaller. When dealing with large integers, the fractional accuracy is less. Languages such as PL/1, COBOL and Ada set the accuracy by decimal digit representation rather than using binary digits. Python also implements decimal floating-point numbers using the IEEE 754-2008 encoding method.\n\n  - Ratio: The number is stored as the ratio of two integers. These integers also have their limits. These integers can be stored in a fixed number of bits or in a vector of digits. While the vector of digits method provides for very large integers, they cannot truly represent a repeating or transcendental number as those numbers do not ever have a fixed length.\n\n"], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "This weakness is introduced when the developer picks a method to represent a real number. The weakness may only be visible with very specific numeric inputs."}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Crash, Exit, or Restart"], "Note": "This weakness will generally lead to undefined results and therefore crashes. In some implementations the program will halt if the weakness causes an overflow during a calculation."}, {"Scope": ["Integrity"], "Impact": ["Execute Unauthorized Code or Commands"], "Note": "The results of the math are not as expected. This could cause issues where a value would not be properly calculated and provide an incorrect answer."}, {"Scope": ["Confidentiality", "Availability", "Access Control"], "Impact": ["Read Application Data", "Modify Application Data"], "Note": "This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a product's implicit security policy."}], "PotentialMitigations": [{"Phase": ["Implementation", "Patching and Maintenance"], "Description": "The developer or maintainer can move to a more accurate representation of real numbers. In extreme cases, the programmer can move to representations such as ratios of BigInts which can represent real numbers to extremely fine precision. The programmer can also use the concept of an Unum real. The memory and CPU tradeoffs of this change must be examined. Since floating point reals are used in many products and many locations, they are implemented in hardware and most format changes will cause the calculations to be moved into software resulting in slower products."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Muller's Recurrence is a series that is supposed to converge to the number 5. When running this series with the following code, different implementations of real numbers fail at specific iterations:"}, {"Nature": "Bad", "Language": "Rust", "ExampleCode": "fn rec_float(y: f64, z: f64) -> f64 \n {\n\n```\n\t 108.0 - ((815.0 - 1500.0 / z) / y);\n }\n fn float_calc(turns: usize) -> f64 \n {\n\t let mut x: Vec<f64> = vec![4.0, 4.25];\n\t (2..turns + 1).for_each(|number| \n\t {\n\t\t x.push(rec_float(x[number - 1], x[number - 2]));\n\t });\n\t x[turns]\n }\n```"}, {"BodyText": "The chart below shows values for different data structures in the rust language when Muller's recurrence is executed to 80 iterations. The data structure f64 is a 64 bit float. The data structures I<number>F<number> are fixed representations 128 bits in length that use the first number as the size of the integer and the second size as the size of the fraction (e.g. I16F112 uses 16 bits for the integer and 112 bits for the fraction). The data structure of Ratio comes in three different implementations: i32 uses a ratio of 32 bit signed integers, i64 uses a ratio of 64 bit signed integers and BigInt uses a ratio of signed integer with up to 2^32 digits of base 256. Notice how even with 112 bits of fractions or ratios of 64bit unsigned integers, this math still does not converge to an expected value of 5."}, {"Nature": "Good", "Language": "Rust", "ExampleCode": "Use num_rational::BigRational;\n\n fn rec_big(y: BigRational, z: BigRational) -> BigRational\n {\n\n```\n\t BigRational::from_integer(BigInt::from(108))\n\t\t - ((BigRational::from_integer(BigInt::from(815))\n\t\t - BigRational::from_integer(BigInt::from(1500)) / z)\n\t\t / y)\n }\n fn big_calc(turns: usize) -> BigRational \n {\n\t let mut x: Vec<BigRational> = vec![BigRational::from_float(4.0).unwrap(), BigRational::from_float(4.25).unwrap(),];\n\t (2..turns + 1).for_each(|number| \n\t {\n\t\t x.push(rec_big(x[number - 1].clone(), x[number - 2].clone()));\n\t });\n\t x[turns].clone()\n }\n```"}]}, {"Entries": [{"IntroText": "On February 25, 1991, during the eve of the Iraqi invasion of Saudi Arabia, a Scud missile fired from Iraqi positions hit a US Army barracks in Dhahran, Saudi Arabia. It miscalculated time and killed 28 people [REF-1190]."}, {"Reference": "REF-1190"}]}, {"Entries": [{"IntroText": "Sleipner A, an offshore drilling platform in the North Sea, was incorrectly constructed with an underestimate of 50% of strength in a critical cluster of buoyancy cells needed for construction. This led to a leak in buoyancy cells during lowering, causing a seismic event of 3.0 on the Richter Scale and about $700M loss [REF-1281]."}, {"Reference": "REF-1281"}]}], "ObservedExamples": [{"Reference": "CVE-2018-16069", "Description": "Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-16069"}, {"Reference": "CVE-2017-7619", "Description": "Chain: rounding error in floating-point calculations (CWE-1339) in image processor leads to infinite loop (CWE-835)", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-7619"}, {"Reference": "CVE-2021-29529", "Description": "Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-29529"}, {"Reference": "CVE-2008-2108", "Description": "Chain: insufficient precision (CWE-1339) in random-number generator causes some zero bits to be reliably generated, reducing the amount of entropy (CWE-331)", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2108"}, {"Reference": "CVE-2006-6499", "Description": "Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2006-6499"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "134", "Name": "Use of Externally-Controlled Format String", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product uses a function that accepts a format string as an argument, but the format string originates from an external source.", "ExtendedDescription": "\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "668", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "123", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "20", "ViewID": "700", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Often"}, {"Type": "Language", "Name": "C++", "Prevalence": "Often"}, {"Type": "Language", "Name": "Perl", "Prevalence": "Rarely"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "The programmer rarely intends for a format string to be externally-controlled at all. This weakness is frequently introduced in code that constructs log messages, where a constant format string is omitted."}, {"Phase": "Implementation", "Note": "In cases such as localization and internationalization, the language-specific message repositories could be an avenue for exploitation, but the format string issue would be resultant, since attacker control of those repositories would also allow modification of message length, format, and content."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Note": "Format string problems allow for information disclosure which can severely simplify exploitation of the program."}, {"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Modify Memory", "Execute Unauthorized Code or Commands"], "Note": "Format string problems can result in the execution of arbitrary code."}], "DetectionMethods": [{"DetectionMethodID": "DM-1", "Method": "Automated Static Analysis", "Description": "This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives."}, {"Method": "Black Box", "Description": "Since format strings often occur in rarely-occurring erroneous conditions (e.g. for error message logging), they can be difficult to detect using black box methods. It is highly likely that many latent issues exist in executables that do not have associated source code (or equivalent source.", "Effectiveness": "Limited"}, {"Method": "Automated Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode simple extractor - strings, ELF readers, etc.", "Effectiveness": "High"}, {"Method": "Manual Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies", "Effectiveness": "SOAR Partial"}, {"Method": "Dynamic Analysis with Automated Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners", "Effectiveness": "SOAR Partial"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source", "Effectiveness": "High"}, {"Method": "Automated Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWarning Flags", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Choose a language that is not subject to this flaw."}, {"Phase": ["Implementation"], "Description": "Ensure that all format string functions are passed a static string which cannot be controlled by the user, and that the proper number of arguments are always sent to that function as well. If at all possible, use functions that do not support the %n operator in format strings. [REF-116] [REF-117]"}, {"Phase": ["Build and Compilation"], "Description": "Run compilers and linkers with high warning levels, since they may detect incorrect usage."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following program prints a string provided as an argument."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#include <stdio.h>\n\tvoid printWrapper(char *string) {\n\t\t\tprintf(string);\n\t}\n\tint main(int argc, char **argv) {\n\t\t\tchar buf[5012];\n\t\t\tmemcpy(buf, argv[1], 5012);\n\t\t\tprintWrapper(argv[1]);\n\t\t\treturn (0);\n\t}\n```"}, {"BodyText": "The example is exploitable, because of the call to printf() in the printWrapper() function. Note: The stack buffer was added to make exploitation more simple."}]}, {"Entries": [{"IntroText": "The following code copies a command line argument into a buffer using snprintf()."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint main(int argc, char **argv){\n\t\tchar buf[128];\n\t\t...\n\t\tsnprintf(buf,128,argv[1]);\n\t}\n```"}, {"BodyText": "This code allows an attacker to view the contents of the stack and write to the stack using a command line argument containing a sequence of formatting directives. The attacker can read from the stack by providing more formatting directives, such as %x, than the function takes as arguments to be formatted. (In this example, the function takes no arguments to be formatted.) By using the %n formatting directive, the attacker can write to the stack, causing snprintf() to write the number of bytes output thus far to the specified argument (rather than reading a value from the argument, which is the intended behavior). A sophisticated version of this attack will use four staggered writes to completely control the value of a pointer on the stack."}]}, {"Entries": [{"IntroText": "Certain implementations make more advanced attacks even easier by providing format directives that control the location in memory to read from or write to. An example of these directives is shown in the following code, written for glibc:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tprintf(\"%d %d %1$d %1$d\\n\", 5, 9);\n```"}, {"BodyText": "This code produces the following output: 5 9 5 5 It is also possible to use half-writes (%hn) to accurately control arbitrary DWORDS in memory, which greatly reduces the complexity needed to execute an attack that would otherwise require four staggered writes, such as the one mentioned in the first example."}]}], "ObservedExamples": [{"Reference": "CVE-2002-1825", "Description": "format string in Perl program", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1825"}, {"Reference": "CVE-2001-0717", "Description": "format string in bad call to syslog function", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0717"}, {"Reference": "CVE-2002-0573", "Description": "format string in bad call to syslog function", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0573"}, {"Reference": "CVE-2002-1788", "Description": "format strings in NNTP server responses", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1788"}, {"Reference": "CVE-2006-2480", "Description": "Format string vulnerability exploited by triggering errors or warnings, as demonstrated via format string specifiers in a .bmp filename.", "Link": "https://www.cve.org/CVERecord?id=CVE-2006-2480"}, {"Reference": "CVE-2007-2027", "Description": "Chain: untrusted search path enabling resultant format string by loading malicious internationalization messages", "Link": "https://www.cve.org/CVERecord?id=CVE-2007-2027"}], "FunctionalAreas": ["Logging", "Error Handling", "String Processing"], "AffectedResources": ["Memory"], "RelatedAttackPatterns": ["135", "67"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Applicable Platform", "Note": "\n\nThis weakness is possible in any programming language that support format strings.\n"}, {"Type": "Other", "Note": "\n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n"}, {"Type": "Research Gap", "Note": "Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc."}], "Top25Examples": [{"Reference": "CVE-2022-26531", "Description": "Multiple improper input validation flaws were identified in some CLI commands of Zyxel USG/ZyWALL series firmware versions 4.09 through 4.71, USG FLEX series firmware versions 4.50 through 5.21, ATP series firmware versions 4.32 through 5.21, VPN series firmware versions 4.30 through 5.21, NSG series firmware versions 1.00 through 1.33 Patch 4, NXC2500 firmware version 6.10(AAIG.3) and earlier versions, NAP203 firmware version 6.25(ABFA.7) and earlier versions, NWA50AX firmware version 6.25(ABYW.5) and earlier versions, WAC500 firmware version 6.30(ABVS.2) and earlier versions, and WAX510D firmware version 6.30(ABTF.2) and earlier versions, that could allow a local authenticated attacker to cause a buffer overflow or a system crash via a crafted payload."}, {"Reference": "CVE-2022-33938", "Description": "A format string injection vulnerability exists in the ghome_process_control_packet functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted XCMD can lead to memory corruption, information disclosure and denial of service. An attacker can send a malicious XML payload to trigger this vulnerability."}, {"Reference": "CVE-2022-35244", "Description": "A format string injection vulnerability exists in the XCMD getVarHA functionality of abode systems, inc. iota All-In-One Security Kit 6.9X and 6.9Z. A specially-crafted XCMD can lead to memory corruption, information disclosure, and denial of service. An attacker can send a malicious XML payload to trigger this vulnerability."}, {"Reference": "CVE-2022-35874", "Description": "Four format string injection vulnerabilities exist in the XCMD testWifiAP functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9X and 6.9Z. Specially-crafted configuration values can lead to memory corruption, information disclosure and denial of service. An attacker can modify a configuration value and then execute an XCMD to trigger these vulnerabilities.This vulnerability arises from format string injection via the `ssid` and `ssid_hex` configuration parameters, as used within the `testWifiAP` XCMD handler"}, {"Reference": "CVE-2022-35875", "Description": "Four format string injection vulnerabilities exist in the XCMD testWifiAP functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9X and 6.9Z. Specially-crafted configuration values can lead to memory corruption, information disclosure and denial of service. An attacker can modify a configuration value and then execute an XCMD to trigger these vulnerabilities.This vulnerability arises from format string injection via the `wpapsk` configuration parameter, as used within the `testWifiAP` XCMD handler"}, {"Reference": "CVE-2022-35876", "Description": "Four format string injection vulnerabilities exist in the XCMD testWifiAP functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9X and 6.9Z. Specially-crafted configuration values can lead to memory corruption, information disclosure and denial of service. An attacker can modify a configuration value and then execute an XCMD to trigger these vulnerabilities.This vulnerability arises from format string injection via the `default_key_id` and `key` configuration parameters, as used within the `testWifiAP` XCMD handler"}, {"Reference": "CVE-2022-35877", "Description": "Four format string injection vulnerabilities exist in the XCMD testWifiAP functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9X and 6.9Z. Specially-crafted configuration values can lead to memory corruption, information disclosure and denial of service. An attacker can modify a configuration value and then execute an XCMD to trigger these vulnerabilities.This vulnerability arises from format string injection via the `default_key_id` configuration parameter, as used within the `testWifiAP` XCMD handler"}, {"Reference": "CVE-2022-35878", "Description": "Four format string injection vulnerabilities exist in the UPnP logging functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted UPnP negotiation can lead to memory corruption, information disclosure, and denial of service. An attacker can host a malicious UPnP service to trigger these vulnerabilities.This vulnerability arises from format string injection via `ST` and `Location` HTTP response headers, as used within the `DoEnumUPnPService` action handler."}, {"Reference": "CVE-2022-35879", "Description": "Four format string injection vulnerabilities exist in the UPnP logging functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted UPnP negotiation can lead to memory corruption, information disclosure, and denial of service. An attacker can host a malicious UPnP service to trigger these vulnerabilities.This vulnerability arises from format string injection via `controlURL` XML tag, as used within the `DoUpdateUPnPbyService` action handler."}, {"Reference": "CVE-2022-35880", "Description": "Four format string injection vulnerabilities exist in the UPnP logging functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted UPnP negotiation can lead to memory corruption, information disclosure, and denial of service. An attacker can host a malicious UPnP service to trigger these vulnerabilities.This vulnerability arises from format string injection via `NewInternalClient` XML tag, as used within the `DoUpdateUPnPbyService` action handler."}, {"Reference": "CVE-2022-35881", "Description": "Four format string injection vulnerabilities exist in the UPnP logging functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted UPnP negotiation can lead to memory corruption, information disclosure, and denial of service. An attacker can host a malicious UPnP service to trigger these vulnerabilities.This vulnerability arises from format string injection via `errorCode` and `errorDescription` XML tags, as used within the `DoUpdateUPnPbyService` action handler."}, {"Reference": "CVE-2022-35884", "Description": "Four format string injection vulnerabilities exist in the web interface /action/wirelessConnect functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted HTTP request can lead to memory corruption, information disclosure and denial of service. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability arises from format string injection via the `ssid_hex` HTTP parameter, as used within the `/action/wirelessConnect` handler."}, {"Reference": "CVE-2022-35885", "Description": "Four format string injection vulnerabilities exist in the web interface /action/wirelessConnect functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted HTTP request can lead to memory corruption, information disclosure and denial of service. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability arises from format string injection via the `wpapsk_hex` HTTP parameter, as used within the `/action/wirelessConnect` handler."}, {"Reference": "CVE-2022-35886", "Description": "Four format string injection vulnerabilities exist in the web interface /action/wirelessConnect functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted HTTP request can lead to memory corruption, information disclosure and denial of service. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability arises from format string injection via the `default_key_id` and `key` HTTP parameters, as used within the `/action/wirelessConnect` handler."}, {"Reference": "CVE-2022-35887", "Description": "Four format string injection vulnerabilities exist in the web interface /action/wirelessConnect functionality of Abode Systems, Inc. iota All-In-One Security Kit 6.9Z and 6.9X. A specially-crafted HTTP request can lead to memory corruption, information disclosure and denial of service. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability arises from format string injection via the `default_key_id` HTTP parameter, as used within the `/action/wirelessConnect` handler."}, {"Reference": "CVE-2021-3442", "Description": "A flaw was found in the Red Hat OpenShift API Management product. User input is not validated allowing an authenticated user to inject scripts into some text boxes leading to a XSS attack. The highest threat from this vulnerability is to data confidentiality."}, {"Reference": "CVE-2022-3724", "Description": "Crash in the USB HID protocol dissector in Wireshark 3.6.0 to 3.6.8 allows denial of service via packet injection or crafted capture file on Windows"}]}
{"ID": "1341", "Name": "Multiple Releases of Same Resource or Handle", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product attempts to close or release a resource or handle more than once, without any successful open between the close operations.", "ExtendedDescription": "\n\nCode typically requires \"opening\" handles or references to resources such as memory, files, devices, socket connections, services, etc. When the code is finished with using the resource, it is typically expected to \"close\" or \"release\" the resource, which indicates to the environment (such as the OS) that the resource can be re-assigned or reused by unrelated processes or actors - or in some cases, within the same process. API functions or other abstractions are often used to perform this release, such as free() or delete() within C/C++, or file-handle close() operations that are used in many languages.\n\n\nUnfortunately, the implementation or design of such APIs might expect the developer to be responsible for ensuring that such APIs are only called once per release of the resource. If the developer attempts to release the same resource/handle more than once, then the API's expectations are not met, resulting in undefined and/or insecure behavior. This could lead to consequences such as memory corruption, data corruption, execution path corruption, or other consequences.\n\n\nNote that while the implementation for most (if not all) resource reservation allocations involve a unique identifier/pointer/symbolic reference, then if this identifier is reused, checking the identifier for resource closure may result in a false state of openness and closing of the wrong resource. For this reason, reuse of identifiers is discouraged.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "675", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "672", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Rust", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability", "Integrity"], "Impact": ["DoS: Crash, Exit, or Restart"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Automated Static Analysis", "Description": "For commonly-used APIs and resource types, automated tools often have signatures that can spot this issue."}, {"Method": "Automated Dynamic Analysis", "Description": "Some compiler instrumentation tools such as AddressSanitizer (ASan) can indirectly detect some instances of this weakness."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Change the code's logic so that the resource is only closed once. This might require simplifying or refactoring. This fix can be simple to do in small code blocks, but more difficult when multiple closes are buried within complex conditionals."}, {"Phase": ["Implementation"], "Strategy": "Refactoring", "Description": "It can be effective to implement a flag that is (1) set when the resource is opened, (2) cleared when it is closed, and (3) checked before closing. This approach can be useful when there are disparate cases in which closes must be performed. However, flag-tracking can increase code complexity and requires diligent compliance by the programmer."}, {"Phase": ["Implementation"], "Strategy": "Refactoring", "Description": "When closing a resource, set the resource's associated variable to NULL or equivalent value for the given language. Some APIs will ignore this null value without causing errors. For other APIs, this can lead to application crashes or exceptions, which may still be preferable to corrupting an unintended resource such as memory or data.", "Effectiveness": "Defense in Depth"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example attempts to close a file twice. In some cases, the C library fclose() function will catch the error and return an error code. In other implementations, a double-free (CWE-415) occurs, causing the program to fault. Note that the examples presented here are simplistic, and double fclose() calls will frequently be spread around a program, making them more difficult to find during code reviews."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "char b[2000];\n FILE *f = fopen(\"dbl_cls.c\", \"r\");\n if (f)\n {\n\n```\n\tb[0] = 0;\n\t fread(b, 1, sizeof(b) - 1, f);\n\t printf(\"%s\\n'\", b);\n\t int r1 = fclose(f);\n\t printf(\"\\n-----------------\\n1 close done '%d'\\n\", r1);\n\t int r2 = fclose(f); // Double close\n\t printf(\"2 close done '%d'\\n\", r2);\n }\n```"}, {"BodyText": "There are multiple possible fixes. This fix only has one call to fclose(), which is typically the preferred handling of this problem - but this simplistic method is not always possible."}, {"Nature": "Good", "Language": "C", "ExampleCode": "char b[2000];\n FILE *f = fopen(\"dbl_cls.c\", \"r\");\n if (f)\n {\n\n```\n\tb[0] = 0;\n\t fread(b, 1, sizeof(b) - 1, f);\n\t printf(\"%s\\n'\", b);\n\t int r = fclose(f);\n\t printf(\"\\n-----------------\\n1 close done '%d'\\n\", r);\n }\n```"}, {"BodyText": "This fix uses a flag to call fclose() only once. Note that this flag is explicit. The variable \"f\" could also have been used as it will be either NULL if the file is not able to be opened or a valid pointer if the file was successfully opened. If \"f\" is replacing \"f_flg\" then \"f\" would need to be set to NULL after the first fclose() call so the second fclose call would never be executed."}, {"Nature": "Good", "Language": "C", "ExampleCode": "char b[2000];\n int f_flg = 0;\n FILE *f = fopen(\"dbl_cls.c\", \"r\");\n if (f)\n {\n\n```\n\tf_flg = 1;\n\t b[0] = 0;\n\t fread(b, 1, sizeof(b) - 1, f);\n\t printf(\"%s\\n'\", b);\n\t if (f_flg)\n\t {\n\t\tint r1 = fclose(f);\n\t\t f_flg = 0;\n\t\t printf(\"\\n-----------------\\n1 close done '%d'\\n\", r1);\n\t }\n\t if (f_flg)\n\t {\n\t\tint r2 = fclose(f); // Double close\n\t\t f_flg = 0;\n\t\t printf(\"2 close done '%d'\\n\", r2);\n\t }\n }\n```"}]}, {"ID": "DX-149", "Entries": [{"IntroText": "The following code shows a simple example of a double free vulnerability."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tchar* ptr = (char*)malloc (SIZE);\n\t...\n\tif (abrt) {\n\t\tfree(ptr);\n\t}\n\t...\n\tfree(ptr);\n```"}, {"BodyText": "Double free vulnerabilities have two common (and sometimes overlapping) causes:"}, {"BodyText": "- Error conditions and other exceptional circumstances\n\n  - Confusion over which part of the program is responsible for freeing the memory"}, {"BodyText": "Although some double free vulnerabilities are not much more complicated than this example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once."}]}], "ObservedExamples": [{"Reference": "CVE-2019-13351", "Description": "file descriptor double close can cause the wrong file to be associated with a file descriptor.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-13351"}, {"Reference": "CVE-2006-5051", "Description": "Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition that leads to a double free (CWE-415).", "Link": "https://www.cve.org/CVERecord?id=CVE-2006-5051"}, {"Reference": "CVE-2004-0772", "Description": "Double free resultant from certain error conditions.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0772"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Terminology", "Note": "The terms related to \"release\" may vary depending on the type of resource, programming language, specification, or framework. \"Close\" has been used synonymously for the release of resources like file descriptors and file handles. \"Return\" is sometimes used instead of Release. \"Free\" is typically used when releasing memory or buffers back into the system for reuse."}]}
{"ID": "1342", "Name": "Information Exposure through Microarchitectural State after Transient Execution", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.", "ExtendedDescription": "\n\nIn many processor architectures an exception, mis-speculation, or microcode assist results in a flush operation to clear results that are no longer required. This action prevents these results from influencing architectural state that is intended to be visible from software. However, traces of this transient execution may remain in microarchitectural buffers, resulting in a change in microarchitectural state that can expose sensitive information to an attacker using side-channel analysis. For example, Load Value Injection (LVI) [REF-1202] can exploit direct injection of erroneous values into intermediate load and store buffers.\n\n\nSeveral conditions may need to be fulfilled for a successful attack:\n\n\n  1. incorrect transient execution that results in remanence of sensitive information;\n\n  1. attacker has the ability to provoke microarchitectural exceptions;\n\n  1. operations and structures in victim code that can be exploited must be identified.\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "226", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "226", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Workstation", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Name": "x86", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Name": "ARM", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Name": "Other", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Requirements"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Modify Memory", "Read Memory", "Execute Unauthorized Code or Commands"], "Likelihood": ["Medium"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Requirements"], "Description": "Hardware ensures that no illegal data flows from faulting micro-ops exists at the microarchitectural level.", "Effectiveness": "High", "EffectivenessNotes": "Being implemented in silicon it is expected to fully address the known weaknesses with limited performance impact."}, {"Phase": ["Build and Compilation"], "Description": "Include instructions that explicitly remove traces of unneeded computations from software interactions with microarchitectural elements e.g. lfence, sfence, mfence, clflush.", "Effectiveness": "High", "EffectivenessNotes": "This effectively forces the processor to complete each memory access before moving on to the next operation. This may have a large performance impact."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Faulting loads in a victim domain may trigger incorrect transient forwarding, which leaves secret-dependent traces in the microarchitectural state. Consider this example from [REF-1203]."}, {"BodyText": "Consider the code gadget:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t void call_victim(size_t untrusted_arg) {\n\t\t *arg_copy = untrusted_arg;\n\t\t array[**trusted_ptr * 4096];\n\t } \n```"}, {"BodyText": "A processor with this weakness will store the value of untrusted_arg (which may be provided by an attacker) to the stack, which is trusted memory. Additionally, this store operation will save this value in some microarchitectural buffer, e.g. the store queue.\n\n\nIn this code gadget, trusted_ptr is dereferenced while the attacker forces a page fault. The faulting load causes the processor to mis-speculate by forwarding untrusted_arg as the (speculative) load result. The processor then uses untrusted_arg for the pointer dereference. After the fault has been handled and the load has been re-issued with the correct argument, secret-dependent information stored at the address of trusted_ptr remains in microarchitectural state and can be extracted by an attacker using a code gadget."}]}], "ObservedExamples": [{"Reference": "CVE-2020-0551", "Description": "Load value injection in some processors utilizing speculative execution may allow an authenticated user to enable information disclosure via a side-channel with local access.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0551"}], "RelatedAttackPatterns": ["696"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "CWE-1342 differs from CWE-1303, which is related to misprediction and biasing microarchitectural components, while CWE-1342 addresses illegal data flows and retention. For example, Spectre is an instance of CWE-1303 biasing branch prediction to steer the transient execution indirectly."}, {"Type": "Maintenance", "Note": "As of CWE 4.9, members of the CWE Hardware SIG are closely analyzing this entry and others to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks. Additional investigation may include other weaknesses related to microarchitectural state. As a result, this entry might change significantly in CWE 4.10."}], "Top25Examples": [{"Reference": "CVE-2021-33624", "Description": "In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db."}, {"Reference": "CVE-2021-26341", "Description": "Some AMD CPUs may transiently execute beyond unconditional direct branches, which may potentially result in data leakage."}, {"Reference": "CVE-2021-28689", "Description": "x86: Speculative vulnerabilities with bare (non-shim) 32-bit PV guests 32-bit x86 PV guest kernels run in ring 1. At the time when Xen was developed, this area of the i386 architecture was rarely used, which is why Xen was able to use it to implement paravirtualisation, Xen's novel approach to virtualization. In AMD64, Xen had to use a different implementation approach, so Xen does not use ring 1 to support 64-bit guests. With the focus now being on 64-bit systems, and the availability of explicit hardware support for virtualization, fixing speculation issues in ring 1 is not a priority for processor companies. Indirect Branch Restricted Speculation (IBRS) is an architectural x86 extension put together to combat speculative execution sidechannel attacks, including Spectre v2. It was retrofitted in microcode to existing CPUs. For more details on Spectre v2, see: http://xenbits.xen.org/xsa/advisory-254.html However, IBRS does not architecturally protect ring 0 from predictions learnt in ring 1. For more details, see: https://software.intel.com/security-software-guidance/deep-dives/deep-dive-indirect-branch-restricted-speculation Similar situations may exist with other mitigations for other kinds of speculative execution attacks. The situation is quite likely to be similar for speculative execution attacks which have yet to be discovered, disclosed, or mitigated."}, {"Reference": "CVE-2022-29900", "Description": "Mis-trained branch predictions for return instructions may allow arbitrary speculative code execution under certain microarchitecture-dependent conditions."}]}
{"ID": "135", "Name": "Incorrect Calculation of Multi-Byte String Length", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not correctly calculate the length of strings that can contain wide or multi-byte characters.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "682", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "\n\nThere are several ways in which improper string length checking may result in an exploitable condition. All of these, however, involve the introduction of buffer overflow conditions in order to reach an exploitable state.\n\n\nThe first of these issues takes place when the output of a wide or multi-byte character string, string-length function is used as a size for the allocation of memory. While this will result in an output of the number of characters in the string, note that the characters are most likely not a single byte, as they are with standard character strings. So, using the size returned as the size sent to new or malloc and copying the string to this newly allocated memory will result in a buffer overflow.\n\n\nAnother common way these strings are misused involves the mixing of standard string and wide or multi-byte string functions on a single string. Invariably, this mismatched information will result in the creation of a possibly exploitable buffer overflow condition.\n"}], "CommonConsequences": [{"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"], "Note": "This weakness may lead to a buffer overflow. Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service."}, {"Scope": ["Availability", "Confidentiality"], "Impact": ["Read Memory", "DoS: Crash, Exit, or Restart", "DoS: Resource Consumption (CPU)", "DoS: Resource Consumption (Memory)"], "Note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."}, {"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Note": "In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Always verify the length of the string unit character."}, {"Phase": ["Implementation"], "Strategy": "Libraries or Frameworks", "Description": "Use length computing functions (e.g. strlen, wcslen, etc.) appropriately with their equivalent type (e.g.: byte, wchar_t, etc.)"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example would be exploitable if any of the commented incorrect malloc calls were used."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#include <stdio.h>\n\t#include <strings.h>\n\t#include <wchar.h>\n\tint main() {\n\t\t\twchar_t wideString[] = L\"The spazzy orange tiger jumped \" \\\n\t\t\t\"over the tawny jaguar.\";\n\t\t\twchar_t *newString;\n\t\t\tprintf(\"Strlen() output: %d\\nWcslen() output: %d\\n\",\n\t\t\tstrlen(wideString), wcslen(wideString));\n\t\t\t/* Wrong because the number of chars in a string isn't related to its length in bytes //\n\t\t\tnewString = (wchar_t *) malloc(strlen(wideString));\n\t\t\t*/\n\t\t\t/* Wrong because wide characters aren't 1 byte long! //\n\t\t\tnewString = (wchar_t *) malloc(wcslen(wideString));\n\t\t\t*/\n\t\t\t/* Wrong because wcslen does not include the terminating null */\n\t\t\tnewString = (wchar_t *) malloc(wcslen(wideString) * sizeof(wchar_t));\n\t\t\t/* correct! */\n\t\t\tnewString = (wchar_t *) malloc((wcslen(wideString) + 1) * sizeof(wchar_t));\n\t\t\t/* ... */\n\t}\n```"}, {"BodyText": "The output from the printf() statement would be:"}, {"Nature": "Result", "ExampleCode": "```\n\tStrlen() output: 0\n\tWcslen() output: 53\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1351", "Name": "Improper Handling of Hardware Behavior in Exceptionally Cold Environments", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "A hardware device, or the firmware running on it, is\n                missing or has incorrect protection features to maintain\n                goals of security primitives when the device is cooled below\n                standard operating temperatures.", "ExtendedDescription": "\n\nThe hardware designer may improperly anticipate hardware behavior when exposed to exceptionally cold conditions. As a result they may introduce a weakness by not accounting for the modified behavior of critical components when in extreme environments.\n\n\nAn example of a change in behavior is that power loss won't clear/reset any volatile state when cooled below standard operating temperatures. This may result in a weakness when the starting state of the volatile memory is being relied upon for a security decision. For example, a Physical Unclonable Function (PUF) may be supplied as a security primitive to improve confidentiality, authenticity, and integrity guarantees. However, when the PUF is paired with DRAM, SRAM, or another temperature sensitive entropy source, the system designer may introduce weakness by failing to account for the chosen entropy source's behavior at exceptionally low temperatures. In the case of DRAM and SRAM, when power is cycled at low temperatures, the device will not contain the bitwise biasing caused by inconsistencies in manufacturing and will instead contain the data from previous boot. Should the PUF primitive be used in a cryptographic construction which does not account for full adversary control of PUF seed data, weakness would arise.\n\n\nThis weakness does not cover \"Cold Boot Attacks\" wherein RAM or other external storage is super cooled and read externally by an attacker.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1384", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Embedded", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Microcomputer", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Authentication"], "Impact": ["Varies by Context", "Unexpected State"], "Likelihood": ["Low"], "Note": "Consequences of this weakness are highly contextual."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "The system should account for security primitive behavior when cooled outside standard temperatures."}], "RelatedAttackPatterns": ["624", "625"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1357", "Name": "Reliance on Insufficiently Trustworthy Component", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product is built from multiple separate components, but it uses a component that is not sufficiently trusted to meet expectations for security, reliability, updateability, and maintainability.", "ExtendedDescription": "\n\nMany modern hardware and software products are built by combining multiple smaller components together into one larger entity, often during the design or architecture phase. For example, a hardware component might be built by a separate supplier, or the product might use an open-source software library from a third party.\n\n\nRegardless of the source, each component should be sufficiently trusted to ensure correct, secure operation of the product. If a component is not trustworthy, it can produce significant risks for the overall product, such as vulnerabilities that cannot be patched fast enough (if at all); hidden functionality such as malware; inability to update or replace the component if needed for security purposes; hardware components built from parts that do not meet specifications in ways that can lead to weaknesses; etc. Note that a component might not be trustworthy even if it is owned by the product vendor, such as a software component whose source code is lost and was built by developers who left the company, or a component that was developed by a separate company that was acquired and brought into the product's own company.\n\n\nNote that there can be disagreement as to whether a component is sufficiently trustworthy, since trust is ultimately subjective. Different stakeholders (e.g., customers, vendors, governments) have various threat models and ways to assess trust, and design/architecture choices might make tradeoffs between security, reliability, safety, privacy, cost, and other characteristics.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Requirements", "Note": "Requirements might include criteria for which the only available solutions are provided by insufficiently trusted components."}, {"Phase": "Architecture and Design", "Note": "An insufficiently trusted component might be selected because it is less expensive to do in-house, requires expertise that is not available in-house, or might allow the product to reach the market faster."}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Reduce Maintainability"]}], "PotentialMitigations": [{"Phase": ["Requirements", "Architecture and Design", "Implementation"], "Description": "For each component, ensure that its supply chain is well-controlled with sub-tier suppliers using best practices. For third-party software components such as libraries, ensure that they are developed and actively maintained by reputable vendors."}, {"Phase": ["Architecture and Design", "Implementation", "Integration", "Manufacturing"], "Description": "Maintain a Bill of Materials for all components and sub-components of the product. For software, maintain a Software Bill of Materials (SBOM). According to [REF-1247], \"An SBOM is a formal, machine-readable inventory of software components and dependencies, information about those components, and their hierarchical relationships.\""}, {"Phase": ["Operation", "Patching and Maintenance"], "Description": "Continue to monitor changes in each of the product's components, especially when the changes indicate new vulnerabilities, end-of-life (EOL) plans, supplier practices that affect trustworthiness, etc."}], "ObservedExamples": [{"Reference": "CVE-2020-9054", "Description": "Chain: network-attached storage (NAS) device has a critical OS command injection (CWE-78) vulnerability that is actively exploited to place IoT devices into a botnet, but some products are \"end-of-support\" and cannot be patched (CWE-1277). [REF-1097]", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-9054"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Maintenance", "Note": "As of CWE 4.10, the name and description for this entry has undergone significant change and is still under public discussion, especially by members of the HW SIG."}]}
{"ID": "138", "Name": "Improper Neutralization of Special Elements", "Abstraction": "Class", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.", "ExtendedDescription": "Most languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "707", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Other"], "Impact": ["Execute Unauthorized Code or Commands", "Alter Execution Logic", "DoS: Crash, Exit, or Restart"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Developers should anticipate that special elements (e.g. delimiters, symbols) will be injected into input vectors of their product. One defense is to create an allowlist (e.g. a regular expression) that defines valid input according to the requirements specifications. Strictly filter any input that does not match against the allowlist. Properly encode your output, and quote any elements that have special meaning to the component with which you are communicating."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"Phase": ["Implementation"], "Description": "Use and specify an appropriate output encoding to ensure that the special elements are well-defined. A normal byte sequence in one encoding could be a special element in another."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}], "ObservedExamples": [{"Reference": "CVE-2001-0677", "Description": "Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0677"}, {"Reference": "CVE-2000-0703", "Description": "Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0703"}, {"Reference": "CVE-2003-0020", "Description": "Multi-channel issue. Terminal escape sequences not filtered from log files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0020"}, {"Reference": "CVE-2003-0083", "Description": "Multi-channel issue. Terminal escape sequences not filtered from log files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0083"}], "RelatedAttackPatterns": ["105", "15", "34"], "MappingNotes": {"Usage": "Discouraged", "Rationale": "This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Relationship", "Note": "This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements."}, {"Type": "Relationship", "Note": "See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example."}, {"Type": "Research Gap", "Note": "This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format."}], "Top25Examples": [{"Reference": "CVE-2022-0661", "Description": "The Ad Injection WordPress plugin through 1.2.0.19 does not properly sanitize the body of the adverts injected into the pages, allowing a high privileged user (Admin+) to inject arbitrary HTML or javascript even with unfiltered_html disallowed, leading to a stored cross-site scripting (XSS) vulnerability. Further it is also possible to inject PHP code, leading to a Remote Code execution (RCE) vulnerability, even if the DISALLOW_FILE_EDIT and DISALLOW_FILE_MOD constants are both set."}, {"Reference": "CVE-2022-0780", "Description": "The SearchIQ WordPress plugin before 3.9 contains a flag to disable the verification of CSRF nonces, granting unauthenticated attackers access to the siq_ajax AJAX action and allowing them to perform Cross-Site Scripting attacks due to the lack of sanitisation and escaping in the customCss parameter"}, {"Reference": "CVE-2022-0818", "Description": "The WooCommerce Affiliate Plugin WordPress plugin before 4.16.4.5 does not have authorization and CSRF checks on a specific action handler, as well as does not sanitize its settings, which enables an unauthenticated attacker to inject malicious XSS payloads into the settings page of the plugin."}, {"Reference": "CVE-2022-0830", "Description": "The FormBuilder WordPress plugin through 1.08 does not have CSRF checks in place when creating/updating and deleting forms, and does not sanitise as well as escape its form field values. As a result, attackers could make logged in admin update and delete arbitrary forms via a CSRF attack, and put Cross-Site Scripting payloads in them."}, {"Reference": "CVE-2022-0875", "Description": "The Google Authenticator WordPress plugin before 1.0.5 does not have CSRF check when saving its settings, and does not sanitise as well as escape them, allowing attackers to make a logged in admin change them and perform Cross-Site Scripting attacks"}, {"Reference": "CVE-2022-1557", "Description": "The ULeak Security & Monitoring WordPress plugin through 1.2.3 does not have authorisation and CSRF checks when updating its settings, and is also lacking sanitisation as well as escaping in some of them, which could allow any authenticated users such as subscriber to perform Stored Cross-Site Scripting attacks against admins viewing the settings"}, {"Reference": "CVE-2022-1593", "Description": "The Site Offline or Coming Soon WordPress plugin through 1.6.6 does not have CSRF check in place when updating its settings, and it also lacking sanitisation as well as escaping in some of them. As a result, attackers could make a logged in admin change them and put Cross-Site Scripting payloads in them via a CSRF attack"}, {"Reference": "CVE-2022-1626", "Description": "The Sharebar WordPress plugin through 1.4.1 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and also lead to Stored Cross-Site Scripting issue due to the lack of sanitisation and escaping in some of them"}, {"Reference": "CVE-2022-1763", "Description": "Due to missing checks the Static Page eXtended WordPress plugin through 2.1 is vulnerable to CSRF attacks which allows changing the plugin settings, including required user levels for specific features. This could also lead to Stored Cross-Site Scripting due to the lack of escaping in some of the settings"}, {"Reference": "CVE-2022-1764", "Description": "The WP-chgFontSize WordPress plugin through 1.8 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1780", "Description": "The LaTeX for WordPress plugin through 3.4.10 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack which could also lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1781", "Description": "The postTabs WordPress plugin through 2.10.6 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack, which also lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1787", "Description": "The Sideblog WordPress plugin through 6.0 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1792", "Description": "The Quick Subscribe WordPress plugin through 1.7.1 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and leading to Stored XSS due to the lack of sanitisation and escaping in some of them"}, {"Reference": "CVE-2022-1818", "Description": "The Multi-page Toolkit WordPress plugin through 2.6 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping as well"}, {"Reference": "CVE-2022-1829", "Description": "The Inline Google Maps WordPress plugin through 5.11 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack, and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1830", "Description": "The Amazon Einzeltitellinks WordPress plugin through 1.3.3 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1842", "Description": "The OpenBook Book Data WordPress plugin through 3.5.2 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping as well"}, {"Reference": "CVE-2022-1844", "Description": "The WP Sentry WordPress plugin through 1.0 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping as well"}, {"Reference": "CVE-2022-1913", "Description": "The Add Post URL WordPress plugin through 2.1.0 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored Cross-Site Scripting due to the lack of sanitisation and escaping"}, {"Reference": "CVE-2022-1914", "Description": "The Clean-Contact WordPress plugin through 1.6 does not have CSRF check in place when updating its settings, which could allow attackers to make a logged in admin change them via a CSRF attack and lead to Stored XSS due to the lack of sanitisation and escaping as well"}, {"Reference": "CVE-2022-2071", "Description": "The Name Directory WordPress plugin before 1.25.4 does not have CSRF check when importing names, and is also lacking sanitisation as well as escaping in some of the imported data, which could allow attackers to make a logged in admin import arbitrary names with XSS payloads in them."}, {"Reference": "CVE-2022-35651", "Description": "A stored XSS and blind SSRF vulnerability was found in Moodle, occurs due to insufficient sanitization of user-supplied data in the SCORM track details. A remote attacker can trick the victim to follow a specially crafted link and execute arbitrary HTML and script code in user's browser in context of vulnerable website to steal potentially sensitive information, change appearance of the web page, can perform phishing and drive-by-download attacks."}, {"Reference": "CVE-2022-36325", "Description": "Affected devices do not properly sanitize data introduced by an user when rendering the web interface. This could allow an authenticated remote attacker with administrative privileges to inject code and lead to a DOM-based XSS."}, {"Reference": "CVE-2022-4029", "Description": "The Simple:Press plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the 'sforum_[md5 hash of the WordPress URL]' cookie value in versions up to, and including, 6.8 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link. This would be highly complex to exploit as it would require the attacker to set the cookie a cookie for the targeted user."}, {"Reference": "CVE-2022-4125", "Description": "The Popup Manager WordPress plugin through 1.6.6 does not have authorisation and CSRF check when creating/updating popups, and is missing sanitisation as well as escaping, which could allow unauthenticated attackers to create arbitrary popups and add Stored XSS payloads as well"}, {"Reference": "CVE-2022-24720", "Description": "image_processing is an image processing wrapper for libvips and ImageMagick/GraphicsMagick. Prior to version 1.12.2, using the `#apply` method from image_processing to apply a series of operations that are coming from unsanitized user input allows the attacker to execute shell commands. This method is called internally by Active Storage variants, so Active Storage is vulnerable as well. The vulnerability has been fixed in version 1.12.2 of image_processing. As a workaround, users who process based on user input should always sanitize the user input by allowing only a constrained set of operations."}, {"Reference": "CVE-2022-43407", "Description": "Jenkins Pipeline: Input Step Plugin 451.vf1a_a_4f405289 and earlier does not restrict or sanitize the optionally specified ID of the 'input' step, which is used for the URLs that process user interactions for the given 'input' step (proceed or abort) and is not correctly encoded, allowing attackers able to configure Pipelines to have Jenkins build URLs from 'input' step IDs that would bypass the CSRF protection of any target URL in Jenkins when the 'input' step is interacted with."}, {"Reference": "CVE-2021-25296", "Description": "Nagios XI version xi-5.7.5 is affected by OS command injection. The vulnerability exists in the file /usr/local/nagiosxi/html/includes/configwizards/windowswmi/windowswmi.inc.php due to improper sanitization of authenticated user-controlled input by a single HTTP request, which can lead to OS command injection on the Nagios XI server."}, {"Reference": "CVE-2021-25297", "Description": "Nagios XI version xi-5.7.5 is affected by OS command injection. The vulnerability exists in the file /usr/local/nagiosxi/html/includes/configwizards/switch/switch.inc.php due to improper sanitization of authenticated user-controlled input by a single HTTP request, which can lead to OS command injection on the Nagios XI server."}, {"Reference": "CVE-2021-25298", "Description": "Nagios XI version xi-5.7.5 is affected by OS command injection. The vulnerability exists in the file /usr/local/nagiosxi/html/includes/configwizards/cloud-vm/cloud-vm.inc.php due to improper sanitization of authenticated user-controlled input by a single HTTP request, which can lead to OS command injection on the Nagios XI server."}, {"Reference": "CVE-2021-27101", "Description": "Accellion FTA 9_12_370 and earlier is affected by SQL injection via a crafted Host header in a request to document_root.html. The fixed version is FTA_9_12_380 and later."}, {"Reference": "CVE-2021-35394", "Description": "Realtek Jungle SDK version v2.x up to v3.4.14B provides a diagnostic tool called 'MP Daemon' that is usually compiled as 'UDPServer' binary. The binary is affected by multiple memory corruption vulnerabilities and an arbitrary command injection vulnerability that can be exploited by remote unauthenticated attackers."}, {"Reference": "CVE-2022-26352", "Description": "An issue was discovered in the ContentResource API in dotCMS 3.0 through 22.02. Attackers can craft a multipart form request to post a file whose filename is not initially sanitized. This allows directory traversal, in which the file is saved outside of the intended storage location. If anonymous content creation is enabled, this allows an unauthenticated attacker to upload an executable file, such as a .jsp file, that can lead to remote code execution."}, {"Reference": "CVE-2022-27926", "Description": "A reflected cross-site scripting (XSS) vulnerability in the /public/launchNewWindow.jsp component of Zimbra Collaboration (aka ZCS) 9.0 allows unauthenticated attackers to execute arbitrary web script or HTML via request parameters."}, {"Reference": "CVE-2022-22221", "Description": "An Improper Neutralization of Special Elements vulnerability in the download manager of Juniper Networks Junos OS on SRX Series and EX Series allows a locally authenticated attacker with low privileges to take full control over the device. One aspect of this vulnerability is that the attacker needs to be able to execute any of the \"request ...\" or \"show system download ...\" commands. This issue affects Juniper Networks Junos OS on SRX Series and EX Series: All versions prior to 19.2R1-S9, 19.2R3-S5; 19.3 versions prior to 19.3R3-S6; 19.4 versions prior to 19.4R3-S8; 20.1 versions prior to 20.1R3-S4; 20.2 versions prior to 20.2R3-S4; 20.3 versions prior to 20.3R3-S3; 20.4 versions prior to 20.4R3-S2, 20.4R3-S3; 21.1 versions prior to 21.1R3-S1; 21.2 versions prior to 21.2R2-S2, 21.2R3; 21.3 versions prior to 21.3R2, 21.3R3; 21.4 versions prior to 21.4R1-S1, 21.4R2."}, {"Reference": "CVE-2022-3047", "Description": "Insufficient policy enforcement in Extensions API in Google Chrome prior to 105.0.5195.52 allowed an attacker who convinced a user to install a malicious extension to bypass downloads policy via a crafted HTML page."}, {"Reference": "CVE-2022-21705", "Description": "Octobercms is a self-hosted CMS platform based on the Laravel PHP Framework. In affected versions user input was not properly sanitized before rendering. An authenticated user with the permissions to create, modify and delete website pages can exploit this vulnerability to bypass `cms.safe_mode` / `cms.enableSafeMode` in order to execute arbitrary code. This issue only affects admin panels that rely on safe mode and restricted permissions. To exploit this vulnerability, an attacker must first have access to the backend area. The issue has been patched in Build 474 (v1.0.474) and v1.1.10. Users unable to upgrade should apply https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe to your installation manually."}, {"Reference": "CVE-2022-24039", "Description": "A vulnerability has been identified in Desigo PXC4 (All versions < V02.20.142.10-10884), Desigo PXC5 (All versions < V02.20.142.10-10884). The \u201caddCell\u201d JavaScript function fails to properly sanitize user-controllable input before including it into the generated XML body of the XLS report document, such that it is possible to inject arbitrary content (e.g., XML tags) into the generated file. An attacker with restricted privileges, by poisoning any of the content used to generate XLS reports, could be able to leverage the application to deliver malicious files against higher-privileged users and obtain Remote Code Execution (RCE) against the administrator\u2019s workstation."}, {"Reference": "CVE-2022-35948", "Description": "undici is an HTTP/1.1 client, written from scratch for Node.js.`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content-type` header. Example: ``` import { request } from 'undici' const unsanitizedContentTypeInput = 'application/json\\\\r\\\\n\\\\r\\\\nGET /foo2 HTTP/1.1' await request('http://localhost:3000, { method: 'GET', headers: { 'content-type': unsanitizedContentTypeInput }, }) ``` The above snippet will perform two requests in a single `request` API call: 1) `http://localhost:3000/` 2) `http://localhost:3000/foo2` This issue was patched in Undici v5.8.1. Sanitize input when sending content-type headers using user input as a workaround."}, {"Reference": "CVE-2021-24942", "Description": "The Menu Item Visibility Control WordPress plugin through 0.5 doesn't sanitize and validate the \"Visibility logic\" option for WordPress menu items, which could allow highly privileged users to execute arbitrary PHP code even in a hardened environment."}, {"Reference": "CVE-2022-0819", "Description": "Code Injection in GitHub repository dolibarr/dolibarr prior to 15.0.1."}, {"Reference": "CVE-2022-25644", "Description": "All versions of package @pendo324/get-process-by-name are vulnerable to Arbitrary Code Execution due to improper sanitization of getProcessByName function."}, {"Reference": "CVE-2022-46161", "Description": "pdfmake is an open source client/server side PDF printing in pure JavaScript. In versions up to and including 0.2.5 pdfmake contains an unsafe evaluation of user controlled input. Users of pdfmake are thus subject to arbitrary code execution in the context of the process running the pdfmake code. There are no known fixes for this issue. Users are advised to restrict access to trusted user input."}, {"Reference": "CVE-2022-46836", "Description": "PHP code injection in watolib auth.php and hosttags.php in Tribe29's Checkmk <= 2.1.0p10, Checkmk <= 2.0.0p27, and Checkmk <= 1.6.0p29 allows an attacker to inject and execute PHP code which will be executed upon request of the vulnerable component."}, {"Reference": "CVE-2021-33360", "Description": "An issue found in Stoqey gnuplot v.0.0.3 and earlier allows attackers to execute arbitrary code via the src/index.ts, plotCallack, child_process, and/or filePath parameter(s)."}, {"Reference": "CVE-2022-0764", "Description": "Arbitrary Command Injection in GitHub repository strapi/strapi prior to 4.1.0."}, {"Reference": "CVE-2022-21129", "Description": "Versions of the package nemo-appium before 0.0.9 are vulnerable to Command Injection due to improper input sanitization in the 'module.exports.setup' function. **Note:** In order to exploit this vulnerability appium-running 0.1.3 has to be installed as one of nemo-appium dependencies. "}, {"Reference": "CVE-2022-21165", "Description": "All versions of package font-converter are vulnerable to Arbitrary Command Injection due to missing sanitization of input that potentially flows into the child_process.exec() function."}, {"Reference": "CVE-2022-21186", "Description": "The package @acrontum/filesystem-template before 0.0.2 are vulnerable to Arbitrary Command Injection due to the fetchRepo API missing sanitization of the href field of external input."}, {"Reference": "CVE-2022-21191", "Description": "Versions of the package global-modules-path before 3.0.0 are vulnerable to Command Injection due to missing input sanitization or other checks and sandboxes being employed to the getPath function. "}, {"Reference": "CVE-2022-2143", "Description": "The affected product is vulnerable to two instances of command injection, which may allow an attacker to remotely execute arbitrary code."}, {"Reference": "CVE-2022-21810", "Description": "All versions of the package smartctl are vulnerable to Command Injection via the info method due to improper input sanitization. "}, {"Reference": "CVE-2022-25350", "Description": "All versions of the package puppet-facter are vulnerable to Command Injection via the getFact function due to improper input sanitization. "}, {"Reference": "CVE-2022-25853", "Description": "All versions of the package semver-tags are vulnerable to Command Injection via the getGitTagsRemote function due to improper input sanitization. "}, {"Reference": "CVE-2022-25855", "Description": "All versions of the package create-choo-app3 are vulnerable to Command Injection via the devInstall function due to improper user-input sanitization. "}, {"Reference": "CVE-2022-25890", "Description": "All versions of the package wifey are vulnerable to Command Injection via the connect() function due to improper input sanitization. "}, {"Reference": "CVE-2022-25908", "Description": "All versions of the package create-choo-electron are vulnerable to Command Injection via the devInstall function due to improper user-input sanitization. "}, {"Reference": "CVE-2022-25916", "Description": "Versions of the package mt7688-wiscan before 0.8.3 are vulnerable to Command Injection due to improper input sanitization in the 'wiscan.scan' function. "}, {"Reference": "CVE-2022-25923", "Description": "Versions of the package exec-local-bin before 1.2.0 are vulnerable to Command Injection via the theProcess() functionality due to improper user-input sanitization. "}, {"Reference": "CVE-2022-25926", "Description": "Versions of the package window-control before 1.4.5 are vulnerable to Command Injection via the sendKeys function, due to improper input sanitization. "}, {"Reference": "CVE-2022-25962", "Description": "All versions of the package vagrant.js are vulnerable to Command Injection via the boxAdd function due to improper input sanitization. "}, {"Reference": "CVE-2022-3275", "Description": "Command injection is possible in the puppetlabs-apt module prior to version 9.0.0. A malicious actor is able to exploit this vulnerability only if they are able to provide unsanitized input to the module. This condition is rare in most deployments of Puppet and Puppet Enterprise."}, {"Reference": "CVE-2022-3276", "Description": "Command injection is possible in the puppetlabs-mysql module prior to version 13.0.0. A malicious actor is able to exploit this vulnerability only if they are able to provide unsanitized input to the module. This condition is rare in most deployments of Puppet and Puppet Enterprise."}, {"Reference": "CVE-2022-36267", "Description": "In Airspan AirSpot 5410 version 0.3.4.1-4 and under there exists a Unauthenticated remote command injection vulnerability. The ping functionality can be called without user authentication when crafting a malicious http request by injecting code in one of the parameters allowing for remote code execution. This vulnerability is exploited via the binary file /home/www/cgi-bin/diagnostics.cgi that accepts unauthenticated requests and unsanitized data. As a result, a malicious actor can craft a specific request and interact remotely with the device."}, {"Reference": "CVE-2022-40282", "Description": "The web server of Hirschmann BAT-C2 before 09.13.01.00R04 allows authenticated command injection. This allows an authenticated attacker to pass commands to the shell of the system because the dir parameter of the FsCreateDir Ajax function is not sufficiently sanitized. The vendor's ID is BSECV-2022-21."}, {"Reference": "CVE-2022-40785", "Description": "Unsanitized input when setting a locale file leads to shell injection in mIPC camera firmware 5.3.1.2003161406. This allows an attacker to gain remote code execution on cameras running the firmware when a victim logs into a specially crafted mobile app."}, {"Reference": "CVE-2022-45600", "Description": "Aztech WMB250AC Mesh Routers Firmware Version 016 2020 devices improperly manage sessions, which allows remote attackers to bypass authentication in opportunistic circumstances and execute arbitrary commands with administrator privileges by leveraging an existing web portal login."}, {"Reference": "CVE-2022-48338", "Description": "An issue was discovered in GNU Emacs through 28.2. In ruby-mode.el, the ruby-find-library-file function has a local command injection vulnerability. The ruby-find-library-file function is an interactive function, and bound to C-c C-f. Inside the function, the external command gem is called through shell-command-to-string, but the feature-name parameters are not escaped. Thus, malicious Ruby source files may cause commands to be executed."}, {"Reference": "CVE-2022-36323", "Description": "Affected devices do not properly sanitize an input field. This could allow an authenticated remote attacker with administrative privileges to inject code or spawn a system root shell."}, {"Reference": "CVE-2022-25921", "Description": "All versions of package morgan-json are vulnerable to Arbitrary Code Execution due to missing sanitization of input passed to the Function constructor."}, {"Reference": "CVE-2021-35254", "Description": "SolarWinds received a report of a vulnerability related to an input that was not sanitized in WebHelpDesk. SolarWinds has removed this input field to prevent the misuse of this input in the future."}, {"Reference": "CVE-2021-38450", "Description": "The affected controllers do not properly sanitize the input containing code syntax. As a result, an attacker could craft code to alter the intended controller flow of the software."}, {"Reference": "CVE-2021-43404", "Description": "An issue was discovered in FusionPBX before 4.5.30. The FAX file name may have risky characters."}, {"Reference": "CVE-2021-43405", "Description": "An issue was discovered in FusionPBX before 4.5.30. The fax_extension may have risky characters (it is not constrained to be numeric)."}, {"Reference": "CVE-2021-43861", "Description": "Mermaid is a Javascript based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. Prior to version 8.13.8, malicious diagrams can run javascript code at diagram readers' machines. Users should upgrade to version 8.13.8 to receive a patch. There are no known workarounds aside from upgrading."}, {"Reference": "CVE-2022-1414", "Description": "3scale API Management 2 does not perform adequate sanitation for user input in multiple fields. An authenticated user could use this flaw to inject scripts and possibly gain access to sensitive information or conduct further attacks."}, {"Reference": "CVE-2022-1867", "Description": "Insufficient validation of untrusted input in Data Transfer in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to bypass same origin policy via a crafted clipboard content."}, {"Reference": "CVE-2022-22589", "Description": "A validation issue was addressed with improved input sanitization. This issue is fixed in iOS 15.3 and iPadOS 15.3, watchOS 8.4, tvOS 15.3, Safari 15.3, macOS Monterey 12.2. Processing a maliciously crafted mail message may lead to running arbitrary javascript."}, {"Reference": "CVE-2022-28054", "Description": "Improper sanitization of trigger action scripts in VanDyke Software VShell for Windows v4.6.2 allows attackers to execute arbitrary code via a crafted value."}, {"Reference": "CVE-2022-32229", "Description": "A information disclosure vulnerability exists in Rockert.Chat <v5 due to /api/v1/chat.getThreadsList lack of sanitization of user inputs and can therefore leak private thread messages to unauthorized users via Mongo DB injection."}, {"Reference": "CVE-2022-34885", "Description": "An improper input sanitization vulnerability in the Motorola MR2600 router could allow a local user with elevated permissions to execute arbitrary code."}, {"Reference": "CVE-2022-20664", "Description": "A vulnerability in the web management interface of Cisco Secure Email and Web Manager, formerly Cisco Security Management Appliance (SMA), and Cisco Email Security Appliance (ESA) could allow an authenticated, remote attacker to retrieve sensitive information from a Lightweight Directory Access Protocol (LDAP) external authentication server connected to an affected device. This vulnerability is due to a lack of proper input sanitization while querying the external authentication server. An attacker could exploit this vulnerability by sending a crafted query through an external authentication web page. A successful exploit could allow the attacker to gain access to sensitive information, including user credentials from the external authentication server. To exploit this vulnerability, an attacker would need valid operator-level (or higher) credentials."}, {"Reference": "CVE-2021-41844", "Description": "Crocoblock JetEngine before 2.9.1 does not properly validate and sanitize form data."}, {"Reference": "CVE-2021-38703", "Description": "Wireless devices running certain Arcadyan-derived firmware (such as KPN Experia WiFi 1.00.15) do not properly sanitise user input to the syslog configuration form. An authenticated remote attacker could leverage this to alter the device configuration and achieve remote code execution. This can be exploited in conjunction with CVE-2021-20090."}]}
{"ID": "1384", "Name": "Improper Handling of Physical or Environmental Conditions", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product does not properly handle unexpected physical or environmental conditions that occur naturally or are artificially induced.", "ExtendedDescription": "\n\nHardware products are typically only guaranteed to behave correctly within certain physical limits or environmental conditions. Such products cannot necessarily control the physical or external conditions to which they are subjected. However, the inability to handle such conditions can undermine a product's security. For example, an unexpected physical or environmental condition may cause the flipping of a bit that is used for an authentication decision. This unexpected condition could occur naturally or be induced artificially by an adversary.\n\n\nPhysical or environmental conditions of concern are:\n\n\n  -  **Atmospheric characteristics: ** extreme temperature ranges, etc.\n\n  -  **Interference: ** electromagnetic interference (EMI), radio frequency interference (RFI), etc.\n\n  -  **Assorted light sources: ** white light, ultra-violet light (UV), lasers, infrared (IR), etc.\n\n  -  **Power variances: ** under-voltages, over-voltages, under-current, over-current, etc.\n\n  -  **Clock variances: ** glitching, overclocking, clock stretching, etc.\n\n  -  **Component aging and degradation** \n\n  -  **Materials manipulation: ** focused ion beams (FIB), etc.\n\n  -  **Exposure to radiation: ** x-rays, cosmic radiation, etc.\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "703", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "The product's design might not consider checking and handling extreme conditions."}, {"Phase": "Manufacturing", "Note": "For hardware manufacturing, sub-par components might be chosen that are not able to handle the expected environmental conditions."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Varies by Context", "Unexpected State"], "Note": "Consequences of this weakness are highly dependent on the role of affected components within the larger product."}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "In requirements, be specific about expectations for how the product will perform when it exceeds physical and environmental boundary conditions, e.g., by shutting down."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "Where possible, include independent components that can detect excess environmental conditions and have the capability to shut down the product."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "Where possible, use shielding or other materials that can increase the adversary's workload and reduce the likelihood of being able to successfully trigger a security-related failure."}], "ObservedExamples": [{"Reference": "CVE-2019-17391", "Description": "Lack of anti-glitch protections allows an attacker to launch a physical attack to bypass the secure boot and read protected eFuses.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-17391"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}}
{"ID": "1385", "Name": "Missing Origin Validation in WebSockets", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses a WebSocket, but it does not properly verify that the source of data or communication is valid.", "ExtendedDescription": "\n\nWebSockets provide a bi-directional low latency communication (near real-time) between a client and a server. WebSockets are different than HTTP in that the connections are long-lived, as the channel will remain open until the client or the server is ready to send the message, whereas in HTTP, once the response occurs (which typically happens immediately), the transaction completes. \n\n\nA WebSocket can leverage the existing HTTP protocol over ports 80 and 443, but it is not limited to HTTP. WebSockets can make cross-origin requests that are not restricted by browser-based protection mechanisms such as the Same Origin Policy (SOP) or Cross-Origin Resource Sharing (CORS). Without explicit origin validation, this makes CSRF attacks more powerful.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "346", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Web Server", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "Cross-Site WebSocket hijacking (CSWSH)", "Description": "this term is used for attacks that exploit this weakness"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Non-Repudiation", "Access Control"], "Impact": ["Varies by Context", "Gain Privileges or Assume Identity", "Bypass Protection Mechanism", "Read Application Data", "Modify Application Data", "DoS: Crash, Exit, or Restart"], "Note": "The consequences will vary depending on the nature of the functionality that is vulnerable to CSRF. An attacker could effectively perform any operations as the victim. If the victim is an administrator or privileged user, the consequences may include obtaining complete control over the web application - deleting or stealing data, uninstalling the product, or using it to launch other attacks against all of the product's users. Because the attacker has the identity of the victim, the scope of the CSRF is limited only by the victim's privileges."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Enable CORS-like access restrictions by verifying the 'Origin' header during the WebSocket handshake."}, {"Phase": ["Implementation"], "Description": "Use a randomized CSRF token to verify requests."}, {"Phase": ["Implementation"], "Description": "Use TLS to securely communicate using 'wss' (WebSocket Secure) instead of 'ws'."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "Require user authentication prior to the WebSocket connection being established. For example, the WS library in Node has a 'verifyClient' function."}, {"Phase": ["Implementation"], "Description": "Leverage rate limiting to prevent against DoS. Use of the leaky bucket algorithm can help with this.", "Effectiveness": "Defense in Depth"}, {"Phase": ["Implementation"], "Description": "Use a library that provides restriction of the payload size. For example, WS library for Node includes 'maxPayloadoption' that can be set.", "Effectiveness": "Defense in Depth"}, {"Phase": ["Implementation"], "Description": "Treat data/input as untrusted in both directions and apply the same data/input sanitization as XSS, SQLi, etc."}], "ObservedExamples": [{"Reference": "CVE-2020-25095", "Description": "web console for SIEM product does not check Origin header, allowing Cross Site WebSocket Hijacking (CSWH)", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-25095"}, {"Reference": "CVE-2018-6651", "Description": "Chain: gaming client attempts to validate the Origin header, but only uses a substring, allowing Cross-Site WebSocket hijacking by forcing requests from an origin whose hostname is a substring of the valid origin.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-6651"}, {"Reference": "CVE-2018-14730", "Description": "WebSocket server does not check the origin of requests, allowing attackers to steal developer's code using a ws://127.0.0.1:3123/ connection.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-14730"}, {"Reference": "CVE-2018-14731", "Description": "WebSocket server does not check the origin of requests, allowing attackers to steal developer's code using a ws://127.0.0.1/ connection to a randomized port number.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-14731"}, {"Reference": "CVE-2018-14732", "Description": "WebSocket server does not check the origin of requests, allowing attackers to steal developer's code using a ws://127.0.0.1:8080/ connection.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-14732"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-22757", "Description": "Remote Agent, used in WebDriver, did not validate the Host or Origin headers. This could have allowed websites to connect back locally to the user's browser to control it. <br>*This bug only affected Firefox when WebDriver was enabled, which is not the default configuration.*. This vulnerability affects Firefox < 97."}]}
{"ID": "1386", "Name": "Insecure Operation on Windows Junction / Mount Point", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product opens a file or directory, but it does not properly prevent the name from being associated with a junction or mount point to a destination that is outside of the intended control sphere.", "ExtendedDescription": "\n\nDepending on the intended action being performed, this could allow an attacker to cause the product to read, write, delete, or otherwise operate on unauthorized files.\n\n\nIn Windows, NTFS5 allows for file system objects called reparse points. Applications can create a hard link from one directory to another directory, called a junction point. They can also create a mapping from a directory to a drive letter, called a mount point. If a file is used by a privileged program, but it can be replaced with a hard link to a sensitive file (e.g., AUTOEXEC.BAT), an attacker could excalate privileges. When the process opens the file, the attacker can assume the privileges of that process, tricking the privileged process to read, modify, or delete the sensitive file, preventing the program from accurately processing data. Note that one can also point to registries and semaphores.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "59", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Windows", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "The developer might not consider that when a program in Windows operates with different permissions than the executing user, the use of links, mount points, and junctions might cause the program to access files or directories that are outside of the intended storage location."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Files or Directories"], "Note": "Read arbitrary files by replacing a user-controlled folder with a mount point and additional hard links."}, {"Scope": ["Integrity"], "Impact": ["Modify Files or Directories"], "Note": "Modify an arbitrary file by replacing the rollback files in installer directories, as they can have the installer execute those rollbacks."}, {"Scope": ["Availability"], "Impact": ["Modify Files or Directories"], "Note": "Even if there is no control of contents, an arbitrary file delete or overwrite (when running as SYSTEM or admin) can be used for a permanent system denial-of-service, e.g. by deleting a startup configuration file that prevents the service from starting."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Strategy": "Separation of Privilege", "Description": "When designing software that will have different rights than the executer, the software should check that files that it is interacting with are not improper hard links or mount points. One way to do this in Windows is to use the functionality embedded in the following command: \"dir /al /s /b\" or, in PowerShell, use LinkType as a filter. In addition, some software uses authentication via signing to ensure that the file is the correct one to use. Make checks atomic with the file action, otherwise a TOCTOU weakness (CWE-367) can be introduced."}], "ObservedExamples": [{"Reference": "CVE-2021-26426", "Description": "Privileged service allows attackers to delete unauthorized files using a directory junction, leading to arbitrary code execution as SYSTEM.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-26426"}, {"Reference": "CVE-2020-0863", "Description": "By creating a mount point and hard links, an attacker can abuse a service to allow users arbitrary file read permissions.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0863"}, {"Reference": "CVE-2019-1161", "Description": "Chain: race condition (CWE-362) in anti-malware product allows deletion of files by creating a junction (CWE-1386) and using hard links during the time window in which a temporary file is created and deleted.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1161"}, {"Reference": "CVE-2014-0568", "Description": "Escape from sandbox for document reader by using a mountpoint [REF-1264]", "Link": "https://www.cve.org/CVERecord?id=CVE-2014-0568"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Terminology", "Note": "Symbolic links, hard links, junctions, and mount points can be confusing terminology, as there are differences in how they operate between UNIX-based systems and Windows, and there are interactions between them."}, {"Type": "Maintenance", "Note": "This entry is still under development and will continue to see updates and content improvements."}], "Top25Examples": [{"Reference": "CVE-2022-21919", "Description": "Windows User Profile Service Elevation of Privilege Vulnerability"}, {"Reference": "CVE-2021-41379", "Description": "Windows Installer Elevation of Privilege Vulnerability"}, {"Reference": "CVE-2022-21999", "Description": "Windows Print Spooler Elevation of Privilege Vulnerability"}, {"Reference": "CVE-2022-36336", "Description": "A link following vulnerability in the scanning function of Trend Micro Apex One and Worry-Free Business Security agents could allow a local attacker to escalate privileges on affected installations. The resolution for this issue has been deployed automatically via ActiveUpdate to customers in an updated Spyware pattern. Customers who are up-to-date on detection patterns are not required to take any additional steps to mitigate this issue."}, {"Reference": "CVE-2022-0799", "Description": "Insufficient policy enforcement in Installer in Google Chrome on Windows prior to 99.0.4844.51 allowed a remote attacker to perform local privilege escalation via a crafted offline installer file."}, {"Reference": "CVE-2022-34008", "Description": "Comodo Antivirus 12.2.2.8012 has a quarantine flaw that allows privilege escalation. To escalate privilege, a low-privileged attacker can use an NTFS directory junction to restore a malicious DLL from quarantine into the System32 folder."}, {"Reference": "CVE-2022-21895", "Description": "Windows User Profile Service Elevation of Privilege Vulnerability"}]}
{"ID": "1389", "Name": "Incorrect Parsing of Numbers with Different Radices", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product parses numeric input assuming base 10 (decimal) values, but it does not account for inputs that use a different base number (radix).", "ExtendedDescription": "\n\nFrequently, a numeric input that begins with \"0\" is treated as octal, or \"0x\" causes it to be treated as hexadecimal, e.g. by the inet_addr() function. For example, \"023\" (octal) is 35 decimal, or \"0x31\" is 49 decimal. Other bases may be used as well. If the developer assumes decimal-only inputs, the code could produce incorrect numbers when the inputs are parsed using a different base. This can result in unexpected and/or dangerous behavior. For example, a \"0127.0.0.1\" IP address is parsed as octal due to the leading \"0\", whose numeric value would be the same as 87.0.0.1 (decimal), where the developer likely expected to use 127.0.0.1.\n\n\nThe consequences vary depending on the surrounding code in which this weakness occurs, but they can include bypassing network-based access control using unexpected IP addresses or netmasks, or causing apparently-symbolic identifiers to be processed as if they are numbers. In web applications, this can enable bypassing of SSRF restrictions.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "704", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "Input validation used may assume decimal bases during conditional checks, when it may not always be the case."}, {"Phase": "Implementation", "Note": "The application may rely on a service that supports different numerical bases."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Likelihood": ["Unknown"], "Note": "An attacker may use an unexpected numerical base to access private application resources."}, {"Scope": ["Integrity"], "Impact": ["Bypass Protection Mechanism", "Alter Execution Logic"], "Likelihood": ["Unknown"], "Note": "An attacker may use an unexpected numerical base to bypass or manipulate access control mechanisms."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Strategy": "Enforcement by Conversion", "Description": "If only decimal-based values are expected in the application, conditional checks should be created in a way that prevent octal or hexadecimal strings from being checked. This can be achieved by converting any numerical string to an explicit base-10 integer prior to the conditional check, to prevent octal or hex values from ever being checked against the condition."}, {"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "If various numerical bases do need to be supported, check for leading values indicating the non-decimal base you wish to support (such as 0x for hex) and convert the numeric strings to integers of the respective base. Reject any other alternative-base string that is not intentionally supported by the application."}, {"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "If regular expressions are used to validate IP addresses, ensure that they are bounded using ^ and $ to prevent base-prepended IP addresses from being matched."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The below demonstrative example uses an IP validator that splits up an IP address by octet, tests to ensure each octet can be casted into an integer, and then returns the original IP address if no exceptions are raised. This validated IP address is then tested using the \"ping\" command."}, {"Nature": "Bad", "Language": "Python", "ExampleCode": "```\n\t import subprocess\n\t def validate_ip(ip: str):\n\t\t split_ip = ip.split('.')\n\t\t if len(split_ip) > 4 or len(split_ip) == 0:\n\t\t\t raise ValueError(\"Invalid IP length\")\n\t\t for octet in split_ip:\n\t\t\t try:\n\t\t\t\t int(octet, 10)\n\t\t\t except ValueError as e:\n\t\t\t\t raise ValueError(f\"Cannot convert IP octet to int - {e}\")\n```\n# Returns original IP after ensuring no exceptions are raised* \n\t\t return ip\n\t\t\n\t def run_ping(ip: str):\n\t\n\t```\n\t\t validated = validate_ip(ip)\n```\n# The ping command treats zero-prepended IP addresses as octal* \n\t\t result = subprocess.call([\"ping\", validated])\n\t\t print(result)"}, {"BodyText": "If run_ping() were to be called with one or more zero-prepended octets, validate_ip() will succeed as zero-prepended numerical strings can be interpreted as decimal by a cast (\"012\" would cast to 12). However, as the original IP with the prepended zeroes is returned rather than the casted IP, it will be used in the call to the ping command. Ping DOES check and support octal-based IP octets, so the IP reached via ping may be different than the IP assumed by the validator. For example, ping would considered \"0127.0.0.1\" the same as \"87.0.0.1\"."}]}, {"ID": "DX-154", "Entries": [{"IntroText": "This code uses a regular expression to validate an IP string prior to using it in a call to the \"ping\" command."}, {"Nature": "Bad", "Language": "Python", "ExampleCode": "```\n\t import subprocess\n\t import re\n\t def validate_ip_regex(ip: str):\n\t\t ip_validator = re.compile(r\"((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\")\n\t\t if ip_validator.match(ip):\n\t\t\t return ip\n\t\t else:\n\t\t\t raise ValueError(\"IP address does not match valid pattern.\")\n\t def run_ping_regex(ip: str):\n\t\t validated = validate_ip_regex(ip)\n```\n# The ping command treats zero-prepended IP addresses as octal* \n\t\t result = subprocess.call([\"ping\", validated])\n\t\t print(result)"}, {"BodyText": "Since the regular expression does not have anchors (CWE-777), i.e. is unbounded without ^ or $ characters, then prepending a 0 or 0x to the beginning of the IP address will still result in a matched regex pattern. Since the ping command supports octal and hex prepended IP addresses, it will use the unexpectedly valid IP address (CWE-1389). For example, \"0x63.63.63.63\" would be considered equivalent to \"99.63.63.63\". As a result, the attacker could potentially ping systems that the attacker cannot reach directly."}]}, {"Entries": [{"IntroText": "Consider the following scenario, inspired by CWE team member Kelly Todd.\n\n\nKelly wants to set up monitoring systems for his two cats, who pose very different threats. One cat, Night, tweets embarrassing or critical comments about his owner in ways that could cause reputational damage, so Night's blog needs to be monitored regularly. The other cat, Taki, likes to distract Kelly and his coworkers during business meetings with cute meows, so Kelly monitors Taki's location using a different web site.\n\n\nSuppose /etc/hosts provides the site info as follows:"}, {"Nature": "Bad", "Language": "Other", "ExampleCode": "```\n\t taki.example.com 10.1.0.7\n\t night.example.com 010.1.0.8 \n```"}, {"BodyText": "The entry for night.example.com has a typo \"010\" in the first octet. When using ping to ensure the servers are up, the leading 0 causes the IP address to be converted using octal. So when Kelly's script attempts to access night.example.com, it inadvertently scans 8.1.0.8 instead of 10.1.0.8 (since \"010\" in octal is 8 in decimal), and Night is free to send new Tweets without being immediately detected."}]}], "ObservedExamples": [{"Reference": "CVE-2021-29662", "Description": "Chain: Use of zero-prepended IP addresses in Perl-based IP validation module can lead to an access control bypass.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-29662"}, {"Reference": "CVE-2021-28918", "Description": "Chain: Use of zero-prepended IP addresses in a product that manages IP blocks can lead to an SSRF.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-28918"}, {"Reference": "CVE-2021-29921", "Description": "Chain: Use of zero-prepended IP addresses in a Python standard library package can lead to an SSRF.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-29921"}, {"Reference": "CVE-2021-29923", "Description": "Chain: Use of zero-prepended IP addresses in the net Golang library can lead to an access control bypass.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-29923"}, {"Reference": "CVE-2021-29424", "Description": "Chain: Use of zero-prepended IP addresses in Perl netmask module allows bypass of IP-based access control.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-29424"}, {"Reference": "CVE-2016-4029", "Description": "Chain: incorrect validation of intended decimal-based IP address format (CWE-1286) enables parsing of octal or hexadecimal formats (CWE-1389), allowing bypass of an SSRF protection mechanism (CWE-918).", "Link": "https://www.cve.org/CVERecord?id=CVE-2016-4029"}, {"Reference": "CVE-2020-13776", "Description": "Mishandling of hex-valued usernames leads to unexpected decimal conversion and privilege escalation in the systemd Linux suite.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-13776"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-28918", "Description": "Improper input validation of octal strings in netmask npm package v1.0.6 and below allows unauthenticated remote attackers to perform indeterminate SSRF, RFI, and LFI attacks on many of the dependent packages. A remote unauthenticated attacker can bypass packages relying on netmask to filter IPs and reach critical VPN or LAN hosts."}, {"Reference": "CVE-2021-29424", "Description": "The Net::Netmask module before 2.0000 for Perl does not properly consider extraneous zero characters at the beginning of an IP address string, which (in some situations) allows attackers to bypass access control that is based on IP addresses."}, {"Reference": "CVE-2021-29662", "Description": "The Data::Validate::IP module through 0.29 for Perl does not properly consider extraneous zero characters at the beginning of an IP address string, which (in some situations) allows attackers to bypass access control that is based on IP addresses."}, {"Reference": "CVE-2021-33318", "Description": "An Input Validation Vulnerability exists in Joel Christner .NET C# packages WatsonWebserver, IpMatcher 1.0.4.1 and below (IpMatcher) and 4.1.3 and below (WatsonWebserver) due to insufficient validation of input IP addresses and netmasks against the internal Matcher list of IP addresses and subnets."}]}
{"ID": "1390", "Name": "Weak Authentication", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses an authentication mechanism to restrict access to specific users or identities, but the mechanism does not sufficiently prove that the claimed identity is correct.", "ExtendedDescription": "\n\nAttackers may be able to bypass weak authentication faster and/or with less effort than expected.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "287", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Confidentiality", "Availability", "Access Control"], "Impact": ["Read Application Data", "Gain Privileges or Assume Identity", "Execute Unauthorized Code or Commands"], "Note": "This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code."}], "DemonstrativeExamples": [{"ID": "DX-153", "Entries": [{"IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."}, {"BodyText": "Multiple OT products used weak authentication."}]}], "ObservedExamples": [{"Reference": "CVE-2022-30034", "Description": "Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30034"}, {"Reference": "CVE-2022-35248", "Description": "Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35248"}, {"Reference": "CVE-2021-3116", "Description": "Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3116"}, {"Reference": "CVE-2022-29965", "Description": "Distributed Control System (DCS) uses a deterministic algorithm to generate utility passwords", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29965"}, {"Reference": "CVE-2022-29959", "Description": "Initialization file contains credentials that can be decoded using a \"simple string transformation\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29959"}, {"Reference": "CVE-2020-8994", "Description": "UART interface for AI speaker uses empty password for root shell", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8994"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Top25Examples": [{"Reference": "CVE-2022-23134", "Description": "After the initial setup process, some steps of setup.php file are reachable not only by super-administrators, but by unauthenticated users as well. Malicious actor can pass step checks and potentially change the configuration of Zabbix Frontend."}, {"Reference": "CVE-2021-38647", "Description": "Open Management Infrastructure Remote Code Execution Vulnerability"}, {"Reference": "CVE-2021-38648", "Description": "Open Management Infrastructure Elevation of Privilege Vulnerability"}, {"Reference": "CVE-2021-39064", "Description": "IBM Spectrum Copy Data Management 2.2.13 and earlier has weak authentication and password rules and incorrectly handles default credentials for the Spectrum Copy Data Management Admin console. IBM X-Force ID: 214957."}, {"Reference": "CVE-2022-0996", "Description": "A vulnerability was found in the 389 Directory Server that allows expired passwords to access the database to cause improper authentication."}, {"Reference": "CVE-2022-31013", "Description": "Chat Server is the chat server for Vartalap, an open-source messaging application. Versions 2.3.2 until 2.6.0 suffer from a bug in validating the access token, resulting in authentication bypass. The function `this.authProvider.verifyAccessKey` is an async function, as the code is not using `await` to wait for the verification result. Every time the function responds back with success, along with an unhandled exception if the token is invalid. A patch is available in version 2.6.0."}, {"Reference": "CVE-2022-35726", "Description": "Broken Authentication vulnerability in yotuwp Video Gallery plugin <= 1.3.4.5 at WordPress."}, {"Reference": "CVE-2022-36296", "Description": "Broken Authentication vulnerability in JumpDEMAND Inc. ActiveDEMAND plugin <= 0.2.27 at WordPress allows unauthenticated post update/create/delete. "}, {"Reference": "CVE-2022-37298", "Description": "Shinken Solutions Shinken Monitoring Version 2.4.3 affected is vulnerable to Incorrect Access Control. The SafeUnpickler class found in shinken/safepickle.py implements a weak authentication scheme when unserializing objects passed from monitoring nodes to the Shinken monitoring server."}, {"Reference": "CVE-2022-45724", "Description": "Incorrect Access Control in Comfast router CF-WR6110N V2.3.1 allows a remote attacker on the same network to perform any HTTP request to an unauthenticated page to force the server to generate a SESSION_ID, and using this SESSION_ID an attacker can then perform authenticated requests."}, {"Reference": "CVE-2022-1801", "Description": "The Very Simple Contact Form WordPress plugin before 11.6 exposes the solution to the captcha in the rendered contact form, both as hidden input fields and as plain text in the page, making it very easy for bots to bypass the captcha check, rendering the page a likely target for spam bots."}, {"Reference": "CVE-2022-37163", "Description": "Bminusl IHateToBudget v1.5.7 employs a weak password policy which allows attackers to potentially gain unauthorized access to the application via brute-force attacks. Additionally, user passwords are hashed without a salt or pepper making it much easier for tools like hashcat to crack the hashes."}, {"Reference": "CVE-2022-37164", "Description": "Inoda OnTrack v3.4 employs a weak password policy which allows attackers to potentially gain unauthorized access to the application via brute-force attacks. Additionally, user passwords are hashed without a salt or pepper making it much easier for tools like hashcat to crack the hashes."}, {"Reference": "CVE-2022-26691", "Description": "A logic issue was addressed with improved state management. This issue is fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big Sur 11.6.5. An application may be able to gain elevated privileges."}, {"Reference": "CVE-2022-28666", "Description": "Broken Access Control vulnerability in YIKES Inc. Custom Product Tabs for WooCommerce plugin <= 1.7.7 at WordPress leading to &yikes-the-content-toggle option update. "}, {"Reference": "CVE-2021-36369", "Description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed."}, {"Reference": "CVE-2021-3827", "Description": "A flaw was found in keycloak, where the default ECP binding flow allows other authentication flows to be bypassed. By exploiting this behavior, an attacker can bypass the MFA authentication by sending a SOAP request with an AuthnRequest and Authorization header with the user's credentials. The highest threat from this vulnerability is to confidentiality and integrity."}, {"Reference": "CVE-2021-41638", "Description": "The authentication checks of the MELAG FTP Server in version 2.2.0.4 are incomplete, which allows a remote attacker to access local files only by using a valid username."}, {"Reference": "CVE-2022-0910", "Description": "A downgrade from two-factor authentication to one-factor authentication vulnerability in the CGI program of Zyxel USG/ZyWALL series firmware versions 4.32 through 4.71, USG FLEX series firmware versions 4.50 through 5.21, ATP series firmware versions 4.32 through 5.21, and VPN series firmware versions 4.32 through 5.21, that could allow an authenticated attacker to bypass the second authentication phase to connect the IPsec VPN server even though the two-factor authentication (2FA) was enabled."}, {"Reference": "CVE-2022-1049", "Description": "A flaw was found in the Pacemaker configuration tool (pcs). The pcs daemon was allowing expired accounts, and accounts with expired passwords to login when using PAM authentication. Therefore, unprivileged expired accounts that have been denied access could still login."}, {"Reference": "CVE-2022-1426", "Description": "An issue has been discovered in GitLab affecting all versions starting from 12.6 before 14.8.6, all versions starting from 14.9 before 14.9.4, all versions starting from 14.10 before 14.10.1. GitLab was not correctly authenticating a user that had some certain amount of information which allowed an user to authenticate without a personal access token."}, {"Reference": "CVE-2022-1955", "Description": "Session 1.13.0 allows an attacker with physical access to the victim's device to bypass the application's password/pin lock to access user data. This is possible due to lack of adequate security controls to prevent dynamic code manipulation."}, {"Reference": "CVE-2022-20662", "Description": "A vulnerability in the smart card login authentication of Cisco Duo for macOS could allow an unauthenticated attacker with physical access to bypass authentication. This vulnerability exists because the assigned user of a smart card is not properly matched with the authenticating user. An attacker could exploit this vulnerability by configuring a smart card login to bypass Duo authentication. A successful exploit could allow the attacker to use any personal identity verification (PIV) smart card for authentication, even if the smart card is not assigned to the authenticating user."}, {"Reference": "CVE-2022-22956", "Description": "VMware Workspace ONE Access has two authentication bypass vulnerabilities (CVE-2022-22955 & CVE-2022-22956) in the OAuth2 ACS framework. A malicious actor may bypass the authentication mechanism and execute any operation due to exposed endpoints in the authentication framework."}, {"Reference": "CVE-2022-23501", "Description": "TYPO3 is an open source PHP based web content management system. In versions prior to 8.7.49, 9.5.38, 10.4.33, 11.5.20, and 12.1.1 TYPO3 is vulnerable to Improper Authentication. Restricting frontend login to specific users, organized in different storage folders (partitions), can be bypassed. A potential attacker might use this ambiguity in usernames to get access to a different account - however, credentials must be known to the adversary. This issue is patched in versions 8.7.49 ELTS, 9.5.38 ELTS, 10.4.33, 11.5.20, 12.1.1."}, {"Reference": "CVE-2022-23554", "Description": "Alpine is a scaffolding library in Java. Alpine prior to version 1.10.4 allows Authentication Filter bypass. The AuthenticationFilter relies on the request URI to evaluate if the user is accessing the swagger endpoint. By accessing a URL with a path such as /api/foo;%2fapi%2fswagger the contains condition will hold and will return from the authentication filter without aborting the request. Note that the principal object will not be assigned and therefore the issue wont allow user impersonation. This issue has been fixed in version 1.10.4. There are no known workarounds."}, {"Reference": "CVE-2022-23600", "Description": "fleet is an open source device management, built on osquery. Versions prior to 4.9.1 expose a limited ability to spoof SAML authentication with missing audience verification. This impacts deployments using SAML SSO in two specific cases: 1. A malicious or compromised Service Provider (SP) could reuse the SAML response to log into Fleet as a user -- only if the user has an account with the same email in Fleet, _and_ the user signs into the malicious SP via SAML SSO from the same Identity Provider (IdP) configured with Fleet. 2. A user with an account in Fleet could reuse a SAML response intended for another SP to log into Fleet. This is only a concern if the user is blocked from Fleet in the IdP, but continues to have an account in Fleet. If the user is blocked from the IdP entirely, this cannot be exploited. Fleet 4.9.1 resolves this issue. Users unable to upgrade should: Reduce the length of sessions on your IdP to reduce the window for malicious re-use, Limit the amount of SAML Service Providers/Applications used by user accounts with access to Fleet, and When removing access to Fleet in the IdP, delete the Fleet user from Fleet as well."}, {"Reference": "CVE-2022-24259", "Description": "An incorrect check in the component cdr.php of Voipmonitor GUI before v24.96 allows unauthenticated attackers to escalate privileges via a crafted request."}, {"Reference": "CVE-2022-24882", "Description": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). In versions prior to 2.7.0, NT LAN Manager (NTLM) authentication does not properly abort when someone provides and empty password value. This issue affects FreeRDP based RDP Server implementations. RDP clients are not affected. The vulnerability is patched in FreeRDP 2.7.0. There are currently no known workarounds."}, {"Reference": "CVE-2022-24883", "Description": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). Prior to version 2.7.0, server side authentication against a `SAM` file might be successful for invalid credentials if the server has configured an invalid `SAM` file path. FreeRDP based clients are not affected. RDP server implementations using FreeRDP to authenticate against a `SAM` file are affected. Version 2.7.0 contains a fix for this issue. As a workaround, use custom authentication via `HashCallback` and/or ensure the `SAM` database path configured is valid and the application has file handles left."}, {"Reference": "CVE-2022-24885", "Description": "Nextcloud Android app is the Android client for Nextcloud, a self-hosted productivity platform. Prior to version 3.19.1, users can bypass a lock on the Nextcloud app on an Android device by repeatedly reopening the app. Version 3.19.1 contains a fix for the problem. There are currently no known workarounds."}, {"Reference": "CVE-2022-24976", "Description": "Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd, allows authentication bypass by ending an IRC handshake at a certain point during a challenge-response login sequence."}, {"Reference": "CVE-2022-25226", "Description": "ThinVNC version 1.0b1 allows an unauthenticated user to bypass the authentication process via 'http://thin-vnc:8080/cmd?cmd=connect' by obtaining a valid SID without any kind of authentication. It is possible to achieve code execution on the server by sending keyboard or mouse events to the server."}, {"Reference": "CVE-2022-2533", "Description": "An issue has been discovered in GitLab affecting all versions starting from 12.10 before 15.1.6, all versions starting from 15.2 before 15.2.4, all versions starting from 15.3 before 15.3.2. GitLab was not performing correct authentication with some Package Registries when IP address restrictions were configured, allowing an attacker already in possession of a valid Deploy Token to misuse it from any location."}, {"Reference": "CVE-2022-2553", "Description": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster."}, {"Reference": "CVE-2022-2572", "Description": "In affected versions of Octopus Server where access is managed by an external authentication provider, it was possible that the API key/keys of a disabled/deleted user were still valid after the access was revoked."}, {"Reference": "CVE-2022-26504", "Description": "Improper authentication in Veeam Backup & Replication 9.5U3, 9.5U4,10.x and 11.x component used for Microsoft System Center Virtual Machine Manager (SCVMM) allows attackers execute arbitrary code via Veeam.Backup.PSManager.exe"}, {"Reference": "CVE-2022-26562", "Description": "An issue in provider/libserver/ECKrbAuth.cpp of Kopano Core <= v11.0.2.51 contains an issue which allows attackers to authenticate even if the user account or password is expired. It also exists in the predecessor Zarafa Collaboration Platform (ZCP) in provider/libserver/ECPamAuth.cpp of Zarafa >= 6.30 (introduced between 6.30.0 RC1e and 6.30.8 final)."}, {"Reference": "CVE-2022-3477", "Description": "The tagDiv Composer WordPress plugin before 3.5, required by the Newspaper WordPress theme before 12.1 and Newsmag WordPress theme before 5.2.2, does not properly implement the Facebook login feature, allowing unauthenticated attackers to login as any user by just knowing their email address"}, {"Reference": "CVE-2022-35147", "Description": "DoraCMS v2.18 and earlier allows attackers to bypass login authentication via a crafted HTTP request."}, {"Reference": "CVE-2022-36106", "Description": "TYPO3 is an open source PHP based web content management system released under the GNU GPL. It has been discovered that the expiration time of a password reset link for TYPO3 backend users has never been evaluated. As a result, a password reset link could be used to perform a password reset even if the default expiry time of two hours has been exceeded. Update to TYPO3 version 10.4.32 or 11.5.16 that fix the problem. There are no known workarounds for this issue."}, {"Reference": "CVE-2022-36412", "Description": "In Zoho ManageEngine SupportCenter Plus before 11023, V3 API requests are vulnerable to authentication bypass. (An API request may, in effect, be executed with the credentials of a user who authenticated in the past.)"}, {"Reference": "CVE-2022-39238", "Description": "Arvados is an open source platform for managing and analyzing biomedical big data. In versions prior to 2.4.3, when using Portable Authentication Modules (PAM) for user authentication, if a user presented valid credentials but the account is disabled or otherwise not allowed to access the host (such as an expired password), it would still be accepted for access to Arvados. Other authentication methods (LDAP, OpenID Connect) supported by Arvados are not affected by this flaw. This issue is patched in version 2.4.3. Workaround for this issue is to migrate to a different authentication method supported by Arvados, such as LDAP."}, {"Reference": "CVE-2022-39263", "Description": "`@next-auth/upstash-redis-adapter` is the Upstash Redis adapter for NextAuth.js, which provides authentication for Next.js. Applications that use `next-auth` Email Provider and `@next-auth/upstash-redis-adapter` before v3.0.2 are affected by this vulnerability. The Upstash Redis adapter implementation did not check for both the identifier (email) and the token, but only checking for the identifier when verifying the token in the email callback flow. An attacker who knows about the victim's email could easily sign in as the victim, given the attacker also knows about the verification token's expired duration. The vulnerability is patched in v3.0.2. A workaround is available. Using Advanced Initialization, developers can check the requests and compare the query's token and identifier before proceeding."}, {"Reference": "CVE-2022-39355", "Description": "Discourse Patreon enables syncronization between Discourse Groups and Patreon rewards. On sites with Patreon login enabled, an improper authentication vulnerability could be used to take control of a victim's forum account. This vulnerability is patched in commit number 846d012151514b35ce42a1636c7d70f6dcee879e of the discourse-patreon plugin. Out of an abundance of caution, any Discourse accounts which have logged in with an unverified-email Patreon account will be logged out and asked to verify their email address on their next login. As a workaround, disable the patreon integration and log out all users with associated Patreon accounts."}, {"Reference": "CVE-2021-3632", "Description": "A flaw was found in Keycloak. This vulnerability allows anyone to register a new security device or key when there is not a device already registered for any user by using the WebAuthn password-less login flow."}, {"Reference": "CVE-2022-43690", "Description": "Concrete CMS (formerly concrete5) below 8.5.10 and between 9.0.0 and 9.1.2 did not use strict comparison for the legacy_salt so that limited authentication bypass could occur if using this functionality. Remediate by updating to Concrete CMS 9.1.3+ or 8.5.10+."}, {"Reference": "CVE-2022-46170", "Description": "CodeIgniter is a PHP full-stack web framework. When an application uses (1) multiple session cookies (e.g., one for user pages and one for admin pages) and (2) a session handler is set to `DatabaseHandler`, `MemcachedHandler`, or `RedisHandler`, then if an attacker gets one session cookie (e.g., one for user pages), they may be able to access pages that require another session cookie (e.g., for admin pages). This issue has been patched, please upgrade to version 4.2.11 or later. As a workaround, use only one session cookie."}, {"Reference": "CVE-2022-46316", "Description": "A thread security vulnerability exists in the authentication process. Successful exploitation of this vulnerability may affect data integrity, confidentiality, and availability."}, {"Reference": "CVE-2022-30034", "Description": "Flower, a web UI for the Celery Python RPC framework, all versions as of 05-02-2022 is vulnerable to an OAuth authentication bypass. An attacker could then access the Flower API to discover and invoke arbitrary Celery RPC calls or deny service by shutting down Celery task nodes."}, {"Reference": "CVE-2022-30124", "Description": "An improper authentication vulnerability exists in Rocket.Chat Mobile App <4.14.1.22788 that allowed an attacker with physical access to a mobile device to bypass local authentication (PIN code)."}, {"Reference": "CVE-2021-43414", "Description": "An issue was discovered in GNU Hurd before 0.9 20210404-9. The use of an authentication protocol in the proc server is vulnerable to man-in-the-middle attacks, which can be exploited for local privilege escalation to get full root access."}, {"Reference": "CVE-2022-21684", "Description": "Discourse is an open source discussion platform. Versions prior to 2.7.13 in `stable`, 2.8.0.beta11 in `beta`, and 2.8.0.beta11 in `tests-passed` allow some users to log in to a community before they should be able to do so. A user invited via email to a forum with `must_approve_users` enabled is going to be automatically logged in, bypassing the check that does not allow unapproved users to sign in. They will be able to do everything an approved user can do. If they logout, they cannot log back in. This issue is patched in the `stable` version 2.7.13, `beta` version 2.8.0.beta11, and `tests-passed` version 2.8.0.beta11. One may disable invites as a workaround. Administrators can increase `min_trust_level_to_allow_invite` to reduce the attack surface to more trusted users."}, {"Reference": "CVE-2022-2303", "Description": "An issue has been discovered in GitLab CE/EE affecting all versions before 15.0.5, all versions starting from 15.1 before 15.1.4, all versions starting from 15.2 before 15.2.1. It may be possible for group members to bypass 2FA enforcement enabled at the group level by using Resource Owner Password Credentials grant to obtain an access token without using 2FA."}, {"Reference": "CVE-2022-34908", "Description": "An issue was discovered in the A4N (Aremis 4 Nomad) application 1.5.0 for Android. It possesses an authentication mechanism; however, some features do not require any token or cookie in a request. Therefore, an attacker may send a simple HTTP request to the right endpoint, and obtain authorization to retrieve application data."}, {"Reference": "CVE-2022-36755", "Description": "D-Link DIR845L A1 contains a authentication vulnerability via an AUTHORIZED_GROUP=1 value, as demonstrated by a request for getcfg.php."}, {"Reference": "CVE-2022-43400", "Description": "A vulnerability has been identified in Siveillance Video Mobile Server V2022 R2 (All versions < V22.2a (80)). The mobile server component of affected applications improperly handles the log in for Active Directory accounts that are part of Administrators group. This could allow an unauthenticated remote attacker to access the application without a valid account."}, {"Reference": "CVE-2022-47003", "Description": "A vulnerability in the Remember Me function of Mura CMS before v10.0.580 allows attackers to bypass authentication via a crafted web request."}, {"Reference": "CVE-2022-48066", "Description": "An issue in the component global.so of Totolink A830R V4.1.2cu.5182 allows attackers to bypass authentication via a crafted cookie."}, {"Reference": "CVE-2022-1053", "Description": "Keylime does not enforce that the agent registrar data is the same when the tenant uses it for validation of the EK and identity quote and the verifier for validating the integrity quote. This allows an attacker to use one AK, EK pair from a real TPM to pass EK validation and give the verifier an AK of a software TPM. A successful attack breaks the entire chain of trust because a not validated AK is used by the verifier. This issue is worse if the validation happens first and then the agent gets added to the verifier because the timing is easier and the verifier does not validate the regcount entry being equal to 1,"}, {"Reference": "CVE-2022-25568", "Description": "MotionEye v0.42.1 and below allows attackers to access sensitive information via a GET request to /config/list. To exploit this vulnerability, a regular user password must be unconfigured."}, {"Reference": "CVE-2022-45124", "Description": "An information disclosure vulnerability exists in the User authentication functionality of WellinTech KingHistorian 35.01.00.05. A specially crafted network packet can lead to a disclosure of sensitive information. An attacker can sniff network traffic to leverage this vulnerability."}]}
{"ID": "1391", "Name": "Use of Weak Credentials", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses weak credentials (such as a default key or hard-coded password) that can be calculated, derived, reused, or guessed by an attacker.", "ExtendedDescription": "\n\nBy design, authentication protocols try to ensure that attackers must perform brute force attacks if they do not know the credentials such as a key or password. However, when these credentials are easily predictable or even fixed (as with default or hard-coded passwords and keys), then the attacker can defeat the mechanism without relying on brute force.\n\n\nCredentials may be weak for different reasons, such as:\n\n\n  - Hard-coded (i.e., static and unchangeable by the administrator)\n\n  - Default (i.e., the same static value across different deployments/installations, but able to be changed by the administrator)\n\n  - Predictable (i.e., generated in a way that produces unique credentials across deployments/installations, but can still be guessed with reasonable efficiency)\n\nEven if a new, unique credential is intended to be generated for each product installation, if the generation is predictable, then that may also simplify guessing attacks.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1390", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Requirements"}, {"Phase": "Architecture and Design"}, {"Phase": "Installation"}, {"Phase": "Operation"}], "DemonstrativeExamples": [{"ID": "DX-153", "Entries": [{"IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."}, {"BodyText": "Multiple OT products used weak credentials."}]}], "ObservedExamples": [{"Reference": "[REF-1374]", "Description": "Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)", "Link": "https://www.unciphered.com/blog/randstorm-you-cant-patch-a-house-of-cards"}, {"Reference": "CVE-2022-30270", "Description": "Remote Terminal Unit (RTU) uses default credentials for some SSH accounts", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30270"}, {"Reference": "CVE-2022-29965", "Description": "Distributed Control System (DCS) uses a deterministic algorithm to generate utility passwords", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29965"}, {"Reference": "CVE-2022-30271", "Description": "Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used in typical deployments", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30271"}, {"Reference": "CVE-2021-38759", "Description": "microcontroller board has default password, allowing admin access", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-38759"}, {"Reference": "CVE-2021-41192", "Description": "data visualization/sharing package uses default secret keys or cookie values if they are not specified in environment variables", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-41192"}, {"Reference": "CVE-2020-8994", "Description": "UART interface for AI speaker uses empty password for root shell", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8994"}, {"Reference": "CVE-2020-27020", "Description": "password manager does not generate cryptographically strong passwords, allowing prediction of passwords using guessable details such as time of generation", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-27020"}, {"Reference": "CVE-2020-8632", "Description": "password generator for cloud application has small length value, making it easier for brute-force guessing", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8632"}, {"Reference": "CVE-2020-5365", "Description": "network-attached storage (NAS) system has predictable default passwords for a diagnostics/support account", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5365"}, {"Reference": "CVE-2020-5248", "Description": "IT asset management app has a default encryption key that is the same across installations", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-5248"}, {"Reference": "CVE-2012-3503", "Description": "Installation script has a hard-coded secret token value, allowing attackers to bypass authentication", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3503"}, {"Reference": "CVE-2010-2306", "Description": "Intrusion Detection System (IDS) uses the same static, private SSL keys for multiple devices and installations, allowing decryption of SSL traffic", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2306"}, {"Reference": "CVE-2001-0618", "Description": "Residential gateway uses the last 5 digits of the 'Network Name' or SSID as the default WEP key, which allows attackers to get the key by sniffing the SSID, which is sent in the clear", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0618"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Top25Examples": [{"Reference": "CVE-2022-3875", "Description": "A vulnerability classified as critical was found in Click Studios Passwordstate and Passwordstate Browser Extension Chrome. This vulnerability affects unknown code of the component API. The manipulation leads to authentication bypass by assumed-immutable data. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216244."}, {"Reference": "CVE-2021-3979", "Description": "A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks."}, {"Reference": "CVE-2021-41117", "Description": "keypair is a a RSA PEM key generator written in javascript. keypair implements a lot of cryptographic primitives on its own or by borrowing from other libraries where possible, including node-forge. An issue was discovered where this library was generating identical RSA keys used in SSH. This would mean that the library is generating identical P, Q (and thus N) values which, in practical terms, is impossible with RSA-2048 keys. Generating identical values, repeatedly, usually indicates an issue with poor random number generation, or, poor handling of CSPRNG output. Issue 1: Poor random number generation (`GHSL-2021-1012`). The library does not rely entirely on a platform provided CSPRNG, rather, it uses it's own counter-based CMAC approach. Where things go wrong is seeding the CMAC implementation with \"true\" random data in the function `defaultSeedFile`. In order to seed the AES-CMAC generator, the library will take two different approaches depending on the JavaScript execution environment. In a browser, the library will use [`window.crypto.getRandomValues()`](https://github.com/juliangruber/keypair/blob/87c62f255baa12c1ec4f98a91600f82af80be6db/index.js#L971). However, in a nodeJS execution environment, the `window` object is not defined, so it goes down a much less secure solution, also of which has a bug in it. It does look like the library tries to use node's CSPRNG when possible unfortunately, it looks like the `crypto` object is null because a variable was declared with the same name, and set to `null`. So the node CSPRNG path is never taken. However, when `window.crypto.getRandomValues()` is not available, a Lehmer LCG random number generator is used to seed the CMAC counter, and the LCG is seeded with `Math.random`. While this is poor and would likely qualify in a security bug in itself, it does not explain the extreme frequency in which duplicate keys occur. The main flaw: The output from the Lehmer LCG is encoded incorrectly. The specific [line][https://github.com/juliangruber/keypair/blob/87c62f255baa12c1ec4f98a91600f82af80be6db/index.js#L1008] with the flaw is: `b.putByte(String.fromCharCode(next & 0xFF))` The [definition](https://github.com/juliangruber/keypair/blob/87c62f255baa12c1ec4f98a91600f82af80be6db/index.js#L350-L352) of `putByte` is `util.ByteBuffer.prototype.putByte = function(b) {this.data += String.fromCharCode(b);};`. Simplified, this is `String.fromCharCode(String.fromCharCode(next & 0xFF))`. The double `String.fromCharCode` is almost certainly unintentional and the source of weak seeding. Unfortunately, this does not result in an error. Rather, it results most of the buffer containing zeros. Since we are masking with 0xFF, we can determine that 97% of the output from the LCG are converted to zeros. The only outputs that result in meaningful values are outputs 48 through 57, inclusive. The impact is that each byte in the RNG seed has a 97% chance of being 0 due to incorrect conversion. When it is not, the bytes are 0 through 9. In summary, there are three immediate concerns: 1. The library has an insecure random number fallback path. Ideally the library would require a strong CSPRNG instead of attempting to use a LCG and `Math.random`. 2. The library does not correctly use a strong random number generator when run in NodeJS, even though a strong CSPRNG is available. 3. The fallback path has an issue in the implementation where a majority of the seed data is going to effectively be zero. Due to the poor random number generation, keypair generates RSA keys that are relatively easy to guess. This could enable an attacker to decrypt confidential messages or gain authorized access to an account belonging to the victim."}, {"Reference": "CVE-2021-42949", "Description": "The component controlla_login function in HotelDruid Hotel Management Software v3.0.3 generates a predictable session token, allowing attackers to bypass authentication via bruteforce attacks."}, {"Reference": "CVE-2022-22922", "Description": "TP-Link TL-WA850RE Wi-Fi Range Extender before v6_200923 was discovered to use highly predictable and easily detectable session keys, allowing attackers to gain administrative privileges."}, {"Reference": "CVE-2022-23555", "Description": "authentik is an open-source Identity Provider focused on flexibility and versatility. Versions prior to 2022.11.4 and 2022.10.4 are vulnerable to Improper Authentication. Token reuse in invitation URLs leads to access control bypass via the use of a different enrollment flow than in the one provided. The vulnerability allows an attacker that knows different invitation flows names (e.g. `enrollment-invitation-test` and `enrollment-invitation-admin`) via either different invite links or via brute forcing to signup via a single invitation url for any valid invite link received (it can even be a url for a third flow as long as it's a valid invite) as the token used in the `Invitations` section of the Admin interface does NOT change when a different `enrollment flow` is selected via the interface and it is NOT bound to the selected flow, so it will be valid for any flow when used. This issue is patched in authentik 2022.11.4,2022.10.4 and 2022.12.0. Only configurations that use invitations and have multiple enrollment flows with invitation stages that grant different permissions are affected. The default configuration is not vulnerable, and neither are configurations with a single enrollment flow. As a workaround, fixed data can be added to invitations which can be checked in the flow to deny requests. Alternatively, an identifier with high entropy (like a UUID) can be used as flow slug, mitigating the attack vector by exponentially decreasing the possibility of discovering other flows."}, {"Reference": "CVE-2022-25219", "Description": "A null byte interaction error has been discovered in the code that the telnetd_startup daemon uses to construct a pair of ephemeral passwords that allow a user to spawn a telnet service on the router, and to ensure that the telnet service persists upon reboot. By means of a crafted exchange of UDP packets, an unauthenticated attacker on the local network can leverage this null byte interaction error in such a way as to make those ephemeral passwords predictable (with 1-in-94 odds). Since the attacker must manipulate data processed by the OpenSSL function RSA_public_decrypt(), successful exploitation of this vulnerability depends on the use of an unpadded RSA cipher (CVE-2022-25218)."}, {"Reference": "CVE-2022-26307", "Description": "LibreOffice supports the storage of passwords for web connections in the user\u2019s configuration database. The stored passwords are encrypted with a single master key provided by the user. A flaw in LibreOffice existed where master key was poorly encoded resulting in weakening its entropy from 128 to 43 bits making the stored passwords vulerable to a brute force attack if an attacker has access to the users stored config. This issue affects: The Document Foundation LibreOffice 7.2 versions prior to 7.2.7; 7.3 versions prior to 7.3.3."}, {"Reference": "CVE-2022-29245", "Description": "SSH.NET is a Secure Shell (SSH) library for .NET. In versions 2020.0.0 and 2020.0.1, during an `X25519` key exchange, the client\u2019s private key is generated with `System.Random`. `System.Random` is not a cryptographically secure random number generator, it must therefore not be used for cryptographic purposes. When establishing an SSH connection to a remote host, during the X25519 key exchange, the private key is generated with a weak random number generator whose seed can be brute forced. This allows an attacker who is able to eavesdrop on the communications to decrypt them. Version 2020.0.2 contains a patch for this issue. As a workaround, one may disable support for `curve25519-sha256` and `curve25519-sha256@libssh.org` key exchange algorithms."}, {"Reference": "CVE-2022-29965", "Description": "The Emerson DeltaV Distributed Control System (DCS) controllers and IO cards through 2022-04-29 misuse passwords. Access to privileged operations on the maintenance port TELNET interface (23/TCP) on M-series and SIS (CSLS/LSNB/LSNG) nodes is controlled by means of utility passwords. These passwords are generated using a deterministic, insecure algorithm using a single seed value composed of a day/hour/minute timestamp with less than 16 bits of entropy. The seed value is fed through a lookup table and a series of permutation operations resulting in three different four-character passwords corresponding to different privilege levels. An attacker can easily reconstruct these passwords and thus gain access to privileged maintenance operations. NOTE: this is different from CVE-2014-2350."}, {"Reference": "CVE-2022-46505", "Description": "An issue in MatrixSSL 4.5.1-open and earlier leads to failure to securely check the SessionID field, resulting in the misuse of an all-zero MasterSecret that can decrypt secret data."}, {"Reference": "CVE-2022-36536", "Description": "An issue in the component post_applogin.php of Super Flexible Software GmbH & Co. KG Syncovery 9 for Linux v9.47x and below allows attackers to escalate privileges via creating crafted session tokens."}, {"Reference": "CVE-2022-28376", "Description": "Verizon 5G Home LVSKIHP outside devices through 2022-02-15 allow anyone (knowing the device's serial number) to access a CPE admin website, e.g., at the 10.0.0.1 IP address. The password (for the verizon username) is calculated by concatenating the serial number and the model (i.e., the LVSKIHP string), running the sha256sum program, and extracting the first seven characters concatenated with the last seven characters of that SHA-256 value."}, {"Reference": "CVE-2022-34919", "Description": "The file upload wizard in Zengenti Contensis Classic before 15.2.1.79 does not correctly check that a user has authenticated. By uploading a crafted aspx file, it is possible to execute arbitrary commands."}, {"Reference": "CVE-2022-40494", "Description": "NPS before v0.26.10 was discovered to contain an authentication bypass vulnerability via constantly generating and sending the Auth key and Timestamp parameters."}, {"Reference": "CVE-2021-41506", "Description": "Xiaongmai AHB7008T-MH-V2, AHB7804R-ELS, AHB7804R-MH-V2, AHB7808R-MS-V2, AHB7808R-MS, AHB7808T-MS-V2, AHB7804R-LMS, HI3518_50H10L_S39 V4.02.R11.7601.Nat.Onvif.20170420, V4.02.R11.Nat.Onvif.20160422, V4.02.R11.7601.Nat.Onvif.20170424, V4.02.R11.Nat.Onvif.20170327, V4.02.R11.Nat.Onvif.20161205, V4.02.R11.Nat.20170301, V4.02.R12.Nat.OnvifS.20170727 is affected by a backdoor in the macGuarder and dvrHelper binaries of DVR/NVR/IP camera firmware due to static root account credentials in the system."}, {"Reference": "CVE-2022-43917", "Description": " IBM WebSphere Application Server 8.5 and 9.0 traditional container uses weaker than expected cryptographic keys that could allow an attacker to decrypt sensitive information. This affects only the containerized version of WebSphere Application Server traditional. IBM X-Force ID: 241045. "}]}
{"ID": "1392", "Name": "Use of Default Credentials", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.", "ExtendedDescription": "It is common practice for products to be designed to use default keys, passwords, or other mechanisms for authentication. The rationale is to simplify the manufacturing process or the system administrator's task of installation and deployment into an enterprise. However, if admins do not change the defaults, it is easier for attackers to bypass authentication quickly across multiple organizations.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1391", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Authentication"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Prohibit use of default, hard-coded, or other values that do not vary for each installation of the product - especially for separate organizations.", "Effectiveness": "High"}, {"Phase": ["Architecture and Design"], "Description": "Force the administrator to change the credential upon installation.", "Effectiveness": "High"}, {"Phase": ["Installation", "Operation"], "Description": "The product administrator could change the defaults upon installation or during operation.", "Effectiveness": "Moderate"}], "DemonstrativeExamples": [{"ID": "DX-153", "Entries": [{"IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."}, {"BodyText": "At least one OT product used default credentials."}]}], "ObservedExamples": [{"Reference": "CVE-2022-30270", "Description": "Remote Terminal Unit (RTU) uses default credentials for some SSH accounts", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30270"}, {"Reference": "CVE-2021-41192", "Description": "data visualization/sharing package uses default secret keys or cookie values if they are not specified in environment variables", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-41192"}, {"Reference": "CVE-2021-38759", "Description": "microcontroller board has default password", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-38759"}, {"Reference": "CVE-2010-2306", "Description": "Intrusion Detection System (IDS) uses the same static, private SSL keys for multiple devices and installations, allowing decryption of SSL traffic", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2306"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-36718", "Description": "SYNEL - eharmonynew / Synel Reports - The attacker can log in to the system with default credentials and export a report of eharmony system with sensetive data (Employee name, Employee ID number, Working hours etc') The vulnerabilety has been addressed and fixed on version 11. Default credentials , Security miscommunication , Sensetive data exposure vulnerability in Synel Reports of SYNEL eharmonynew, Synel Reports allows an attacker to log into the system with default credentials. This issue affects: SYNEL eharmonynew, Synel Reports 8.0.2 version 11 and prior versions."}, {"Reference": "CVE-2022-20918", "Description": "A vulnerability in the Simple Network Management Protocol (SNMP) access controls for Cisco FirePOWER Software for Adaptive Security Appliance (ASA) FirePOWER module, Cisco Firepower Management Center (FMC) Software, and Cisco Next-Generation Intrusion Prevention System (NGIPS) Software could allow an unauthenticated, remote attacker to perform an SNMP GET request using a default credential. This vulnerability is due to the presence of a default credential for SNMP version 1 (SNMPv1) and SNMP version 2 (SNMPv2). An attacker could exploit this vulnerability by sending an SNMPv1 or SNMPv2 GET request to an affected device. A successful exploit could allow the attacker to retrieve sensitive information from the device using the default credential. This attack will only be successful if SNMP is configured, and the attacker can only perform SNMP GET requests; write access using SNMP is not allowed."}, {"Reference": "CVE-2022-30270", "Description": "The Motorola ACE1000 RTU through 2022-05-02 has default credentials. It exposes an SSH interface on port 22/TCP. This interface is used for remote maintenance and for SFTP file-transfer operations that are part of engineering software functionality. Access to this interface is controlled by 5 preconfigured accounts (root, abuilder, acelogin, cappl, ace), all of which come with default credentials. Although the ACE1000 documentation mentions the root, abuilder and acelogin accounts and instructs users to change the default credentials, the cappl and ace accounts remain undocumented and thus are unlikely to have their credentials changed."}, {"Reference": "CVE-2022-36524", "Description": "D-Link GO-RT-AC750 GORTAC750_revA_v101b03 & GO-RT-AC750_revB_FWv200b02 is vulnerable to Static Default Credentials via /etc/init0.d/S80telnetd.sh."}, {"Reference": "CVE-2022-38556", "Description": "Trendnet TEW733GR v1.03B01 contains a Static Default Credential vulnerability in /etc/init0.d/S80telnetd.sh."}, {"Reference": "CVE-2022-38557", "Description": "D-Link DIR845L v1.00-v1.03 contains a Static Default Credential vulnerability in /etc/init0.d/S80telnetd.sh."}, {"Reference": "CVE-2022-40242", "Description": "MegaRAC Default Credentials Vulnerability"}, {"Reference": "CVE-2022-40259", "Description": "MegaRAC Default Credentials Vulnerability"}, {"Reference": "CVE-2022-42951", "Description": "An issue was discovered in Couchbase Server 6.5.x and 6.6.x before 6.6.6, 7.x before 7.0.5, and 7.1.x before 7.1.2. During the start-up of a Couchbase Server node, there is a small window of time (before the cluster management authentication has started) where an attacker can connect to the cluster manager using default credentials."}, {"Reference": "CVE-2021-45841", "Description": "In Terramaster F4-210, F2-210 TOS 4.2.X (4.2.15-2107141517), an attacker can self-sign session cookies by knowing the target's MAC address and the user's password hash. Guest users (disabled by default) can be abused using a null/empty hash and allow an unauthenticated attacker to login as guest."}, {"Reference": "CVE-2022-1666", "Description": "The default password for the web application\u2019s root user (the vendor\u2019s private account) was weak and the MD5 hash was used to crack the password using a widely available open-source tool."}, {"Reference": "CVE-2022-35203", "Description": "An access control issue in TrendNet TV-IP572PI v1.0 allows unauthenticated attackers to access sensitive system information."}, {"Reference": "CVE-2022-23320", "Description": "XMPie uStore 12.3.7244.0 allows for administrators to generate reports based on raw SQL queries. Since the application ships with default administrative credentials, an attacker may authenticate into the application and exfiltrate sensitive information from the database."}]}
{"ID": "1393", "Name": "Use of Default Password", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses default passwords for potentially critical functionality.", "ExtendedDescription": "It is common practice for products to be designed to use default passwords for authentication. The rationale is to simplify the manufacturing process or the system administrator's task of installation and deployment into an enterprise. However, if admins do not change the defaults, then it makes it easier for attackers to quickly bypass authentication across multiple organizations. There are many lists of default passwords and default-password scanning tools that are easily available from the World Wide Web.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1392", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Authentication"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Prohibit use of default, hard-coded, or other values that do not vary for each installation of the product - especially for separate organizations.", "Effectiveness": "High"}, {"Phase": ["Documentation"], "Description": "Ensure that product documentation clearly emphasizes the presence of default passwords and provides steps for the administrator to change them.", "Effectiveness": "Limited"}, {"Phase": ["Architecture and Design"], "Description": "Force the administrator to change the credential upon installation.", "Effectiveness": "High"}, {"Phase": ["Installation", "Operation"], "Description": "The product administrator could change the defaults upon installation or during operation.", "Effectiveness": "Moderate"}], "DemonstrativeExamples": [{"ID": "DX-153", "Entries": [{"IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."}, {"BodyText": "Multiple OT products used default credentials."}]}], "ObservedExamples": [{"Reference": "CVE-2022-30270", "Description": "Remote Terminal Unit (RTU) uses default credentials for some SSH accounts", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30270"}, {"Reference": "CVE-2022-2336", "Description": "OPC Unified Architecture (OPC UA) industrial automation product has a default password", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-2336"}, {"Reference": "CVE-2021-38759", "Description": "microcontroller board has default password", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-38759"}, {"Reference": "CVE-2021-44480", "Description": "children's smart watch has default passwords allowing attackers to send SMS commands and listen to the device's surroundings", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-44480"}, {"Reference": "CVE-2020-11624", "Description": "surveillance camera has default password for the admin account", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-11624"}, {"Reference": "CVE-2018-15719", "Description": "medical dental records product installs a MySQL database with a blank default password", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-15719"}, {"Reference": "CVE-2014-9736", "Description": "healthcare system for archiving patient images has default passwords for key management and storage databases", "Link": "https://www.cve.org/CVERecord?id=CVE-2014-9736"}, {"Reference": "CVE-2000-1209", "Description": "database product installs admin account with default null password, allowing privileges, as exploited by various worms", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1209"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-25863", "Description": "Open5GS 2.1.3 listens on 0.0.0.0:3000 and has a default password of 1423 for the admin account."}, {"Reference": "CVE-2021-28152", "Description": "Hongdian H8922 3.0.5 devices have an undocumented feature that allows access to a shell as a superuser. To connect, the telnet service is used on port 5188 with the default credentials of root:superzxmn."}, {"Reference": "CVE-2021-30028", "Description": "SOOTEWAY Wi-Fi Range Extender v1.5 was discovered to use default credentials (the admin password for the admin account) to access the TELNET service, allowing attackers to erase/read/write the firmware remotely."}, {"Reference": "CVE-2021-37555", "Description": "TX9 Automatic Food Dispenser v3.2.57 devices allow access to a shell as root/superuser, a related issue to CVE-2019-16734. To connect, the telnet service is used on port 23 with the default password of 059AnkJ for the root account. The user can then download the filesystem through preinstalled BusyBox utilities (e.g., tar and nc)."}, {"Reference": "CVE-2021-42849", "Description": "A weak default password for the serial port was reported in some Lenovo Personal Cloud Storage devices that could allow unauthorized device access to an attacker with physical access."}, {"Reference": "CVE-2022-28321", "Description": "The Linux-PAM package before 1.5.2-6.1 for openSUSE Tumbleweed allows authentication bypass for SSH logins. The pam_access.so module doesn't correctly restrict login if a user tries to connect from an IP address that is not resolvable via DNS. In such conditions, a user with denied access to a machine can still get access. NOTE: the relevance of this issue is largely limited to openSUSE Tumbleweed and openSUSE Factory; it does not affect Linux-PAM upstream."}, {"Reference": "CVE-2022-35198", "Description": "Contract Management System v2.0 contains a weak default password which gives attackers to access database connection information."}, {"Reference": "CVE-2022-4126", "Description": "Use of Default Password vulnerability in ABB RCCMD on Windows, Linux, MacOS allows Try Common or Default Usernames and Passwords.This issue affects RCCMD: before 4.40 230207. "}, {"Reference": "CVE-2022-46411", "Description": "An issue was discovered in Veritas NetBackup Flex Scale through 3.0 and Access Appliance through 8.0.100. A default password is persisted after installation and may be discovered and used to escalate privileges."}, {"Reference": "CVE-2022-47209", "Description": "A support user exists on the device and appears to be a backdoor for Technical Support staff. The default password for this account is \u201csupport\u201d and cannot be changed by a user via any normally accessible means."}, {"Reference": "CVE-2022-44244", "Description": "An authentication bypass in Lin-CMS v0.2.1 allows attackers to escalate privileges to Super Administrator."}]}
{"ID": "1394", "Name": "Use of Default Cryptographic Key", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses a default cryptographic key for potentially critical functionality.", "ExtendedDescription": "It is common practice for products to be designed to use default keys. The rationale is to simplify the manufacturing process or the system administrator's task of installation and deployment into an enterprise. However, if admins do not change the defaults, it is easier for attackers to bypass authentication quickly across multiple organizations.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1392", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Authentication"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Prohibit use of default, hard-coded, or other values that do not vary for each installation of the product - especially for separate organizations.", "Effectiveness": "High"}, {"Phase": ["Architecture and Design"], "Description": "Force the administrator to change the credential upon installation.", "Effectiveness": "High"}, {"Phase": ["Installation", "Operation"], "Description": "The product administrator could change the defaults upon installation or during operation.", "Effectiveness": "Moderate"}], "ObservedExamples": [{"Reference": "CVE-2018-3825", "Description": "cloud cluster management product has a default master encryption key", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-3825"}, {"Reference": "CVE-2016-1561", "Description": "backup storage product has a default SSH public key in the authorized_keys file, allowing root access", "Link": "https://www.cve.org/CVERecord?id=CVE-2016-1561"}, {"Reference": "CVE-2010-2306", "Description": "Intrusion Detection System (IDS) uses the same static, private SSL keys for multiple devices and installations, allowing decryption of SSL traffic", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2306"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-40342", "Description": " In the DES implementation, the affected product versions use a default key for encryption. Successful exploitation allows an attacker to obtain sensitive information and gain access to the network elements that are managed by the affected products versions. This issue affects * FOXMAN-UN product: FOXMAN-UN R16A, FOXMAN-UN R15B, FOXMAN-UN R15A, FOXMAN-UN R14B, FOXMAN-UN R14A, FOXMAN-UN R11B, FOXMAN-UN R11A, FOXMAN-UN R10C, FOXMAN-UN R9C; * UNEM product: UNEM R16A, UNEM R15B, UNEM R15A, UNEM R14B, UNEM R14A, UNEM R11B, UNEM R11A, UNEM R10C, UNEM R9C. List of CPEs: * cpe:2.3:a:hitachienergy:foxman-un:R16A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R15B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R15A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R14B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R14A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R11B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R11A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R10C:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:foxman-un:R9C:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R16A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R15B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R15A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R14B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R14A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R11B:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R11A:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R10C:*:*:*:*:*:*:* * cpe:2.3:a:hitachienergy:unem:R9C:*:*:*:*:*:*:* "}, {"Reference": "CVE-2021-43444", "Description": "ONLYOFFICE all versions as of 2021-11-08 is affected by Incorrect Access Control. Signed document download URLs can be forged due to a weak default URL signing key."}, {"Reference": "CVE-2021-43445", "Description": "ONLYOFFICE all versions as of 2021-11-08 is affected by Incorrect Access Control. An attacker can authenticate with the web socket service of the ONLYOFFICE document editor which is protected by JWT auth by using a default JWT signing key."}, {"Reference": "CVE-2021-35252", "Description": "Common encryption key appears to be used across all deployed instances of Serv-U FTP Server. Because of this an encrypted value that is exposed to an attacker can be simply recovered to plaintext."}, {"Reference": "CVE-2021-43116", "Description": "An Access Control vulnerability exists in Nacos 2.0.3 in the access prompt page; enter username and password, click on login to capture packets and then change the returned package, which lets a malicious user login."}]}
{"ID": "1395", "Name": "Dependency on Vulnerable Third-Party Component", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product has a dependency on a third-party component that contains one or more known vulnerabilities.", "ExtendedDescription": "\n\nMany products are large enough or complex enough that part of their functionality uses libraries, modules, or other intellectual property developed by third parties who are not the product creator. For example, even an entire operating system might be from a third-party supplier in some hardware products. Whether open or closed source, these components may contain publicly known vulnerabilities that could be exploited by adversaries to compromise the product.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "657", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "The product architect or designer might choose a component that is already known to contain vulnerabilities or has a high likelihood of containing vulnerabilities in the future."}, {"Phase": "Implementation", "Note": "For reasons of compatibility or stability, developers might choose a third-party component, such as a library, that is already known to contain vulnerabilities."}, {"Phase": "Patching and Maintenance", "Note": "Since all products contain vulnerabilities, over time, a third-party component will be discovered to have a vulnerability."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Varies by Context"], "Note": "The consequences vary widely, depending on the vulnerabilities that exist in the component; how those vulnerabilities can be \"reached\" by adversaries, as the exploitation paths and attack surface will vary depending on how the component is used; and the criticality of the privilege levels and features for which the product relies on the component."}], "DetectionMethods": [{"Method": "Automated Analysis", "Description": "For software, use Software Composition Analysis (SCA) tools, which automatically analyze products to identify third-party dependencies. Often, SCA tools can be used to link with known vulnerabilities in the dependencies that they detect. There are commercial and open-source alternatives, such as OWASP Dependency-Check [REF-1312]. Many languages or frameworks have package managers with similar capabilities, such as npm audit for JavaScript, pip-audit for Python, govulncheck for Go, and many others. Dynamic methods can detect loading of third-party components.", "Effectiveness": "High", "EffectivenessNotes": "Software Composition Analysis (SCA) tools face a number of technical challenges that can lead to false positives and false negatives. Dynamic methods have other technical challenges."}], "PotentialMitigations": [{"Phase": ["Requirements", "Policy"], "Description": "In some industries such as healthcare [REF-1320] [REF-1322] or technologies such as the cloud [REF-1321], it might be unclear about who is responsible for applying patches for third-party vulnerabilities: the vendor, the operator/customer, or a separate service. Clarifying roles and responsibilities can be important to minimize confusion or unnecessary delay when third-party vulnerabilities are disclosed."}, {"Phase": ["Requirements"], "Description": "Require a Bill of Materials for all components and sub-components of the product. For software, require a Software Bill of Materials (SBOM) [REF-1247] [REF-1311]."}, {"Phase": ["Architecture and Design", "Implementation", "Integration", "Manufacturing"], "Description": "Maintain a Bill of Materials for all components and sub-components of the product. For software, maintain a Software Bill of Materials (SBOM). According to [REF-1247], \"An SBOM is a formal, machine-readable inventory of software components and dependencies, information about those components, and their hierarchical relationships.\""}, {"Phase": ["Operation", "Patching and Maintenance"], "Description": "Actively monitor when a third-party component vendor announces vulnerability patches; fix the third-party component as soon as possible; and make it easy for operators/customers to obtain and apply the patch."}, {"Phase": ["Operation", "Patching and Maintenance"], "Description": "Continuously monitor changes in each of the product's components, especially when the changes indicate new vulnerabilities, end-of-life (EOL) plans, etc."}], "DemonstrativeExamples": [{"ID": "DX-169", "Entries": [{"IntroText": "The \"SweynTooth\" vulnerabilities in Bluetooth Low Energy (BLE) software development kits (SDK) were found to affect multiple Bluetooth System-on-Chip (SoC) manufacturers. These SoCs were used by many products such as medical devices, Smart Home devices, wearables, and other IoT devices. [REF-1314] [REF-1315]"}]}, {"Entries": [{"IntroText": "log4j, a Java-based logging framework, is used in a large number of products, with estimates in the range of 3 billion affected devices [REF-1317]. When the \"log4shell\" (CVE-2021-44228) vulnerability was initially announced, it was actively exploited for remote code execution, requiring urgent mitigation in many organizations. However, it was unclear how many products were affected, as Log4j would sometimes be part of a long sequence of transitive dependencies. [REF-1316]"}]}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}}
{"ID": "14", "Name": "Compiler Removal of Code to Clear Buffers", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Sensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka \"dead store removal.\"", "ExtendedDescription": "\n\nThis compiler optimization error occurs when:\n\n\n  1. Secret data are stored in memory.\n\n  1. The secret data are scrubbed from memory by overwriting its contents.\n\n  1. The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently.\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "733", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Build and Compilation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Access Control"], "Impact": ["Read Memory", "Bypass Protection Mechanism"], "Note": "This weakness will allow data that has not been cleared from memory to be read. If this data contains sensitive password information, then an attacker can read the password and use the information to bypass protection mechanisms."}], "DetectionMethods": [{"Method": "Black Box", "Description": "This specific weakness is impossible to detect using black box methods. While an analyst could examine memory to see that it has not been scrubbed, an analysis of the executable would not be successful. This is because the compiler has already removed the relevant code. Only the source code shows whether the programmer intended to clear the memory or not, so this weakness is indistinguishable from others."}, {"Method": "White Box", "Description": "This weakness is only detectable using white box methods (see black box detection factor). Careful analysis is required to determine if the code is likely to be removed by the compiler."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Store the sensitive data in a \"volatile\" memory location if available."}, {"Phase": ["Build and Compilation"], "Description": "If possible, configure your compiler so that it does not remove dead stores."}, {"Phase": ["Architecture and Design"], "Description": "Where possible, encrypt sensitive data that are used by a software system."}], "DemonstrativeExamples": [{"ID": "DX-200", "Entries": [{"IntroText": "The following code reads a password from the user, uses the password to connect to a back-end mainframe and then attempts to scrub the password from memory using memset()."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tvoid GetData(char *MFAddr) {\n\t\t\tchar pwd[64];\n\t\t\tif (GetPasswordFromUser(pwd, sizeof(pwd))) {\n\t\t\t\t\tif (ConnectToMainframe(MFAddr, pwd)) {\n```\n// Interaction with mainframe* \n\t\t\t\t\t\t\t}}\n\t\t\tmemset(pwd, 0, sizeof(pwd));}"}, {"BodyText": "The code in the example will behave correctly if it is executed verbatim, but if the code is compiled using an optimizing compiler, such as Microsoft Visual C++ .NET or GCC 3.x, then the call to memset() will be removed as a dead store because the buffer pwd is not used after its value is overwritten [18]. Because the buffer pwd contains a sensitive value, the application may be vulnerable to attack if the data are left memory resident. If attackers are able to access the correct region of memory, they may use the recovered password to gain control of the system."}, {"BodyText": "It is common practice to overwrite sensitive data manipulated in memory, such as passwords or cryptographic keys, in order to prevent attackers from learning system secrets. However, with the advent of optimizing compilers, programs do not always behave as their source code alone would suggest. In the example, the compiler interprets the call to memset() as dead code because the memory being written to is not subsequently used, despite the fact that there is clearly a security motivation for the operation to occur. The problem here is that many compilers, and in fact many programming languages, do not take this and other security concerns into consideration in their efforts to improve efficiency."}, {"BodyText": "Attackers typically exploit this type of vulnerability by using a core dump or runtime mechanism to access the memory used by a particular application and recover the secret information. Once an attacker has access to the secret information, it is relatively straightforward to further exploit the system and possibly compromise other resources with which the application interacts."}]}], "AffectedResources": ["Memory"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "140", "Name": "Improper Neutralization of Delimiters", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not neutralize or incorrectly neutralizes delimiters.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Developers should anticipate that delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2003-0307", "Description": "Attacker inserts field separator into input to specify admin privileges.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0307"}, {"Reference": "CVE-2000-0293", "Description": "Multiple internal space, insufficient quoting - program does not use proper delimiter between values.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0293"}, {"Reference": "CVE-2001-0527", "Description": "Attacker inserts carriage returns and \"|\" field separator characters to add new user/privileges.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0527"}, {"Reference": "CVE-2002-0267", "Description": "Linebreak in field of PHP script allows admin privileges when written to data file.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0267"}], "RelatedAttackPatterns": ["15"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "141", "Name": "Improper Neutralization of Parameter/Argument Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as parameter or argument delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that parameter/argument delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2003-0307", "Description": "Attacker inserts field separator into input to specify admin privileges.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0307"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-29872", "Description": "A vulnerability has been identified in SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P850 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00), SICAM P855 (All versions < V3.00). Affected devices do not properly validate parameters of POST requests. This could allow an authenticated attacker to set the device to a denial of service state or to control the program counter and, thus, execute arbitrary code on the device."}]}
{"ID": "1419", "Name": "Incorrect Initialization of Resource", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product attempts to initialize a resource but does not correctly do so, which might leave the resource in an unexpected, incorrect, or insecure state when it is accessed.", "ExtendedDescription": "\n\nThis can have security implications when the associated resource is expected to have certain properties or values. Examples include a variable that determines whether a user has been authenticated or not, or a register or fuse value that determines the security state of the product.\n\n\nFor software, this weakness can frequently occur when implicit initialization is used, meaning the resource is not explicitly set to a specific value. For example, in C, memory is not necessarily cleared when it is allocated on the stack, and many scripting languages use a default empty, null value, or zero value when a variable is not explicitly initialized.\n\n\nFor hardware, this weakness frequently appears with reset values and fuses. After a product reset, hardware may initialize registers incorrectly. During different phases of a product lifecycle, fuses may be set to incorrect values. Even if fuses are set to correct values, the lines to the fuse could be broken or there might be hardware on the fuse line that alters the fuse value to be incorrect.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "665", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Manufacturing"}, {"Phase": "Installation"}, {"Phase": "System Configuration"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory", "Read Application Data", "Unexpected State"], "Likelihood": ["Unknown"]}, {"Scope": ["Authorization", "Integrity"], "Impact": ["Gain Privileges or Assume Identity"]}, {"Scope": ["Other"], "Impact": ["Varies by Context"], "Note": "The technical impact can vary widely based on how the resource is used in the product, and whether its contents affect security decisions."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Choose the safest-possible initialization for security-related resources."}, {"Phase": ["Implementation"], "Description": "Ensure that each resource (whether variable, memory buffer, register, etc.) is fully initialized."}, {"Phase": ["Implementation"], "Description": "Pay close attention to complex conditionals or reset sources that affect initialization, since some paths might not perform the initialization."}, {"Phase": ["Architecture and Design"], "Description": "Ensure that the design and architecture clearly identify what the initialization should be, and that the initialization does not have security implications."}], "DemonstrativeExamples": [{"ID": "DX-162", "Entries": [{"IntroText": "Consider example design module system verilog code shown below. The register_example module is an example parameterized module that defines two parameters, REGISTER_WIDTH and REGISTER_DEFAULT. Register_example module defines a Secure_mode setting, which when set makes the register content read-only and not modifiable by software writes. register_top module instantiates two registers, Insecure_Device_ID_1 and Insecure_Device_ID_2. Generally, registers containing device identifier values are required to be read only to prevent any possibility of software modifying these values."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "// Parameterized Register module example \n // Secure_mode : REGISTER_DEFAULT[0] : When set to 1 register is read only and not writable// \n module register_example \n #( \n parameter REGISTER_WIDTH = 8, // Parameter defines width of register, default 8 bits \n parameter [REGISTER_WIDTH-1:0] REGISTER_DEFAULT = 2**REGISTER_WIDTH -2 // Default value of register computed from Width. Sets all bits to 1s except bit 0 (Secure _mode) \n ) \n ( \n input [REGISTER_WIDTH-1:0] Data_in, \n input Clk, \n input resetn, \n input write, \n output reg [REGISTER_WIDTH-1:0] Data_out \n ); \n\n reg Secure_mode; \n\n always @(posedge Clk or negedge resetn) \n\n```\n\t if (~resetn) \n\t begin \n\t\t Data_out <= REGISTER_DEFAULT; // Register content set to Default at reset \n\t\t Secure_mode <= REGISTER_DEFAULT[0]; // Register Secure_mode set at reset \n\t end \n\t else if (write & ~Secure_mode) \n\t begin \n\t\t Data_out <= Data_in; \n\t end \n endmodule \n module register_top \n ( \n input Clk, \n input resetn, \n input write, \n input [31:0] Data_in, \n output reg [31:0] Secure_reg, \n output reg [31:0] Insecure_reg \n ); \n register_example #( \n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1224) // Incorrect Default value used bit 0 is 0. \n ) Insecure_Device_ID_1 ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n register_example #(\n\t .REGISTER_WIDTH (32) // Default not defined 2^32-2 value will be used as default. \n ) Insecure_Device_ID_2 ( \n\t .Data_in (Data_in), \n\t .Data_out (Insecure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n endmodule \n```"}, {"BodyText": "These example instantiations show how, in a hardware design, it would be possible to instantiate the register module with insecure defaults and parameters."}, {"BodyText": "In the example design, both registers will be software writable since Secure_mode is defined as zero."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "register_example #( \n\n```\n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1225) // Correct default value set, to enable Secure_mode \n ) Secure_Device_ID_example ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n );\n```"}]}, {"ID": "DX-163", "Entries": [{"IntroText": "This code attempts to login a user using credentials from a POST request:"}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n```\n// $user and $pass automatically set from POST request* \n\tif (login_user($user,$pass)) {\n\t```\n\t\t$authorized = true;\n\t}\n```\n...* \n\t\n\tif ($authorized) {\n\t```\n\t\tgeneratePage();\n\t}\n```"}, {"BodyText": "Because the $authorized variable is never initialized, PHP will automatically set $authorized to any value included in the POST request if register_globals is enabled. An attacker can send a POST request with an unexpected third value 'authorized' set to 'true' and gain authorized status without supplying valid credentials."}, {"BodyText": "Here is a fixed version:"}, {"Nature": "Good", "Language": "PHP", "ExampleCode": "```\n\t$user = $_POST['user'];\n\t$pass = $_POST['pass'];\n\t$authorized = false;\n\tif (login_user($user,$pass)) {\n\t\t$authorized = true;\n\t}\n```\n...*"}, {"BodyText": "This code avoids the issue by initializing the $authorized variable to false and explicitly retrieving the login credentials from the $_POST variable. Regardless, register_globals should never be enabled and is disabled by default in current versions of PHP."}]}, {"ID": "DX-222", "Entries": [{"IntroText": "The following example code is excerpted from the Access Control module, acct_wrapper, in the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Within this module, a set of memory-mapped I/O registers, referred to as acct_mem, each 32-bit wide, is utilized to store access control permissions for peripherals [REF-1437]. Access control registers are typically used to define and enforce permissions and access rights for various system resources."}, {"BodyText": "However, in the buggy SoC, these registers are all enabled at reset, i.e., essentially granting unrestricted access to all system resources [REF-1438]. This will introduce security vulnerabilities and risks to the system, such as privilege escalation or exposing sensitive information to unauthorized users or processes."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni && ~rst_6))\n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j < AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] <= 32'hffffffff;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."}, {"BodyText": "To fix this issue, the access control registers must be properly initialized during the reset phase of the SoC. Correct initialization values should be established to maintain the system's integrity, security, predictable behavior, and allow proper control of peripherals. The specifics of what values should be set depend on the SoC's design and the requirements of the system. To address the problem depicted in the bad code example [REF-1438], the default value for \"acct_mem\" should be set to 32'h00000000 (see good code example [REF-1439]). This ensures that during startup or after any reset, access to protected data is restricted until the system setup is complete and security procedures properly configure the access control settings."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni && ~rst_6)) \n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j < AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] <= 32'h00000000;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."}]}], "ObservedExamples": [{"Reference": "CVE-2020-27211", "Description": "Chain: microcontroller system-on-chip uses a register value stored in flash to set product protection state on the memory bus and does not contain protection against fault injection (CWE-1319) which leads to an incorrect initialization of the memory bus (CWE-1419) causing the product to be in an unprotected state.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-27211"}, {"Reference": "CVE-2023-25815", "Description": "chain: a change in an underlying package causes the gettext function to use implicit initialization with a hard-coded path (CWE-1419) under the user-writable C:\\ drive, introducing an untrusted search path element (CWE-427) that enables spoofing of messages.", "Link": "https://www.cve.org/CVERecord?id=CVE-2023-25815"}, {"Reference": "CVE-2022-43468", "Description": "WordPress module sets internal variables based on external inputs, allowing false reporting of the number of views", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-43468"}, {"Reference": "CVE-2022-36349", "Description": "insecure default variable initialization in BIOS firmware for a hardware board allows DoS", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-36349"}, {"Reference": "CVE-2015-7763", "Description": "distributed filesystem only initializes part of the variable-length padding for a packet, allowing attackers to read sensitive information from previously-sent packets in the same memory location", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-7763"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}}
{"ID": "142", "Name": "Improper Neutralization of Value Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as value delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that value delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2000-0293", "Description": "Multiple internal space, insufficient quoting - program does not use proper delimiter between values.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0293"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1420", "Name": "Exposure of Sensitive Information during Transient Execution", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "A processor event or prediction may allow incorrect operations (or correct operations with incorrect data) to execute transiently, potentially exposing data over a covert channel.", "ExtendedDescription": "\n\nWhen operations execute but do not commit to the processor's architectural state, this is commonly referred to as transient execution. This behavior can occur when the processor mis-predicts an outcome (such as a branch target), or when a processor event (such as an exception or microcode assist, etc.) is handled after younger operations have already executed. Operations that execute transiently may exhibit observable discrepancies (CWE-203) in covert channels [REF-1400] such as data caches. Observable discrepancies of this kind can be detected and analyzed using timing or power analysis techniques, which may allow an attacker to infer information about the operations that executed transiently. For example, the attacker may be able to infer confidential data that was accessed or used by those operations.\n\n\nTransient execution weaknesses may be exploited using one of two methods. In the first method, the attacker generates a code sequence that exposes data through a covert channel when it is executed transiently (the attacker must also be able to trigger transient execution). Some transient execution weaknesses can only expose data that is accessible within the attacker's processor context. For example, an attacker executing code in a software sandbox may be able to use a transient execution weakness to expose data within the same address space, but outside of the attacker's sandbox. Other transient execution weaknesses can expose data that is architecturally inaccessible, that is, data protected by hardware-enforced boundaries such as page tables or privilege rings. These weaknesses are the subject of CWE-1421.\n\n\nIn the second exploitation method, the attacker first identifies a code sequence in a victim program that, when executed transiently, can expose data that is architecturally accessible within the victim's processor context. For instance, the attacker may search the victim program for code sequences that resemble a bounds-check bypass sequence (see Demonstrative Example 1). If the attacker can trigger a mis-prediction of the conditional branch and influence the index of the out-of-bounds array access, then the attacker may be able to infer the value of out-of-bounds data by monitoring observable discrepancies in a covert channel.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "669", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "This weakness can be introduced when a computing unit (such as a CPU, GPU, accelerator, or any other processor) uses out-of-order execution, speculation, or any other microarchitectural feature that can allow microarchitectural operations to execute without committing to architectural state."}, {"Phase": "Implementation", "Note": "This weakness can be introduced when sandboxes or managed runtimes are not properly isolated by using hardware-enforced boundaries. Developers of sandbox or managed runtime software should exercise caution when relying on software techniques (such as bounds checking) to prevent code in one sandbox from accessing confidential data in another sandbox. For example, an attacker sandbox may be able to trigger a processor event or mis-prediction in a manner that allows it to transiently read a victim sandbox's private data."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected in hardware by manually inspecting processor specifications. Features that exhibit this weakness may include microarchitectural predictors, access control checks that occur out-of-order, or any other features that can allow operations to execute without committing to architectural state. Academic researchers have demonstrated that new hardware weaknesses can be discovered by exhaustively analyzing a processor's machine clear (or nuke) conditions ([REF-1427]).\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nHardware designers can also scrutinize aspects of the instruction set architecture that have undefined behavior; these can become a focal point when applying other detection methods.\n\n\nManual analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage.\n"}, {"Method": "Fuzzing", "Description": "\n\nAcademic researchers have demonstrated that this weakness can be detected in hardware using software fuzzing tools that treat the underlying hardware as a black box ([REF-1428]).\n", "Effectiveness": "Opportunistic", "EffectivenessNotes": "\n\nFuzzing may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage.\n"}, {"Method": "Fuzzing", "Description": "\n\nAcademic researchers have demonstrated that this weakness can be detected in software using software fuzzing tools ([REF-1429]).\n", "Effectiveness": "Opportunistic", "EffectivenessNotes": "\n\nAt the time of this writing, publicly available software fuzzing tools can only detect a subset of transient execution weaknesses in software (for example, [REF-1429] can only detect instances of Spectre v1) and may produce false positives.\n"}, {"Method": "Automated Static Analysis", "Description": "\n\nA variety of automated static analysis tools can identify potentially exploitable code sequences in software. These tools may perform the analysis on source code, on binary code, or on an intermediate code representation (for example, during compilation).\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nAt the time of this writing, publicly available software static analysis tools can only detect a subset of transient execution weaknesses in software and may produce false positives.\n"}, {"Method": "Automated Analysis", "Description": "\n\nSoftware vendors can release tools that detect presence of known weaknesses on a processor. For example, some of these tools can attempt to transiently execute a vulnerable code sequence and detect whether code successfully leaks data in a manner consistent with the weakness under test. Alternatively, some hardware vendors provide enumeration for the presence of a weakness (or lack of a weakness). These enumeration bits can be checked and reported by system software. For example, Linux supports these checks for many commodity processors:\n\n\n$ cat /proc/cpuinfo | grep bugs | head -n 1\n\n\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed\n", "Effectiveness": "High", "EffectivenessNotes": "\n\nThis method can be useful for detecting whether a processor is affected by known weaknesses, but it may not be useful for detecting unknown weaknesses.\n"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "The hardware designer can attempt to prevent transient execution from causing observable discrepancies in specific covert channels.", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique has many pitfalls. For example, InvisiSpec was an early attempt to mitigate this weakness by blocking \"micro-architectural covert and side channels through the multiprocessor data cache hierarchy due to speculative loads\" [REF-1417]. Commodity processors and SoCs have many covert and side channels that exist outside of the data cache hierarchy. Even when some of these channels are blocked, others (such as execution ports [REF-1418]) may allow an attacker to infer confidential data. Mitigation strategies that attempt to prevent transient execution from causing observable discrepancies also have other pitfalls, for example, see [REF-1419].\n"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers may expose instructions or other architectural features that allow software to mitigate the effects of transient execution, but without disabling predictors. These features may also help to limit opportunities for data exposure.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nInstructions or features that constrain transient execution or suppress its side effects may impact performance.\n"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers may expose registers (for example, control registers or model-specific registers) that allow privileged and/or user software to disable specific predictors or other hardware features that can cause confidential data to be exposed during transient execution.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nDisabling specific predictors or other hardware features may result in significant performance overhead.\n"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers, system software vendors, or other agents may choose to restrict the ability of unprivileged software to access to high-resolution timers that are commonly used to monitor covert channels.\n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "\n\nSpecific software algorithms can be used by an attacker to compensate for a lack of a high-resolution time source [REF-1420].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIsolate sandboxes or managed runtimes in separate address spaces (separate processes). For examples, see [REF-1421].\n", "Effectiveness": "High"}, {"Phase": ["Build and Compilation"], "Description": "\n\nInclude serialization instructions (for example, LFENCE) that prevent processor events or mis-predictions prior to the serialization instruction from causing transient execution after the serialization instruction. For some weaknesses, a serialization instruction can also prevent a processor event or a mis-prediction from occurring after the serialization instruction (for example, CVE-2018-3639 can allow a processor to predict that a load will not depend on an older store; a serialization instruction between the store and the load may allow the store to update memory and prevent the prediction from happening at all).\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nWhen used to comprehensively mitigate a transient execution weakness (for example, by inserting an LFENCE after every instruction in a program), serialization instructions can introduce significant performance overhead. On the other hand, when used to mitigate only a relatively small number of high-risk code sequences, serialization instructions may have a low or negligible impact on performance.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse control-flow integrity (CFI) techniques to constrain the behavior of instructions that redirect the instruction pointer, such as indirect branch instructions.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nSome CFI techniques may not be able to constrain transient execution, even though they are effective at constraining architectural execution. Or they may be able to provide some additional protection against a transient execution weakness, but without comprehensively mitigating the weakness. For example, Clang-CFI provides strong architectural CFI properties and can make some transient execution weaknesses more difficult to exploit [REF-1398].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIf the weakness is exposed by a single instruction (or a small set of instructions), then the compiler (or JIT, etc.) can be configured to prevent the affected instruction(s) from being generated, and instead generate an alternate sequence of instructions that is not affected by the weakness. One prominent example of this mitigation is retpoline ([REF-1414]).\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique may only be effective for software that is compiled with this mitigation. For some transient execution weaknesses, this technique may not be sufficient to protect software that is compiled without the affected instruction(s). For example, see CWE-1421.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques that can mitigate the consequences of transient execution. For example, address masking can be used in some circumstances to prevent out-of-bounds transient reads.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nAddress masking and related software mitigation techniques have been used to harden specific code sequences that could potentially be exploited via transient execution. For example, the Linux kernel makes limited use of manually inserted address masks to mitigate bounds-check bypass [REF-1390]. Compiler-based techniques have also been used to automatically harden software [REF-1425].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques (including the use of serialization instructions) that are intended to reduce the number of instructions that can be executed transiently after a processor event or misprediction.\n", "Effectiveness": "Incidental", "EffectivenessNotes": "\n\nSome transient execution weaknesses can be exploited even if a single instruction is executed transiently after a processor event or mis-prediction. This mitigation strategy has many other pitfalls that prevent it from eliminating this weakness entirely. For example, see [REF-1389].\n"}, {"Phase": ["Documentation"], "Description": "\n\nIf a hardware feature can allow incorrect operations (or correct operations with incorrect data) to execute transiently, the hardware designer may opt to disclose this behavior in architecture documentation. This documentation can inform users about potential consequences and effective mitigations.\n", "Effectiveness": "High"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Secure programs perform bounds checking before accessing an array if the source of the array index is provided by an untrusted source such as user input. In the code below, data from array1 will not be accessed if x is out of bounds. The following code snippet is from [REF-1415]:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tif (x < array1_size)\n\t\ty = array2[array1[x] * 4096];\n```"}, {"BodyText": "However, if this code executes on a processor that performs conditional branch prediction the outcome of the if statement could be mis-predicted and the access on the next line will occur with a value of x that can point to an out-of-bounds location (within the program's memory).\n\n\nEven though the processor does not commit the architectural effects of the mis-predicted branch, the memory accesses alter data cache state, which is not rolled back after the branch is resolved. The cache state can reveal array1[x] thereby providing a mechanism to recover the data value located at address array1 + x."}]}, {"Entries": [{"IntroText": "Some managed runtimes or just-in-time (JIT) compilers may overwrite recently executed code with new code. When the instruction pointer enters the new code, the processor may inadvertently execute the stale code that had been overwritten. This can happen, for instance, when the processor issues a store that overwrites a sequence of code, but the processor fetches and executes the (stale) code before the store updates memory. Similar to the first example, the processor does not commit the stale code's architectural effects, though microarchitectural side effects can persist. Hence, confidential information accessed or used by the stale code may be inferred via an observable discrepancy in a covert channel. This vulnerability is described in more detail in [REF-1427]."}]}], "ObservedExamples": [{"Reference": "CVE-2017-5753", "Description": "Microarchitectural conditional branch predictors may allow operations to execute transiently after a misprediction, potentially exposing data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5753"}, {"Reference": "CVE-2021-0089", "Description": "A machine clear triggered by self-modifying code may allow incorrect operations to execute transiently, potentially exposing data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-0089"}, {"Reference": "CVE-2022-0002", "Description": "Microarchitectural indirect branch predictors may allow incorrect operations to execute transiently after a misprediction, potentially exposing data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-0002"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "\n\nA vulnerability should only map to CWE-1420 if it cannot map to any of CWE-1420's child weaknesses. Follow this diagram:\n\n", "Reasons": ["Acceptable-Use"]}}
{"ID": "1421", "Name": "Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "\n\t\t\tA processor event may allow transient operations to access\n\t\t\tarchitecturally restricted data (for example, in another address\n\t\t\tspace) in a shared microarchitectural structure (for example, a CPU\n\t\t\tcache), potentially exposing the data over a covert channel.\n\t\t  ", "ExtendedDescription": "\n\nMany commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.\n\n\nMany commodity processors also share microarchitectural resources that cache (temporarily store) data, which may be confidential. These resources may be shared across processor contexts, including across SMT threads, privilege rings, or others.\n\n\nWhen transient operations allow access to ISA-protected data in a shared microarchitectural resource, this might violate users' expectations of the ISA feature that is bypassed. For example, if transient operations can access a victim's private data in a shared microarchitectural resource, then the operations' microarchitectural side effects may correspond to the accessed data. If an attacker can trigger these transient operations and observe their side effects through a covert channel [REF-1400], then the attacker may be able to infer the victim's private data. Private data could include sensitive program data, OS/VMM data, page table data (such as memory addresses), system configuration data (see Demonstrative Example 3), or any other data that the attacker does not have the required privileges to access.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1420", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1420", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "\n\nThis weakness can be introduced during hardware architecture and design if a data path allows architecturally restricted data to propagate to operations that execute before an older mis-prediction or processor event (such as an exception) is caught.\n"}, {"Phase": "Implementation", "Note": "\n\nThis weakness can be introduced during system software implementation if state-sanitizing operations are not invoked when switching from one context to another, according to the hardware vendor's recommendations for mitigating the weakness.\n"}, {"Phase": "System Configuration", "Note": "\n\nThis weakness can be introduced if the system has not been configured according to the hardware vendor's recommendations for mitigating the weakness.\n"}, {"Phase": "Architecture and Design", "Note": "\n\nThis weakness can be introduced when an access control check (for example, checking page permissions) can proceed in parallel with the access operation (for example, a load) that is being checked. If the processor can allow the access operation to execute before the check completes, this race condition may allow subsequent transient operations to expose sensitive information.\n"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Likelihood": ["Medium"], "Note": "\n\n<<put the information here>>\n"}], "DetectionMethods": [{"Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected in hardware by manually inspecting processor specifications. Features that exhibit this weakness may include microarchitectural predictors, access control checks that occur out-of-order, or any other features that can allow operations to execute without committing to architectural state. Academic researchers have demonstrated that new hardware weaknesses can be discovered by examining publicly available patent filings, for example [REF-1405] and [REF-1406]. Hardware designers can also scrutinize aspects of the instruction set architecture that have undefined behavior; these can become a focal point when applying other detection methods. \n", "Effectiveness": "Moderate", "EffectivenessNotes": "Manual analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}, {"Method": "Automated Analysis", "Description": "\n\nThis weakness can be detected (pre-discovery) in hardware by employing static or dynamic taint analysis methods [REF-1401]. These methods can label data in one context (for example, kernel data) and perform information flow analysis (or a simulation, etc.) to determine whether tainted data can appear in another context (for example, user mode). Alternatively, stale or invalid data in shared microarchitectural resources can be marked as tainted, and the taint analysis framework can identify when transient operations encounter tainted data.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "Automated static or dynamic taint analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}, {"Method": "Automated Analysis", "Description": "\n\nSoftware vendors can release tools that detect presence of known weaknesses (post-discovery) on a processor. For example, some of these tools can attempt to transiently execute a vulnerable code sequence and detect whether code successfully leaks data in a manner consistent with the weakness under test. Alternatively, some hardware vendors provide enumeration for the presence of a weakness (or lack of a weakness). These enumeration bits can be checked and reported by system software. For example, Linux supports these checks for many commodity processors:\n\n\n$ cat /proc/cpuinfo | grep bugs | head -n 1\n\n\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed\n", "Effectiveness": "High", "EffectivenessNotes": "This method can be useful for detecting whether a processor if affected by known weaknesses, but it may not be useful for detecting unknown weaknesses."}, {"Method": "Fuzzing", "Description": "Academic researchers have demonstrated that this weakness can be detected in hardware using software fuzzing tools that treat the underlying hardware as a black box ([REF-1406], [REF-1430])", "Effectiveness": "Opportunistic", "EffectivenessNotes": "Fuzzing may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\nHardware designers may choose to engineer the processor's pipeline to prevent architecturally restricted data from being used by operations that can execute transiently.\n", "Effectiveness": "High"}, {"Phase": ["Architecture and Design"], "Description": "\n\nHardware designers may choose not to share microarchitectural resources that can contain sensitive data, such as fill buffers and store buffers.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nThis can be highly effective at preventing this weakness from being exposed across different SMT threads or different processor cores. It is generally less practical to isolate these resources between different contexts (for example, user and kernel) that may execute on the same SMT thread or processor core.\n"}, {"Phase": ["Architecture and Design"], "Description": "\n\nHardware designers may choose to sanitize specific microarchitectural state (for example, store buffers) when the processor transitions to a different context, such as whenever a system call is invoked. Alternatively, the hardware may expose instruction(s) that allow software to sanitize microarchitectural state according to the user or system administrator's threat model. These mitigation approaches are similar to those that address CWE-226; however, sanitizing microarchitectural state may not be the optimal or best way to mitigate this weakness on every processor design.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nSanitizing shared state on context transitions may not be practical for all processors, especially when the amount of shared state affected by the weakness is relatively large. Additionally, this technique may not be practical unless there is a synchronous transition between two processor contexts that would allow the affected resource to be sanitized. For example, this technique alone may not suffice to mitigate asynchronous access to a resource that is shared by two SMT threads.\n"}, {"Phase": ["Architecture and Design"], "Description": "\n\nThe hardware designer can attempt to prevent transient execution from causing observable discrepancies in specific covert channels.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique has many pitfalls. For example, InvisiSpec was an early attempt to mitigate this weakness by blocking \"micro-architectural covert and side channels through the multiprocessor data cache hierarchy due to speculative loads\" [REF-1417]. Commodity processors and SoCs have many covert and side channels that exist outside of the data cache hierarchy. Even when some of these channels are blocked, others (such as execution ports [REF-1418]) may allow an attacker to infer confidential data. Mitigation strategies that attempt to prevent transient execution from causing observable discrepancies also have other pitfalls, for example, see [REF-1419].\n"}, {"Phase": ["Architecture and Design"], "Description": "\n\nSoftware architects may design software to enforce strong isolation between different contexts. For example, kernel page table isolation (KPTI) mitigates the Meltdown vulnerability [REF-1401] by separating user-mode page tables from kernel-mode page tables, which prevents user-mode processes from using Meltdown to transiently access kernel memory [REF-1404].\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nIsolating different contexts across a process boundary (or another kind of architectural boundary) may only be effective for some weaknesses.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIf the weakness is exposed by a single instruction (or a small set of instructions), then the compiler (or JIT, etc.) can be configured to prevent the affected instruction(s) from being generated, and instead generate an alternate sequence of instructions that is not affected by the weakness.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique may only be fully effective if it is applied to all software that runs on the system. Also, relatively few observed examples of this weakness have exposed data through only a single instruction.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques (including the use of serialization instructions) that are intended to reduce the number of instructions that can be executed transiently after a processor event or misprediction.\n", "Effectiveness": "Incidental", "EffectivenessNotes": "\n\nSome transient execution weaknesses can be exploited even if a single instruction is executed transiently after a processor event or mis-prediction. This mitigation strategy has many other pitfalls that prevent it from eliminating this weakness entirely. For example, see [REF-1389].\n"}, {"Phase": ["Implementation"], "Description": "\n\nSystem software can mitigate this weakness by invoking state-sanitizing operations when switching from one context to another, according to the hardware vendor's recommendations.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique may not be able to mitigate weaknesses that arise from resource sharing across SMT threads.\n"}, {"Phase": ["System Configuration"], "Description": "\n\nSome systems may allow the user to disable (for example, in the BIOS) sharing of the affected resource.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nDisabling resource sharing (for example, by disabling SMT) may result in significant performance overhead.\n"}, {"Phase": ["System Configuration"], "Description": "\n\nSome systems may allow the user to disable (for example, in the BIOS) microarchitectural features that allow transient access to architecturally restricted data.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nDisabling microarchitectural features such as predictors may result in significant performance overhead.\n"}, {"Phase": ["Patching and Maintenance"], "Description": "\n\nThe hardware vendor may provide a patch to sanitize the affected shared microarchitectural state when the processor transitions to a different context.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nThis technique may not be able to mitigate weaknesses that arise from resource sharing across SMT threads.\n"}, {"Phase": ["Patching and Maintenance"], "Description": "\n\nThis kind of patch may not be feasible or implementable for all processors or all weaknesses.\n", "Effectiveness": "Limited"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers, system software vendors, or other agents may choose to restrict the ability of unprivileged software to access to high-resolution timers that are commonly used to monitor covert channels.\n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "\n\nSpecific software algorithms can be used by an attacker to compensate for a lack of a high-resolution time source [REF-1420].\n"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Some processors may perform access control checks in parallel with memory read/write operations. For example, when a user-mode program attempts to read data from memory, the processor may also need to check whether the memory address is mapped into user space or kernel space. If the processor performs the access concurrently with the check, then the access may be able to transiently read kernel data before the check completes. This race condition is demonstrated in the following code snippet from [REF-1408], with additional annotations:"}, {"Nature": "Bad", "Language": "x86 Assembly", "ExampleCode": "1 ; rcx = kernel address, rbx = probe array\n 2 xor rax, rax # set rax to 0\n 3 retry:\n 4 mov al, byte [rcx] # attempt to read kernel memory\n 5 shl rax, 0xc # multiply result by page size (4KB)\n 6 jz retry # if the result is zero, try again\n 7 mov rbx, qword [rbx + rax] # transmit result over a cache covert channel"}, {"BodyText": "Vulnerable processors may return kernel data from a shared microarchitectural resource in line 4, for example, from the processor's L1 data cache. Since this vulnerability involves a race condition, the mov in line 4 may not always return kernel data (that is, whenever the check \"wins\" the race), in which case this demonstration code re-attempts the access in line 6. The accessed data is multiplied by 4KB, a common page size, to make it easier to observe via a cache covert channel after the transmission in line 7. The use of cache covert channels to observe the side effects of transient execution has been described in [REF-1408]."}]}, {"Entries": [{"IntroText": "Many commodity processors share microarchitectural fill buffers between sibling hardware threads on simultaneous multithreaded (SMT) processors. Fill buffers can serve as temporary storage for data that passes to and from the processor's caches. Microarchitectural Fill Buffer Data Sampling (MFBDS) is a vulnerability that can allow a hardware thread to access its sibling's private data in a shared fill buffer. The access may be prohibited by the processor's ISA, but MFBDS can allow the access to occur during transient execution, in particular during a faulting operation or an operation that triggers a microcode assist.\n\n\nMore information on MFBDS can be found in [REF-1405] and [REF-1409]."}]}, {"Entries": [{"IntroText": "Some processors may allow access to system registers (for example, system coprocessor registers or model-specific registers) during transient execution. This scenario is depicted in the code snippet below. Under ordinary operating circumstances, code in exception level 0 (EL0) is not permitted to access registers that are restricted to EL1, such as TTBR0_EL1. However, on some processors an earlier mis-prediction can cause the MRS instruction to transiently read the value in an EL1 register. In this example, a conditional branch (line 2) can be mis-predicted as \"not taken\" while waiting for a slow load (line 1). This allows MRS (line 3) to transiently read the value in the TTBR0_EL1 register. The subsequent memory access (line 6) can allow the restricted register's value to become observable, for example, over a cache covert channel.\n\n\nCode snippet is from [REF-1410]. See also [REF-1411]."}, {"Nature": "Bad", "Language": "x86 Assembly", "ExampleCode": "1 LDR X1, [X2] ; arranged to miss in the cache\n 2 CBZ X1, over ; This will be taken \n 3 MRS X3, TTBR0_EL1; \n 4 LSL X3, X3, #imm \n 5 AND X3, X3, #0xFC0\n 6 LDR X5, [X6,X3] ; X6 is an EL0 base address\n 7 over"}]}], "ObservedExamples": [{"Reference": "CVE-2017-5715", "Description": "A fault may allow transient user-mode operations to access kernel data cached in the L1D, potentially exposing the data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5715"}, {"Reference": "CVE-2018-3615", "Description": "A fault may allow transient non-enclave operations to access SGX enclave data cached in the L1D, potentially exposing the data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-3615"}, {"Reference": "CVE-2019-1135", "Description": "A TSX Asynchronous Abort may allow transient operations to access architecturally restricted data, potentially exposing the data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-1135"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities", "Comments": "If a weakness can potentially be exploited to infer data that is accessible inside or outside the current processor context, then the weakness could map to CWE-1421 and to another CWE such as CWE-1420.", "Reasons": ["Acceptable-Use"]}}
{"ID": "1422", "Name": "Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "A processor event or prediction may allow incorrect or stale data to\n\t\t  be forwarded to transient operations, potentially exposing data over a\n\t\t  covert channel.", "ExtendedDescription": "\n\nSoftware may use a variety of techniques to preserve the confidentiality of private data that is accessible within the current processor context. For example, the memory safety and type safety properties of some high-level programming languages help to prevent software written in those languages from exposing private data. As a second example, software sandboxes may co-locate multiple users' software within a single process. The processor's Instruction Set Architecture (ISA) may permit one user's software to access another user's data (because the software shares the same address space), but the sandbox prevents these accesses by using software techniques such as bounds checking.\n\n\nIf incorrect or stale data can be forwarded (for example, from a cache) to transient operations, then the operations' microarchitectural side effects may correspond to the data. If an attacker can trigger these transient operations and observe their side effects through a covert channel, then the attacker may be able to infer the data. For example, an attacker process may induce transient execution in a victim process that causes the victim to inadvertently access and then expose its private data via a covert channel. In the software sandbox example, an attacker sandbox may induce transient execution in its own code, allowing it to transiently access and expose data in a victim sandbox that shares the same address space.\n\n\nConsequently, weaknesses that arise from incorrect/stale data forwarding might violate users' expectations of software-based memory safety and isolation techniques. If the data forwarding behavior is not properly documented by the hardware vendor, this might violate the software vendor's expectation of how the hardware should behave.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1420", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1420", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "\n\nThis weakness can be introduced by data speculation techniques, or when the processor pipeline is designed to check exception conditions concurrently with other operations. This weakness can also persist after a CWE-1421 weakness has been mitigated. For example, suppose that a processor can forward stale data from a shared microarchitectural buffer to dependent transient operations, and furthermore suppose that the processor has been patched to flush the buffer on context switches. This mitigates the CWE-1421 weakness, but the stale-data forwarding behavior may persist as a CWE-1422 weakness unless this behavior is also patched.\n"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Automated Static Analysis", "Description": "\n\nA variety of automated static analysis tools can identify potentially exploitable code sequences in software. These tools may perform the analysis on source code, on binary code, or on an intermediate code representation (for example, during compilation).\n", "Effectiveness": "Moderate", "EffectivenessNotes": "Automated static analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}, {"Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected in hardware by manually inspecting processor specifications. Features that exhibit this weakness may include microarchitectural predictors, access control checks that occur out-of-order, or any other features that can allow operations to execute without committing to architectural state.Hardware designers can also scrutinize aspects of the instruction set architecture that have undefined behavior; these can become a focal point when applying other detection methods. \n", "Effectiveness": "Moderate", "EffectivenessNotes": "Manual analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}, {"Method": "Automated Analysis", "Description": "\n\nSoftware vendors can release tools that detect presence of known weaknesses on a processor. For example, some of these tools can attempt to transiently execute a vulnerable code sequence and detect whether code successfully leaks data in a manner consistent with the weakness under test. Alternatively, some hardware vendors provide enumeration for the presence of a weakness (or lack of a weakness). These enumeration bits can be checked and reported by system software. For example, Linux supports these checks for many commodity processors:\n\n\n$ cat /proc/cpuinfo | grep bugs | head -n 1\n\n\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed\n", "Effectiveness": "High", "EffectivenessNotes": "This method can be useful for detecting whether a processor if affected by known weaknesses, but it may not be useful for detecting unknown weaknesses."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\nThe hardware designer can attempt to prevent transient execution from causing observable discrepancies in specific covert channels.\n", "Effectiveness": "Limited", "EffectivenessNotes": "Instructions or features that constrain transient execution or suppress its side effects may impact performance."}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers, system software vendors, or other agents may choose to restrict the ability of unprivileged software to access to high-resolution timers that are commonly used to monitor covert channels.\n", "Effectiveness": "Defense in Depth", "EffectivenessNotes": "Disabling specific predictors or other hardware features may result in significant performance overhead."}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers may expose instructions or other architectural features that allow software to mitigate the effects of transient execution, but without disabling predictors. These features may also help to limit opportunities for data exposure.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nInstructions or features that constrain transient execution or suppress its side effects may impact performance.\n"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers may expose registers (for example, control registers or model-specific registers) that allow privileged and/or user software to disable specific predictors or other hardware features that can cause confidential data to be exposed during transient execution.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nDisabling specific predictors or other hardware features may result in significant performance overhead.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques (including the use of serialization instructions) that are intended to reduce the number of instructions that can be executed transiently after a processor event or misprediction.\n", "Effectiveness": "Incidental", "EffectivenessNotes": "\n\nSome transient execution weaknesses can be exploited even if a single instruction is executed transiently after a processor event or mis-prediction. This mitigation strategy has many other pitfalls that prevent it from eliminating this weakness entirely. For example, see [REF-1389].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIsolate sandboxes or managed runtimes in separate address spaces (separate processes).\n", "Effectiveness": "High", "EffectivenessNotes": "\n\nProcess isolation is also an effective strategy to mitigate many other kinds of weaknesses.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nInclude serialization instructions (for example, LFENCE) that prevent processor events or mis-predictions prior to the serialization instruction from causing transient execution after the serialization instruction. For some weaknesses, a serialization instruction can also prevent a processor event or a mis-prediction from occurring after the serialization instruction (for example, CVE-2018-3639 can allow a processor to predict that a load will not depend on an older store; a serialization instruction between the store and the load may allow the store to update memory and prevent the mis-prediction from happening at all).\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nWhen used to comprehensively mitigate a transient execution weakness, serialization instructions can introduce significant performance overhead.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques that can mitigate the consequences of transient execution. For example, address masking can be used in some circumstances to prevent out-of-bounds transient reads.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nAddress masking and related software mitigation techniques have been used to harden specific code sequences that could potentially be exploited via transient execution. For example, the Linux kernel makes limited use of this technique to mitigate bounds-check bypass [REF-1390].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIf the weakness is exposed by a single instruction (or a small set of instructions), then the compiler (or JIT, etc.) can be configured to prevent the affected instruction(s) from being generated, and instead generate an alternate sequence of instructions that is not affected by the weakness.\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique is only effective for software that is compiled with this mitigation.\n"}, {"Phase": ["Documentation"], "Description": "\n\nIf a hardware feature can allow incorrect or stale data to be forwarded to transient operations, the hardware designer may opt to disclose this behavior in architecture documentation. This documentation can inform users about potential consequences and effective mitigations.\n", "Effectiveness": "High"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Faulting loads in a victim domain may trigger incorrect transient forwarding, which leaves secret-dependent traces in the microarchitectural state. Consider this code sequence example from [REF-1391]."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "void call_victim(size_t untrusted_arg) {\n\n```\n\t *arg_copy = untrusted_arg;\n\t array[**trusted_ptr * 4096];\n }\n```"}, {"BodyText": "A processor with this weakness will store the value of untrusted_arg (which may be provided by an attacker) to the stack, which is trusted memory. Additionally, this store operation will save this value in some microarchitectural buffer, for example, the store buffer.\n\n\nIn this code sequence, trusted_ptr is dereferenced while the attacker forces a page fault. The faulting load causes the processor to mis-speculate by forwarding untrusted_arg as the (transient) load result. The processor then uses untrusted_arg for the pointer dereference. After the fault has been handled and the load has been re-issued with the correct argument, secret-dependent information stored at the address of trusted_ptr remains in microarchitectural state and can be extracted by an attacker using a vulnerable code sequence."}]}, {"Entries": [{"IntroText": "Some processors try to predict when a store will forward data to a subsequent load, even when the address of the store or the load is not yet known. For example, on Intel processors this feature is called a Fast Store Forwarding Predictor [REF-1392], and on AMD processors the feature is called Predictive Store Forwarding [REF-1393]. A misprediction can cause incorrect or stale data to be forwarded from a store to a load, as illustrated in the following code snippet from [REF-1393]:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "void fn(int idx) {\n\n```\n\t unsigned char v;\n\t idx_array[0] = 4096;\n\t v = array[idx_array[idx] * (idx)];\n }\n```"}, {"BodyText": "In this example, assume that the parameter idx can only be 0 or 1, and assume that idx_array initially contains all 0s. Observe that the assignment to v in line 4 will be array[0], regardless of whether idx=0 or idx=1. Now suppose that an attacker repeatedly invokes fn with idx=0 to train the store forwarding predictor to predict that the store in line 3 will forward the data 4096 to the load idx_array[idx] in line 4. Then, when the attacker invokes fn with idx=1 the predictor may cause idx_array[idx] to transiently produce the incorrect value 4096, and therefore v will transiently be assigned the value array[4096], which otherwise would not have been accessible in line 4.\n\n\nAlthough this toy example is benign (it doesn't transmit array[4096] over a covert channel), an attacker may be able to use similar techniques to craft and train malicious code sequences to, for example, read data beyond a software sandbox boundary."}]}], "ObservedExamples": [{"Reference": "CVE-2020-0551", "Description": "A fault, microcode assist, or abort may allow transient load operations to forward malicious stale data to dependent operations executed by a victim, causing the victim to unintentionally access and potentially expose its own data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-0551"}, {"Reference": "CVE-2020-8698", "Description": "A fast store forwarding predictor may allow store operations to forward incorrect data to transient load operations, potentially exposing data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-8698"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities", "Comments": "Use only when the weakness arises from forwarding of incorrect/stale data, and the data is not architecturally restricted (that is, the forwarded data is accessible within the current processor context). \n\nIf a weakness arises from forwarding of incorrect/stale data that is not accessible within the current processor context, then CWE-1421 may be more appropriate for the mapping task.\n", "Reasons": ["Acceptable-Use"]}}
{"ID": "1423", "Name": "Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Shared microarchitectural predictor state may allow code to influence\n\t\t\t\ttransient execution across a hardware boundary, potentially exposing\n\t\t\t\tdata that is accessible beyond the boundary over a covert channel.\n\t\t\t", "ExtendedDescription": "\n\nMany commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.\n\n\nWhen separate software components (for example, two processes) share microarchitectural predictor state across a hardware boundary, code in one component may be able to influence microarchitectural predictor behavior in another component. If the predictor can cause transient execution, the shared predictor state may allow an attacker to influence transient execution in a victim, and in a manner that could allow the attacker to infer private data from the victim by monitoring observable discrepancies (CWE-203) in a covert channel [REF-1400].\n\n\nPredictor state may be shared when the processor transitions from one component to another (for example, when a process makes a system call to enter the kernel). Many commodity processors have features which prevent microarchitectural predictions that occur before a boundary from influencing predictions that occur after the boundary.\n\n\nPredictor state may also be shared between hardware threads, for example, sibling hardware threads on a processor that supports simultaneous multithreading (SMT). This sharing may be benign if the hardware threads are simultaneously executing in the same software component, or it could expose a weakness if one sibling is a malicious software component, and the other sibling is a victim software component. Processors that share microarchitectural predictors between hardware threads may have features which prevent microarchitectural predictions that occur on one hardware thread from influencing predictions that occur on another hardware thread.\n\n\nFeatures that restrict predictor state sharing across transitions or between hardware threads may be always-on, on by default, or may require opt-in from software.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1420", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "1420", "ViewID": "1194", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Operating_System", "Class": "Not OS-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Microcontroller Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Processor Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "Memory Hardware", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "System on Chip", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "\n\nThis weakness can be introduced during hardware architecture and design if predictor state is not properly isolated between modes (for example, user mode and kernel mode), if predictor state is not isolated between hardware threads, or if it is not isolated between other kinds of execution contexts supported by the processor.\n"}, {"Phase": "Implementation", "Note": "\n\nThis weakness can be introduced during system software implementation if predictor-state-sanitizing operations (for example, the indirect branch prediction barrier on Intel x86) are not invoked when switching from one context to another.\n"}, {"Phase": "System Configuration", "Note": "\n\nThis weakness can be introduced if the system has not been configured according to the hardware vendor's recommendations for mitigating the weakness.\n"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Memory"], "Likelihood": ["Medium"]}], "DetectionMethods": [{"Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected in hardware by manually inspecting processor specifications. Features that exhibit this weakness may have microarchitectural predictor state that is shared between hardware threads, execution contexts (for example, user and kernel), or other components that may host mutually distrusting software (or firmware, etc.).\n", "Effectiveness": "Moderate", "EffectivenessNotes": "Manual analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}, {"Method": "Automated Analysis", "Description": "\n\nSoftware vendors can release tools that detect presence of known weaknesses on a processor. For example, some of these tools can attempt to transiently execute a vulnerable code sequence and detect whether code successfully leaks data in a manner consistent with the weakness under test. Alternatively, some hardware vendors provide enumeration for the presence of a weakness (or lack of a weakness). These enumeration bits can be checked and reported by system software. For example, Linux supports these checks for many commodity processors:\n\n\n$ cat /proc/cpuinfo | grep bugs | head -n 1\n\n\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed\n", "Effectiveness": "High", "EffectivenessNotes": "This method can be useful for detecting whether a processor if affected by known weaknesses, but it may not be useful for detecting unknown weaknesses"}, {"Method": "Automated Analysis", "Description": "\n\nThis weakness can be detected in hardware by employing static or dynamic taint analysis methods [REF-1401]. These methods can label each predictor entry (or prediction history, etc.) according to the processor context that created it. Taint analysis or information flow analysis can then be applied to detect when predictor state created in one context can influence predictions made in another context.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "Automated static or dynamic taint analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\nThe hardware designer can attempt to prevent transient execution from causing observable discrepancies in specific covert channels.\n"}, {"Phase": ["Architecture and Design"], "Description": "\n\nHardware designers may choose to use microarchitectural bits to tag predictor entries. For example, each predictor entry may be tagged with a kernel-mode bit which, when set, indicates that the predictor entry was created in kernel mode. The processor can use this bit to enforce that predictions in the current mode must have been trained in the current mode. This can prevent malicious cross-mode training, such as when user-mode software attempts to create predictor entries that influence transient execution in the kernel. Predictor entry tags can also be used to associate each predictor entry with the SMT thread that created it, and thus the processor can enforce that each predictor entry can only be used by the SMT thread that created it. This can prevent an SMT thread from using predictor entries crafted by a malicious sibling SMT thread.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nTagging can be highly effective for predictor state that is comprised of discrete elements, such as an array of recently visited branch targets. Predictor state can also have different representations that are not conducive to tagging. For example, some processors keep a compressed digest of branch history which does not contain discrete elements that can be individually tagged.\n"}, {"Phase": ["Architecture and Design"], "Description": "\n\nHardware designers may choose to sanitize microarchitectural predictor state (for example, branch prediction history) when the processor transitions to a different context, for example, whenever a system call is invoked. Alternatively, the hardware may expose instruction(s) that allow software to sanitize predictor state according to the user's threat model. For example, this can allow operating system software to sanitize predictor state when performing a context switch from one process to another.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nThis technique may not be able to mitigate weaknesses that arise from predictor state that is shared across SMT threads. Sanitizing predictor state on context switches may also negatively impact performance, either by removing predictor entries that could be reused when returning to the previous context, or by slowing down the context switch itself.\n"}, {"Phase": ["Implementation"], "Description": "\n\nSystem software can mitigate this weakness by invoking predictor-state-sanitizing operations (for example, the indirect branch prediction barrier on Intel x86) when switching from one context to another, according to the hardware vendor's recommendations.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nThis technique may not be able to mitigate weaknesses that arise from predictor state shared across SMT threads. Sanitizing predictor state may also negatively impact performance in some circumstances.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nIf the weakness is exposed by a single instruction (or a small set of instructions), then the compiler (or JIT, etc.) can be configured to prevent the affected instruction(s) from being generated. One prominent example of this mitigation is retpoline ([REF-1414]).\n", "Effectiveness": "Limited", "EffectivenessNotes": "\n\nThis technique is only effective for software that is compiled with this mitigation. Additionally, an alternate instruction sequence may mitigate the weakness on some processors but not others, even when the processors share the same ISA. For example, retpoline has been documented as effective on some x86 processors, but not fully effective on other x86 processors.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse control-flow integrity (CFI) techniques to constrain the behavior of instructions that redirect the instruction pointer, such as indirect branch instructions.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nSome CFI techniques may not be able to constrain transient execution, even though they are effective at constraining architectural execution. Or they may be able to provide some additional protection against a transient execution weakness, but without comprehensively mitigating the weakness. For example, Clang-CFI provides strong architectural CFI properties and can make some transient execution weaknesses more difficult to exploit [REF-1398].\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nUse software techniques (including the use of serialization instructions) that are intended to reduce the number of instructions that can be executed transiently after a processor event or misprediction.\n", "Effectiveness": "Incidental", "EffectivenessNotes": "\n\nSome transient execution weaknesses can be exploited even if a single instruction is executed transiently after a processor event or mis-prediction. This mitigation strategy has many other pitfalls that prevent it from eliminating this weakness entirely. For example, see [REF-1389].\n"}, {"Phase": ["System Configuration"], "Description": "\n\nSome systems may allow the user to disable predictor sharing. For example, this could be a BIOS configuration, or a model-specific register (MSR) that can be configured by the operating system or virtual machine monitor.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nDisabling predictor sharing can negatively impact performance for some workloads that benefit from shared predictor state.\n"}, {"Phase": ["Patching and Maintenance"], "Description": "\n\nThe hardware vendor may provide a patch to, for example, sanitize predictor state when the processor transitions to a different context, or to prevent predictor entries from being shared across SMT threads. A patch may also introduce new ISA that allows software to toggle a mitigation.\n", "Effectiveness": "Moderate", "EffectivenessNotes": "\n\nThis mitigation may only be fully effective if the patch prevents predictor sharing across all contexts that are affected by the weakness. Additionally, sanitizing predictor state and/or preventing shared predictor state can negatively impact performance in some circumstances.\n"}, {"Phase": ["Documentation"], "Description": "\n\nIf a hardware feature can allow microarchitectural predictor state to be shared between contexts, SMT threads, or other architecturally defined boundaries, the hardware designer may opt to disclose this behavior in architecture documentation. This documentation can inform users about potential consequences and effective mitigations.\n", "Effectiveness": "High"}, {"Phase": ["Requirements"], "Description": "\n\nProcessor designers, system software vendors, or other agents may choose to restrict the ability of unprivileged software to access to high-resolution timers that are commonly used to monitor covert channels.\n"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Branch Target Injection (BTI) is a vulnerability that can allow an SMT hardware thread to maliciously train the indirect branch predictor state that is shared with its sibling hardware thread. A cross-thread BTI attack requires the attacker to find a vulnerable code sequence within the victim software. For example, the authors of [REF-1415] identified the following code sequence in the Windows library ntdll.dll:"}, {"Nature": "Bad", "Language": "x86 Assembly", "ExampleCode": "```\n\t adc edi,dword ptr [ebx+edx+13BE13BDh]\n\t adc dl,byte ptr [edi]\n\t ...\n indirect_branch_site:\n\t jmp dword ptr [rsi] # at this point attacker knows edx, controls edi and ebx\n```"}, {"BodyText": "To successfully exploit this code sequence to disclose the victim's private data, the attacker must also be able to find an indirect branch site within the victim, where the attacker controls the values in edi and ebx, and the attacker knows the value in edx as shown above at the indirect branch site.\n\n\nA proof-of-concept cross-thread BTI attack might proceed as follows:\n\n\n  1. The attacker thread and victim thread must be co-scheduled on the same physical processor core. \n\n  1. The attacker thread must train the shared branch predictor so that when the victim thread reaches indirect_branch_site, the jmp instruction will be predicted to target example_code_sequence instead of the correct architectural target. The training procedure may vary by processor, and the attacker may need to reverse-engineer the branch predictor to identify a suitable training algorithm. \n\n  1. This step assumes that the attacker can control some values in the victim program, specifically the values in edi and ebx at indirect_branch_site. When the victim reaches indirect_branch_site the processor will (mis)predict example_code_sequence as the target and (transiently) execute the adc instructions. If the attacker chooses ebx so that `ebx = m \n   -  0x13BE13BD - edx, then the first adc will load 32 bits from address m in the victim's address space and add *m (the data loaded from) to the attacker-controlled base address in edi. The second adc instruction accesses a location in memory whose address corresponds to *m`. \n\n\n\n  1. The adversary uses a covert channel analysis technique such as Flush+Reload ([REF-1416]) to infer the value of the victim's private data *m."}]}, {"Entries": [{"IntroText": "BTI can also allow software in one execution context to maliciously train branch predictor entries that can be used in another context. For example, on some processors user-mode software may be able to train predictor entries that can also be used after transitioning into kernel mode, such as after invoking a system call. This vulnerability does not necessarily require SMT and may instead be performed in synchronous steps, though it does require the attacker to find an exploitable code sequence in the victim's code, for example, in the kernel."}]}], "ObservedExamples": [{"Reference": "CVE-2017-5754", "Description": "(Branch Target Injection, BTI, Spectre v2). Shared microarchitectural indirect branch predictor state may allow code to influence transient execution across a process, VM, or privilege boundary, potentially exposing data that is accessible beyond the boundary.", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-5754"}, {"Reference": "CVE-2022-0001", "Description": "(Branch History Injection, BHI, Spectre-BHB). Shared branch history state may allow user-mode code to influence transient execution in the kernel, potentially exposing kernel data over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-0001"}, {"Reference": "CVE-2021-33149", "Description": "(RSB underflow, Retbleed). Shared return stack buffer state may allow code that executes before a prediction barrier to influence transient execution after the prediction barrier, potentially exposing data that is accessible beyond the barrier over a covert channel.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-33149"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities", "Comments": "Use only when the weakness allows code in one processor context to influence the predictions of code in another processor context via predictor state that is shared between the two contexts. For example, Branch Target Injection, an instance of CWE-1423, can be mitigated by tagging each indirect branch predictor entry according to the processor context in which the entry was created, thus preventing entries created in one context from being used in a different context. However, the mitigated indirect branch predictor can still expose different weaknesses where malicious predictor entries created in one context are used later in the same context (context tags cannot prevent this). One such example is Intra-mode Branch Target Injection. Weaknesses of this sort can map to CWE-1420.", "Reasons": ["Acceptable-Use"], "Suggestions": [{"CweID": "1420", "Comment": "If a weakness involves a microarchitectural predictor whose state is not shared across processor contexts, then CWE-1420 may be more appropriate for the mapping task."}]}}
{"ID": "1426", "Name": "Improper Validation of Generative AI Output", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product invokes a generative AI/ML\n\t\t\tcomponent whose behaviors and outputs cannot be directly\n\t\t\tcontrolled, but the product does not validate or\n\t\t\tinsufficiently validates the outputs to ensure that they\n\t\t\talign with the intended security, content, or privacy\n\t\t\tpolicy.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "707", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Architecture", "Class": "Not Architecture-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Name": "AI/ML", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "\n\nDevelopers may rely heavily on protection mechanisms such as input filtering and model alignment, assuming they are more effective than they actually are.\n"}, {"Phase": "Implementation", "Note": "\n\nDevelopers may rely heavily on protection mechanisms such as input filtering and model alignment, assuming they are more effective than they actually are.\n"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Execute Unauthorized Code or Commands", "Varies by Context"], "Note": "\n\nIn an agent-oriented setting, output could be used to cause unpredictable agent invocation, i.e., to control or influence agents that might be invoked from the output. The impact varies depending on the access that is granted to the tools, such as creating a database or writing files.\n"}], "DetectionMethods": [{"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "Use known techniques for prompt injection and other attacks, and adjust the attacks to be more specific to the model or system."}, {"Method": "Dynamic Analysis with Automated Results Interpretation", "Description": "Use known techniques for prompt injection and other attacks, and adjust the attacks to be more specific to the model or system."}, {"Method": "Architecture or Design Review", "Description": "Review of the product design can be effective, but it works best in conjunction with dynamic analysis."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Since the output from a generative AI component (such as an LLM) cannot be trusted, ensure that it operates in an untrusted or non-privileged space."}, {"Phase": ["Operation"], "Description": "Use \"semantic comparators,\" which are mechanisms that provide semantic comparison to identify objects that might appear different but are semantically similar."}, {"Phase": ["Operation"], "Description": "\n\nUse components that operate externally to the system to monitor the output and act as a moderator. These components are called different terms, such as supervisors or guardrails.\n"}, {"Phase": ["Build and Compilation"], "Description": "\n\nDuring model training, use an appropriate variety of good and bad examples to guide preferred outputs.\n"}], "ObservedExamples": [{"Reference": "CVE-2024-3402", "Description": "chain: GUI for ChatGPT API performs input validation but does not properly \"sanitize\" or validate model output data (CWE-1426), leading to XSS (CWE-79).", "Link": "https://www.cve.org/CVERecord?id=CVE-2024-3402"}], "MappingNotes": {"Usage": "Discouraged", "Rationale": "There is potential for this CWE entry to be modified in the future for further clarification as the research community continues to better understand weaknesses in this domain.", "Comments": "\n\nThis CWE entry is only related to \"validation\" of output and might be used mistakenly for other kinds of output-related weaknesses. Careful attention should be paid to whether this CWE should be used for vulnerabilities related to \"prompt injection,\" which is an attack that works against many different weaknesses. See Maintenance Notes and Research Gaps. Analysts should closely investigate the root cause to ensure it is not ultimately due to other well-known weaknesses. The following suggestions are not comprehensive.\n", "Reasons": ["Potential Major Changes", "Frequent Misinterpretation"], "Suggestions": [{"CweID": "77", "Comment": "Command Injection. Use this CWE for most cases of 'prompt injection' attacks in which additional prompts are added to input to, or output from, the model. If OS command injection, consider CWE-78."}, {"CweID": "94", "Comment": "Code Injection. Use this CWE for cases in which output from genAI components is directly fed into components that parse and execute code."}, {"CweID": "116", "Comment": "Improper Encoding or Escaping of Output. Use this CWE when the product is expected to encode or escape genAI outputs."}]}, "Notes": [{"Type": "Research Gap", "Note": "This entry is related to AI/ML, which is not well understood from a weakness perspective. Typically, for new/emerging technologies including AI/ML, early vulnerability discovery and research does not focus on root cause analysis (i.e., weakness identification). For AI/ML, the recent focus has been on attacks and exploitation methods, technical impacts, and mitigations. As a result, closer research or focused efforts by SMEs is necessary to understand the underlying weaknesses. Diverse and dynamic terminology and rapidly-evolving technology further complicate understanding. Finally, there might not be enough real-world examples with sufficient details from which weakness patterns may be discovered. For example, many real-world vulnerabilities related to \"prompt injection\" appear to be related to typical injection-style attacks in which the only difference is that the \"input\" to the vulnerable component comes from model output instead of direct adversary input, similar to \"second-order SQL injection\" attacks."}, {"Type": "Maintenance", "Note": "This entry was created by members of the CWE AI Working Group during June and July 2024. The CWE Project Lead, CWE Technical Lead, AI WG co-chairs, and many WG members decided that for purposes of timeliness, it would be more helpful to the CWE community to publish the new entry in CWE 4.15 quickly and add to it in subsequent versions."}]}
{"ID": "143", "Name": "Improper Neutralization of Record Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as record delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that record delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-1982", "Description": "Carriage returns in subject field allow adding new records to data file.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1982"}, {"Reference": "CVE-2001-0527", "Description": "Attacker inserts carriage returns and \"|\" field separator characters to add new user/privileges.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0527"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "144", "Name": "Improper Neutralization of Line Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as line delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanAlsoBe", "CweID": "93", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that line delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0267", "Description": "Linebreak in field of PHP script allows admin privileges when written to data file.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0267"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "Depending on the language and syntax being used, this could be the same as the record delimiter (CWE-143)."}]}
{"ID": "145", "Name": "Improper Neutralization of Section Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as section delimiters when they are sent to a downstream component.", "ExtendedDescription": "\n\nAs data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.\n\n\nOne example of a section delimiter is the boundary string in a multipart MIME message. In many cases, doubled line delimiters can serve as a section delimiter.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanAlsoBe", "CweID": "93", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that section delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "Depending on the language and syntax being used, this could be the same as the record delimiter (CWE-143)."}]}
{"ID": "146", "Name": "Improper Neutralization of Expression/Command Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as expression or command delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "140", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Other"], "Impact": ["Execute Unauthorized Code or Commands", "Alter Execution Logic"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that inter-expression and inter-command delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "RelatedAttackPatterns": ["15", "6"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "A shell metacharacter (covered in CWE-150) is one example of a potential delimiter that may need to be neutralized."}]}
{"ID": "147", "Name": "Improper Neutralization of Input Terminators", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as input terminators when they are sent to a downstream component.", "ExtendedDescription": "For example, a \".\" in SMTP signifies the end of mail message data, whereas a null character can be used for the end of a string.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that terminators will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2000-0319", "Description": "MFV. mail server does not properly identify terminator string to signify end of message, causing corruption, possibly in conjunction with off-by-one error.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0319"}, {"Reference": "CVE-2000-0320", "Description": "MFV. mail server does not properly identify terminator string to signify end of message, causing corruption, possibly in conjunction with off-by-one error.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0320"}, {"Reference": "CVE-2001-0996", "Description": "Mail server does not quote end-of-input terminator if it appears in the middle of a message.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0996"}, {"Reference": "CVE-2002-0001", "Description": "Improperly terminated comment or phrase allows commands.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0001"}], "RelatedAttackPatterns": ["460"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "148", "Name": "Improper Neutralization of Input Leaders", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product does not properly handle when a leading character or sequence (\"leader\") is missing or malformed, or if multiple leaders are used when only one should be allowed.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that leading characters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "149", "Name": "Improper Neutralization of Quoting Syntax", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Quotes injected into a product can be used to compromise a system. As data are parsed, an injected/absent/duplicate/malformed use of quotes may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that quotes will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-0956", "Description": "Database allows remote attackers to cause a denial of service (application crash) via a MATCH AGAINST query with an opening double quote but no closing double quote.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0956"}, {"Reference": "CVE-2003-1016", "Description": "MIE. MFV too? bypass AV/security with fields that should not be quoted, duplicate quotes, missing leading/trailing quotes.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1016"}], "RelatedAttackPatterns": ["468"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-39232", "Description": "Discourse is an open source discussion platform. Starting with version 2.9.0.beta5 and prior to version 2.9.0.beta10, an incomplete quote can generate a JavaScript error which will crash the current page in the browser in some cases. Version 2.9.0.beta10 added a fix and tests to ensure incomplete quotes won't break the app. As a workaround, the quote can be fixed via the rails console."}]}
{"ID": "15", "Name": "External Control of System or Configuration Setting", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "One or more system settings or configuration elements can be externally controlled by a user.", "ExtendedDescription": "Allowing external control of system settings can disrupt service or cause an application to behave in unexpected, and potentially malicious ways.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "642", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "610", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "20", "ViewID": "700", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "Setting manipulation vulnerabilities occur when an attacker can control values that govern the behavior of the system, manage specific resources, or in some way affect the functionality of the application."}, {"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"MitigationID": "MIT-46", "Phase": ["Architecture and Design"], "Strategy": "Separation of Privilege", "Description": "\n\nCompartmentalize the system to have \"safe\" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.\n\n\nEnsure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.\n"}, {"Phase": ["Implementation", "Architecture and Design"], "Description": "Because setting manipulation covers a diverse set of functions, any attempt at illustrating it will inevitably be incomplete. Rather than searching for a tight-knit relationship between the functions addressed in the setting manipulation category, take a step back and consider the sorts of system values that an attacker should not be allowed to control."}, {"Phase": ["Implementation", "Architecture and Design"], "Description": "In general, do not allow user-provided or otherwise untrusted data to control sensitive values. The leverage that an attacker gains by controlling these values is not always immediately obvious, but do not underestimate the creativity of the attacker."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following C code accepts a number as one of its command line parameters and sets it as the host ID of the current machine."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t...\n\tsethostid(argv[1]);\n\t...\n```"}, {"BodyText": "Although a process must be privileged to successfully invoke sethostid(), unprivileged users may be able to invoke the program. The code in this example allows user input to directly control the value of a system setting. If an attacker provides a malicious value for host ID, the attacker can misidentify the affected machine on the network or cause other unintended behavior."}]}, {"Entries": [{"IntroText": "The following Java code snippet reads a string from an HttpServletRequest and sets it as the active catalog for a database Connection."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\t...\n\tconn.setCatalog(request.getParameter(\"catalog\"));\n\t...\n```"}, {"BodyText": "In this example, an attacker could cause an error by providing a nonexistent catalog name or connect to an unauthorized portion of the database."}]}], "RelatedAttackPatterns": ["13", "146", "176", "203", "270", "271", "579", "69", "76", "77"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-37112", "Description": "Hisuite module has a External Control of System or Configuration Setting vulnerability.Successful exploitation of this vulnerability may lead to Firmware leak."}, {"Reference": "CVE-2021-39971", "Description": "Password vault has a External Control of System or Configuration Setting vulnerability.Successful exploitation of this vulnerability could compromise confidentiality."}, {"Reference": "CVE-2022-48198", "Description": "The ntpd_driver component before 1.3.0 and 2.x before 2.2.0 for Robot Operating System (ROS) allows attackers, who control the source code of a different node in the same ROS application, to change a robot's behavior. This occurs because a topic name depends on the attacker-controlled time_ref_topic parameter."}, {"Reference": "CVE-2022-29850", "Description": "Various Lexmark products through 2022-04-27 allow an attacker who has already compromised an affected Lexmark device to maintain persistence across reboots."}]}
{"ID": "150", "Name": "Improper Neutralization of Escape, Meta, or Control Sequences", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as escape, meta, or control character sequences when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that escape, meta and control characters/sequences will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0542", "Description": "The mail program processes special \"~\" escape sequence even when not in interactive mode.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0542"}, {"Reference": "CVE-2000-0703", "Description": "Setuid program does not filter escape sequences before calling mail program.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0703"}, {"Reference": "CVE-2002-0986", "Description": "Mail function does not filter control characters from arguments, allowing mail message content to be modified.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0986"}, {"Reference": "CVE-2003-0020", "Description": "Multi-channel issue. Terminal escape sequences not filtered from log files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0020"}, {"Reference": "CVE-2003-0083", "Description": "Multi-channel issue. Terminal escape sequences not filtered from log files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0083"}, {"Reference": "CVE-2003-0021", "Description": "Terminal escape sequences not filtered by terminals when displaying files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0021"}, {"Reference": "CVE-2003-0022", "Description": "Terminal escape sequences not filtered by terminals when displaying files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0022"}, {"Reference": "CVE-2003-0023", "Description": "Terminal escape sequences not filtered by terminals when displaying files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0023"}, {"Reference": "CVE-2003-0063", "Description": "Terminal escape sequences not filtered by terminals when displaying files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0063"}, {"Reference": "CVE-2000-0476", "Description": "Terminal escape sequences not filtered by terminals when displaying files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0476"}, {"Reference": "CVE-2001-1556", "Description": "MFV. (multi-channel). Injection of control characters into log files that allow information hiding when using raw Unix programs to read the files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1556"}], "RelatedAttackPatterns": ["134", "41", "81", "93"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-34298", "Description": "The NT auth module in OpenAM before 14.6.6 allows a \"replace Samba username attack.\""}, {"Reference": "CVE-2022-23465", "Description": "SwiftTerm is a Xterm/VT100 Terminal emulator. Prior to commit a94e6b24d24ce9680ad79884992e1dff8e150a31, an attacker could modify the window title via a certain character escape sequence and then insert it back to the command line in the user's terminal, e.g. when the user views a file containing the malicious sequence, which could allow the attacker to execute arbitrary commands. Version a94e6b24d24ce9680ad79884992e1dff8e150a31 contains a patch for this issue. There are no known workarounds available."}]}
{"ID": "151", "Name": "Improper Neutralization of Comment Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as comment delimiters when they are sent to a downstream component.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that comments will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0001", "Description": "Mail client command execution due to improperly terminated comment in address list.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0001"}, {"Reference": "CVE-2004-0162", "Description": "MIE. RFC822 comment fields may be processed as other fields by clients.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0162"}, {"Reference": "CVE-2004-1686", "Description": "Well-placed comment bypasses security warning.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1686"}, {"Reference": "CVE-2005-1909", "Description": "Information hiding using a manipulation involving injection of comment code into product. Note: these vulnerabilities are likely vulnerable to more general XSS problems, although a regexp might allow \">!--\" while denying most other tags.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1909"}, {"Reference": "CVE-2005-1969", "Description": "Information hiding using a manipulation involving injection of comment code into product. Note: these vulnerabilities are likely vulnerable to more general XSS problems, although a regexp might allow \"<!--\" while denying most other tags.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1969"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "152", "Name": "Improper Neutralization of Macro Symbols", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as macro symbols when they are sent to a downstream component.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Developers should anticipate that macro symbols will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-30", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0770", "Description": "Server trusts client to expand macros, allows macro characters to be expanded to trigger resultant information exposure.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0770"}, {"Reference": "CVE-2008-2018", "Description": "Attacker can obtain sensitive information from a database by using a comment containing a macro, which inserts the data during expansion.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-2018"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "Under-studied."}]}
{"ID": "153", "Name": "Improper Neutralization of Substitution Characters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as substitution characters when they are sent to a downstream component.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that substitution characters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0770", "Description": "Server trusts client to expand macros, allows macro characters to be expanded to trigger resultant information exposure.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0770"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "Under-studied."}]}
{"ID": "154", "Name": "Improper Neutralization of Variable Name Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as variable name delimiters when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected delimiter may cause the process to take unexpected actions that result in an attack. Example: \"$\" for an environment variable.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that variable name delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2005-0129", "Description": "\"%\" variable is expanded by wildcard function into disallowed commands.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0129"}, {"Reference": "CVE-2002-0770", "Description": "Server trusts client to expand macros, allows macro characters to be expanded to trigger resultant information exposure.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0770"}], "RelatedAttackPatterns": ["15"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "Under-studied."}]}
{"ID": "155", "Name": "Improper Neutralization of Wildcards or Matching Symbols", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as wildcards or matching symbols when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected element may cause the process to take unexpected actions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that wildcard or matching elements will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0433", "Description": "Bypass file restrictions using wildcard character.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0433"}, {"Reference": "CVE-2002-1010", "Description": "Bypass file restrictions using wildcard character.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1010"}, {"Reference": "CVE-2001-0334", "Description": "Wildcards generate long string on expansion.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0334"}, {"Reference": "CVE-2004-1962", "Description": "SQL injection involving \"/**/\" sequences.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1962"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "Under-studied."}], "Top25Examples": [{"Reference": "CVE-2022-21646", "Description": "SpiceDB is a database system for managing security-critical application permissions. Any user making use of a wildcard relationship under the right hand branch of an `exclusion` or within an `intersection` operation will see `Lookup`/`LookupResources` return a resource as \"accessible\" if it is *not* accessible by virtue of the inclusion of the wildcard in the intersection or the right side of the exclusion. In `v1.3.0`, the wildcard is ignored entirely in lookup's dispatch, resulting in the `banned` wildcard being ignored in the exclusion. Version 1.4.0 contains a patch for this issue. As a workaround, don't make use of wildcards on the right side of intersections or within exclusions."}]}
{"ID": "156", "Name": "Improper Neutralization of Whitespace", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as whitespace when they are sent to a downstream component.", "ExtendedDescription": "This can include space, tab, etc.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "White space"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that whitespace will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-0637", "Description": "MIE. virus protection bypass with RFC violations involving extra whitespace, or missing whitespace.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0637"}, {"Reference": "CVE-2004-0942", "Description": "CPU consumption with MIME headers containing lines with many space characters, probably due to algorithmic complexity (RESOURCE.AMP.ALG).", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0942"}, {"Reference": "CVE-2003-1015", "Description": "MIE. whitespace interpreted differently by mail clients.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1015"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "Can overlap other separator characters or delimiters."}], "Top25Examples": [{"Reference": "CVE-2022-1243", "Description": "CRHTLF can lead to invalid protocol extraction potentially leading to XSS in GitHub repository medialize/uri.js prior to 1.19.11."}, {"Reference": "CVE-2022-31180", "Description": "Shescape is a simple shell escape package for JavaScript. Affected versions were found to have insufficient escaping of white space when interpolating output. This issue only impacts users that use the `escape` or `escapeAll` functions with the `interpolation` option set to `true`. The result is that if an attacker is able to include whitespace in their input they can: 1. Invoke shell-specific behaviour through shell-specific special characters inserted directly after whitespace. 2. Invoke shell-specific behaviour through shell-specific special characters inserted or appearing after line terminating characters. 3. Invoke arbitrary commands by inserting a line feed character. 4. Invoke arbitrary commands by inserting a carriage return character. Behaviour number 1 has been patched in [v1.5.7] which you can upgrade to now. No further changes are required. Behaviour number 2, 3, and 4 have been patched in [v1.5.8] which you can upgrade to now. No further changes are required. The best workaround is to avoid having to use the `interpolation: true` option - in most cases using an alternative is possible, see [the recipes](https://github.com/ericcornelissen/shescape#recipes) for recommendations. Alternatively, users may strip all whitespace from user input. Note that this is error prone, for example: for PowerShell this requires stripping `'\\\\u0085'` which is not included in JavaScript's definition of `\\\\s` for Regular Expressions."}, {"Reference": "CVE-2022-24723", "Description": "URI.js is a Javascript URL mutation library. Before version 1.19.9, whitespace characters are not removed from the beginning of the protocol, so URLs are not parsed properly. This issue has been patched in version 1.19.9. Removing leading whitespace from values before passing them to URI.parse can be used as a workaround."}]}
{"ID": "157", "Name": "Failure to Sanitize Paired Delimiters", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product does not properly handle the characters that are used to mark the beginning and ending of a group of entities, such as parentheses, brackets, and braces.", "ExtendedDescription": "\n\nPaired delimiters might include:\n\n\n  - < and > angle brackets\n\n  - ( and ) parentheses\n\n  - { and } braces\n\n  - [ and ] square brackets\n\n  - \" \" double quotes\n\n  - ' ' single quotes\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that grouping elements will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-0956", "Description": "Crash via missing paired delimiter (open double-quote but no closing double-quote).", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0956"}, {"Reference": "CVE-2000-1165", "Description": "Crash via message without closing \">\".", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1165"}, {"Reference": "CVE-2005-2933", "Description": "Buffer overflow via mailbox name with an opening double quote but missing a closing double quote, causing a larger copy than expected.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2933"}], "RelatedAttackPatterns": ["15"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "Under-studied."}]}
{"ID": "158", "Name": "Improper Neutralization of Null Byte or NUL Character", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes NUL characters or null bytes when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, an injected NUL character or null byte may cause the product to believe the input is terminated earlier than it actually is, or otherwise cause the input to be misinterpreted. This could then be used to inject potentially dangerous input that occurs after the null byte or otherwise bypass validation routines and other protection mechanisms.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2008-1284", "Description": "NUL byte in theme name causes directory traversal impact to be worse", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-1284"}, {"Reference": "CVE-2005-2008", "Description": "Source code disclosure using trailing null.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2008"}, {"Reference": "CVE-2005-3293", "Description": "Source code disclosure using trailing null.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3293"}, {"Reference": "CVE-2005-2061", "Description": "Trailing null allows file include.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2061"}, {"Reference": "CVE-2002-1774", "Description": "Null character in MIME header allows detection bypass.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1774"}, {"Reference": "CVE-2000-0149", "Description": "Web server allows remote attackers to view the source code for CGI programs via a null character (%00) at the end of a URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0149"}, {"Reference": "CVE-2000-0671", "Description": "Web server earlier allows allows remote attackers to bypass access restrictions, list directory contents, and read source code by inserting a null character (%00) in the URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0671"}, {"Reference": "CVE-2001-0738", "Description": "Logging system allows an attacker to cause a denial of service (hang) by causing null bytes to be placed in log messages.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0738"}, {"Reference": "CVE-2001-1140", "Description": "Web server allows source code for executable programs to be read via a null character (%00) at the end of a request.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1140"}, {"Reference": "CVE-2002-1031", "Description": "Protection mechanism for limiting file access can be bypassed using a null character (%00) at the end of the directory name.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1031"}, {"Reference": "CVE-2002-1025", "Description": "Application server allows remote attackers to read JSP source code via an encoded null byte in an HTTP GET request, which causes the server to send the .JSP file unparsed.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1025"}, {"Reference": "CVE-2003-0768", "Description": "XSS protection mechanism only checks for sequences with an alphabetical character following a (<), so a non-alphabetical or null character (%00) following a < may be processed.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0768"}, {"Reference": "CVE-2004-0189", "Description": "Decoding function in proxy allows regular expression bypass in ACLs via URLs with null characters.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0189"}, {"Reference": "CVE-2005-3153", "Description": "Null byte bypasses PHP regexp check (interaction error).", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3153"}, {"Reference": "CVE-2005-4155", "Description": "Null byte bypasses PHP regexp check (interaction error).", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-4155"}], "RelatedAttackPatterns": ["52", "53"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This can be a factor in multiple interpretation errors, other interaction errors, filename equivalence, etc."}], "Top25Examples": [{"Reference": "CVE-2022-36804", "Description": "Multiple API endpoints in Atlassian Bitbucket Server and Data Center 7.0.0 before version 7.6.17, from version 7.7.0 before version 7.17.10, from version 7.18.0 before version 7.21.4, from version 8.0.0 before version 8.0.3, from version 8.1.0 before version 8.1.3, and from version 8.2.0 before version 8.2.2, and from version 8.3.0 before 8.3.1 allows remote attackers with read permissions to a public or private Bitbucket repository to execute arbitrary code by sending a malicious HTTP request. This vulnerability was reported via our Bug Bounty Program by TheGrandPew."}, {"Reference": "CVE-2022-2778", "Description": "In affected versions of Octopus Deploy it is possible to bypass rate limiting on login using null bytes."}, {"Reference": "CVE-2022-41716", "Description": "Due to unsanitized NUL values, attackers may be able to maliciously set environment variables on Windows. In syscall.StartProcess and os/exec.Cmd, invalid environment variable values containing NUL values are not properly checked for. A malicious environment variable value can exploit this behavior to set a value for a different environment variable. For example, the environment variable string \"A=B\\\\x00C=D\" sets the variables \"A=B\" and \"C=D\"."}, {"Reference": "CVE-2022-39243", "Description": "NuProcess is an external process execution implementation for Java. In all the versions of NuProcess where it forks processes by using the JVM's Java_java_lang_UNIXProcess_forkAndExec method (1.2.0+), attackers can use NUL characters in their strings to perform command line injection. Java's ProcessBuilder isn't vulnerable because of a check in ProcessBuilder.start. NuProcess is missing that check. This vulnerability can only be exploited to inject command line arguments on Linux. Version 2.0.5 contains a patch. As a workaround, users of the library can sanitize command strings to remove NUL characters prior to passing them to NuProcess for execution."}, {"Reference": "CVE-2022-4170", "Description": "The rxvt-unicode package is vulnerable to a remote code execution, in the Perl background extension, when an attacker can control the data written to the user's terminal and certain options are set."}]}
{"ID": "159", "Name": "Improper Handling of Invalid Use of Special Elements", "Abstraction": "Class", "Structure": "Simple", "Status": "Draft", "Description": "The product does not properly filter, remove, quote, or otherwise manage the invalid use of special elements in user-controlled input, which could cause adverse effect on its behavior and integrity.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-1362", "Description": "Crash via message type without separator character", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1362"}, {"Reference": "CVE-2000-0116", "Description": "Extra \"<\" in front of SCRIPT tag bypasses XSS prevention.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0116"}], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Maintenance", "Note": "The list of children for this entry is far from complete. However, the types of special elements might be too precise for use within CWE."}, {"Type": "Terminology", "Note": "Precise terminology for the underlying weaknesses does not exist. Therefore, these weaknesses use the terminology associated with the manipulation."}, {"Type": "Research Gap", "Note": "Customized languages and grammars, even those that are specific to a particular product, are potential sources of weaknesses that are related to special elements. However, most researchers concentrate on the most commonly used representations for data transmission, such as HTML and SQL. Any representation that is commonly used is likely to be a rich source of weaknesses; researchers are encouraged to investigate previously unexplored representations."}]}
{"ID": "160", "Name": "Improper Neutralization of Leading Special Elements", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, improperly handled leading special elements may cause the process to take unexpected actions that result in an attack.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that leading special elements will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-1345", "Description": "Multiple FTP clients write arbitrary files via absolute paths in server responses", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1345"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "161", "Name": "Improper Neutralization of Multiple Leading Special Elements", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, improperly handled multiple leading special elements may cause the process to take unexpected actions that result in an attack.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "160", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that multiple leading special elements will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-1238", "Description": "Server allows remote attackers to bypass access restrictions for files via an HTTP request with a sequence of multiple / (slash) characters such as http://www.example.com///file/.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1238"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "162", "Name": "Improper Neutralization of Trailing Special Elements", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes trailing special elements that could be interpreted in unexpected ways when they are sent to a downstream component.", "ExtendedDescription": "As data is parsed, improperly handled trailing special elements may cause the process to take unexpected actions that result in an attack.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "138", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Description": "Developers should anticipate that trailing special elements will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system."}, {"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-28", "Phase": ["Implementation"], "Strategy": "Output Encoding", "Description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-0847", "Description": "web framework for .NET allows remote attackers to bypass authentication for .aspx files in restricted directories via a request containing a (1) \"\\\" (backslash) or (2) \"%5C\" (encoded backslash)", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0847"}, {"Reference": "CVE-2002-1451", "Description": "Trailing space (\"+\" in query string) leads to source code disclosure.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1451"}, {"Reference": "CVE-2001-0446", "Description": "Application server allows remote attackers to read source code for .jsp files by appending a / to the requested URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0446"}], "RelatedAttackPatterns": ["635"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-27779", "Description": "libcurl wrongly allows cookies to be set for Top Level Domains (TLDs) if thehost name is provided with a trailing dot.curl can be told to receive and send cookies. curl's \"cookie engine\" can bebuilt with or without [Public Suffix List](https://publicsuffix.org/)awareness. If PSL support not provided, a more rudimentary check exists to atleast prevent cookies from being set on TLDs. This check was broken if thehost name in the URL uses a trailing dot.This can allow arbitrary sites to set cookies that then would get sent to adifferent and unrelated site or domain."}]}
